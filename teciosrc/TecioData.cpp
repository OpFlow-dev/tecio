#include "TecioData.h"
#include "ThirdPartyHeadersBegin.h"
#include <numeric>
#include <sstream>
#include <boost/assign.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/bind/bind.hpp>
#include <boost/foreach.hpp>
#include <boost/function.hpp>
#include <boost/make_shared.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "FieldData_s.h"
#include "RawArray.h"
using namespace tecplot::___3934; struct ___1291 { }; namespace tecplot { namespace tecioszl { ___3971::___3971() {} ___3971::___3971( std::string const& ___4178, std::string const& ___4350, int32_t            defaultVarType) : ___2650(___4178) , m_defaultVarType(defaultVarType) , m_nextZoneIndex(0) , m_lastZoneFlushedToDisk(-1) , ___2400(new AuxData_s) { if (!VALID_ENUM((FieldDataType_e)defaultVarType, FieldDataType_e)) { std::ostringstream ___2893; ___2893 << "Invalid default variable type: " << defaultVarType; throw std::runtime_error(___2893.str()); } char const* ___3476; if (___4350.find_first_of('\n') != std::string::npos) ___3476 = "\n"; else if (___4350.find_first_of(',') != std::string::npos) ___3476 = ","; else ___3476 = " "; std::string trimmedVariables(___4350); boost::trim_if(trimmedVariables, boost::is_any_of(___3476)); boost::split(___2675, trimmedVariables, boost::is_any_of(___3476), boost::token_compress_on); for (std::vector<std::string>::iterator ___2686 = ___2675.begin(); ___2686 != ___2675.end(); ++___2686) { boost::trim(*___2686); ___2673.push_back(boost::make_shared<AuxData_s>()); } } ___3971::~___3971() { } void ___3971::___19( char    const* ___4690, int32_t const  ___4692, int64_t const  ___1908, int64_t const  ___2115, int64_t const  ___2160, int32_t        numSections, int32_t const* cellShapePerSection, int32_t const* gridOrderPerSection, int32_t const* basisFnPerSection, int64_t const* numElementsPerSection, double  const  ___3641, int32_t const  ___3786, int32_t const  ___2975, int64_t const  ___2803, int32_t const  ___1282, int64_t const  ___4193, int64_t const  ___2787, int64_t const  ___4189, int32_t const* varTypes, int32_t const* ___2983, int32_t const* ___4326, int32_t const* ___3552, int32_t const  ___3550) { REQUIRE(VALID_REF(___4690) && strlen(___4690) > 0); REQUIRE(0 <= ___4692 && ___4692 < 9); REQUIRE(0 < ___1908); REQUIRE(0 < ___2115); REQUIRE(IMPLICATION(___4692 == 0 || ___4692 == 6 || ___4692 == 7, 0 < ___2160)); REQUIRE(IMPLICATION(___4692 == 8, VALID_REF(cellShapePerSection) && VALID_REF(numElementsPerSection))); REQUIRE(0 <= ___3786); REQUIRE(0 <= ___2975); REQUIRE(0 <= ___2803); REQUIRE(VALID_ENUM(___1282, FaceNeighborMode_e) || ___1282 == ___1286); REQUIRE(0 <= ___4193); REQUIRE(0 <= ___2787); REQUIRE(0 <= ___4189); REQUIRE(VALID_REF_OR_NULL(varTypes)); REQUIRE(VALID_REF_OR_NULL(___2983)); REQUIRE(VALID_REF_OR_NULL(___4326)); REQUIRE(VALID_REF_OR_NULL(___3552)); REQUIRE(0 <= ___3550); ZoneType_e tecplotZoneTypes[] = { ___4704, ___4696, ___4702, ___4700, ___4701, ___4695,
___4698, ___4699, ZoneType_FEMixed }; REQUIRE(0 <= ___4692 && ___4692 < (int)(sizeof(tecplotZoneTypes) / sizeof(tecplotZoneTypes[0]))); ZoneType_e tecplotZoneType = tecplotZoneTypes[___4692]; if (tecplotZoneType == ___4698 || tecplotZoneType == ___4699) throw Error("Polygon and Polyhedral zone types are currently not supported by SZL files."); FECellShape_e tecplotFECellShapes[] = { FECellShape_Bar, FECellShape_Triangle, FECellShape_Quadrilateral, FECellShape_Tetrahedron, FECellShape_Hexahedron, FECellShape_Pyramid, FECellShape_Prism }; FECellBasisFunction_e tecplotFECellBasisFunctions[] = { FECellBasisFunction_Lagrangian }; std::vector<FECellShape_e> cellShapesVector; std::vector<int32_t> gridOrdersVector; std::vector<FECellBasisFunction_e> basisFnsVector; std::vector<int64_t> numElementsPerSectionVector; if (tecplotZoneType == ZoneType_FEMixed) { try { for (int32_t section=0; section<numSections; ++section) { REQUIRE(0 <= cellShapePerSection[section] && cellShapePerSection[section] < (int)(sizeof(tecplotFECellShapes) / sizeof(tecplotFECellShapes[0]))); REQUIRE(numElementsPerSection[section] > 0); cellShapesVector.push_back(tecplotFECellShapes[cellShapePerSection[section]]); numElementsPerSectionVector.push_back(numElementsPerSection[section]); if (gridOrderPerSection != NULL) { REQUIRE(gridOrderPerSection[section] > 0); gridOrdersVector.push_back(gridOrderPerSection[section]); } else { gridOrdersVector.push_back(1); } if (basisFnPerSection != NULL) { REQUIRE(tecplotFECellBasisFunctions[basisFnPerSection[section]] == FECellBasisFunction_Lagrangian); basisFnsVector.push_back(tecplotFECellBasisFunctions[basisFnPerSection[section]]); } else { basisFnsVector.push_back(FECellBasisFunction_Lagrangian); } } } catch (std::bad_alloc const&) { std::cerr << "Out of memory while processing FEMixed section information\n"; throw; } }
 #if !defined TECIOMPI 
if (___3550 > 0 && m_zoneMap.find(static_cast<___4636>(___3550 - 1)) == m_zoneMap.end()) { try { std::ostringstream ostream; ostream << "Invalid zone specified for nodemap sharing.\n" "Specified non-existent zone " << ___3550 << "."; throw Error(ostream.str()); } catch (std::bad_alloc const&) { std::cerr << "Out of memory while attempting to report:" << std::endl << "Invalid zone specified for nodemap sharing." << std::endl << "Specified non-existent zone " << ___3550 << "." << std::endl; throw; } }
 #endif
std::vector<FieldDataType_e> fieldDataTypeVector; try { if (varTypes) { std::map<int32_t, FieldDataType_e> varTypeMap = boost::assign::map_list_of<int32_t, FieldDataType_e> (1, FieldDataType_Float) (2, FieldDataType_Double) (3, FieldDataType_Int32) (4, FieldDataType_Int16) (5, FieldDataType_Byte); for (size_t i = 0; i < ___2675.size(); ++i) { if (varTypeMap.find(varTypes[i]) == varTypeMap.end()) { std::ostringstream ___2893; ___2893 << "Invalid variable type for variable " << i + 1 << ": " << varTypes[i]; throw Error(___2893.str()); } fieldDataTypeVector.push_back(varTypeMap[varTypes[i]]); } } else { fieldDataTypeVector.assign(___2675.size(), (FieldDataType_e)m_defaultVarType); } } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while processing " << ___2675.size() << " zone variable types." << std::endl; throw; } std::vector<int> passiveVarVector; try { for(size_t ___4292 = 0; ___4292 < ___2675.size(); ++___4292) { if (___2983 && ___2983[___4292] != 0) passiveVarVector.push_back(1); else passiveVarVector.push_back(0); } } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while processing " << ___2675.size() << " zone passive variables." << std::endl; throw; } std::vector<ValueLocation_e> valueLocationVector; try { for(size_t ___4292 = 0; ___4292 < ___2675.size(); ++___4292) { if (___4326) valueLocationVector.push_back(static_cast<ValueLocation_e>(___4326[___4292])); else valueLocationVector.push_back(___4330); } } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while processing " << ___2675.size() << " zone variable locations." << std::endl; throw; } std::vector<int> shareVarFromZoneVector; try { for(size_t ___4292 = 0; ___4292 < ___2675.size(); ++___4292) { if (___3552 && ___3552[___4292] != 0) {
 #if !defined TECIOMPI 
if (m_zoneMap.find(static_cast<___4636>(___3552[___4292] - 1)) == m_zoneMap.end()) { try { std::ostringstream ostream; ostream << "Invalid zone specified for variable sharing.\n" "Specified non-existent zone " << ___3552[___4292] << " for variable " << ___4292 << "."; throw Error(ostream.str()); } catch (std::bad_alloc const&) { std::cerr << "Out of memory while attempting to report:" << std::endl << "Invalid zone specified for variable sharing." << std::endl << "Specified non-existent zone " << ___3552[___4292] << " for variable " << ___4292 << "." << std::endl; throw; } } else
 #endif
{ shareVarFromZoneVector.push_back(___3552[___4292]); } } else { shareVarFromZoneVector.push_back(0); } } } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while processing " << ___2675.size() << " zone variable sharing settings." << std::endl; throw; } size_t titleLength = strlen(___4690); if (titleLength > (size_t)___2359) { titleLength = ___2359; std::cerr << "Warning: Zone title too long, truncating to " << titleLength << " chars." << std::endl; } std::string zoneTitleString; try { zoneTitleString.assign(___4690, titleLength); } catch(std::bad_alloc const&) { std::cerr << "Out of memory while processing zone title string." << std::endl; throw; } Zone_s* zone = NULL; try { zone = new Zone_s( zoneTitleString, tecplotZoneType, 1, 1, 1, ___1908, ___2115, ___2160, cellShapesVector, gridOrdersVector, basisFnsVector, numElementsPerSectionVector, ___3641, ___3786, static_cast<___1170>(___2975), ___2803, static_cast<FaceNeighborMode_e>(___1282), ___4193, ___2787, ___4189, fieldDataTypeVector, passiveVarVector, valueLocationVector, shareVarFromZoneVector, ___3550); } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while creating container to store zone settings." << std::endl; throw; } try { m_zoneMap[m_nextZoneIndex] = boost::shared_ptr<Zone_s>(zone); } catch (std::bad_alloc const&) { std::cerr << "Out-of-memory error while storing zone settings." << std::endl; throw; } ++m_nextZoneIndex; } void ___3971::renumberZones(std::vector<int32_t> const& zoneNumbers) { INVARIANT(IMPLICATION(!m_zoneMap.empty(), m_nextZoneIndex > 0)); REQUIRE(zoneNumbers.size() == unflushedZoneSet().size()); std::set<___3494> zonesToRenumber = unflushedZoneSet(); size_t ind = zoneNumbers.size() - 1; BOOST_REVERSE_FOREACH(___3494 oldZoneNumber, zonesToRenumber) { int32_t newZoneNumber = zoneNumbers[ind]; ___476(newZoneNumber >= oldZoneNumber); if (newZoneNumber > oldZoneNumber) { m_zoneMap[static_cast<___4636>(newZoneNumber - 1)] = m_zoneMap[static_cast<___4636>(oldZoneNumber - 1)]; m_zoneMap.erase(static_cast<___4636>(oldZoneNumber - 1)); } --ind; } m_lastZoneFlushedToDisk = zoneNumbers[0] - 2; m_nextZoneIndex = zoneNumbers.back(); } void ___3971::dropLastZone() { INVARIANT(IMPLICATION(!m_zoneMap.empty(), m_nextZoneIndex > 0)); REQUIRE(!m_zoneMap.empty()); REQUIRE(m_nextZoneIndex > 0); ___4636 newestZoneIndex = m_nextZoneIndex - 1; REQUIRE(m_zoneMap.rbegin()->first == newestZoneIndex); m_zoneMap.erase(newestZoneIndex); } void ___3971::setPartitionOwners(std::vector<int> const& partitionOwners) { if (!m_zoneMap.rbegin()->second->m_partitionOwners.empty()) throw Error("Must be called only once, immediately after zone creation."); m_zoneMap.rbegin()->second->m_partitionOwners = partitionOwners; } Zone_s* ___3971::getZonePtr(int32_t zone) const { Zone_s::ZoneMap::const_iterator iter = m_zoneMap.find(static_cast<___4636>(zone - 1));
if (iter == m_zoneMap.end()) { std::ostringstream ___2893; ___2893 << "Specified non-existent zone " << zone << "."; throw Error(___2893.str()); } return iter->second.get(); } Zone_s* ___3971::getAndCheckZonePtr(int32_t zone) const { Zone_s* zonePtr = getZonePtr(zone); for (size_t i = 0; i < zonePtr->___2497.size(); ++i) { if (zonePtr->___2497[i]->storedValueCount() != 0) { std::ostringstream ___2893; ___2893 << "Called out-of-order (after caching data to the zone) for zone " << zone << "." << std::endl; ___2893 << "If the zone is partitioned, you must add a partition before calling TECDAT or TECNOD."; throw Error(___2893.str()); } } return zonePtr; } namespace { bool zonesAreCompatibleForSharing(Zone_s const* zonePtr, Zone_s const* shareZonePtr, int32_t ___2978) { return (shareZonePtr->m_partitionMap.empty() && zonePtr->m_partitionMap.empty()) || (shareZonePtr->m_partitionMap.find(___2978 - 1) != shareZonePtr->m_partitionMap.end()); } } template <typename T> void ___3971::addFEZonePartition( int32_t                                 zone, int32_t                                 ___2978, int64_t                                 ___2822, tecplot::___3270<int64_t const> const& numCellsPerSection, tecplot::___3270<T const>       const& gnodes, tecplot::___3270<int32_t const> const& gnpartitions, tecplot::___3270<T const>       const& gnpnodes, tecplot::___3270<int64_t const> const& numGhostCellsPerSection, tecplot::___3270<T const>       const& gcells) { Zone_s* zonePtr = getAndCheckZonePtr(zone); ___4636 numPartitionsMPI = static_cast<___4636>(zonePtr->m_partitionOwners.size()); for(size_t i = 0; i < gnodes.size(); ++i) { if (gnodes[i] < 1 || ___2822 < gnodes[i]) { std::ostringstream ___2893; ___2893 << "Invalid ghost node (" << gnodes[i] << ") at position " << i + 1 << " in the ghost node list for partition " << ___2978 << " of zone " << zone << "." << std::endl; throw Error(___2893.str()); } if (gnpartitions[i] < 1 || (numPartitionsMPI > 0 && numPartitionsMPI < gnpartitions[i])) { std::ostringstream ___2893; ___2893 << "Invalid ghost node partition (" << gnpartitions[i] << ") at position " << i + 1 << " in the ghost node partition list for partition " << ___2978 << " of zone " << zone << "." << std::endl; throw Error(___2893.str()); } if (gnpnodes[i] < 1) { std::ostringstream ___2893; ___2893 << "Invalid ghost node partition node (" << gnpnodes[i] << ") at position " << i + 1 << " in the ghost node partition node list for partition " << ___2978 << " of zone " << zone << "." << std::endl; throw Error(___2893.str()); } } size_t baseOffset = 0; for (size_t section = 0; section < numGhostCellsPerSection.size(); ++section) { for (size_t i = 0; i < static_cast<size_t>(numGhostCellsPerSection[section]); ++i) { ___476(baseOffset+i < gcells.size()); if (gcells[baseOffset+i] < 1 || numCellsPerSection[section] < gcells[baseOffset+i])
{ std::ostringstream ___2893; ___2893 << "Invalid ghost cell (" << gcells[i] << ") at position " << i + 1 << " in the ghost cell list for partition " << ___2978 << " of zone " << zone << "." << std::endl; throw Error(___2893.str()); } } baseOffset += static_cast<size_t>(numGhostCellsPerSection[section]); } int64_t const numCellsInPartition = std::accumulate(numCellsPerSection.begin(), numCellsPerSection.end(), int64_t(0)); boost::shared_ptr<Zone_s> newPartition = boost::shared_ptr<Zone_s>(new Zone_s( zonePtr->___2684, zonePtr->___2685, 1, 1, 1, ___2822, numCellsInPartition, zonePtr->___2683.___1668(), zonePtr->m_cellShapes, zonePtr->m_gridOrders, zonePtr->m_basisFns, std::vector<int64_t>(numCellsPerSection.begin(),numCellsPerSection.end()), zonePtr->___2622, zonePtr->___2623, zonePtr->___2615, 0, zonePtr->___2459, 0, 0, 0, zonePtr->___2461, zonePtr->m_passiveVars, zonePtr->___2671, zonePtr->m_shareVarFromZone, zonePtr->m_shareConnectivityFromZone)); for (size_t i = 0; i < zonePtr->m_shareVarFromZone.size(); ++i) { ___1170 shareZone = zonePtr->m_shareVarFromZone[i]; if (shareZone) { Zone_s* shareZonePtr = getZonePtr(shareZone); if (!zonesAreCompatibleForSharing(zonePtr, shareZonePtr, ___2978)) { std::ostringstream ___2893; ___2893 << "Error in var share list for zone " << zone << " partition " << ___2978 << ": var " << i + 1 << " attempting to share with incompatible zone " << shareZone << "." << std::endl; throw Error(___2893.str()); } } } if (zonePtr->m_shareConnectivityFromZone) { Zone_s* shareZonePtr = getZonePtr(zonePtr->m_shareConnectivityFromZone); if (!zonesAreCompatibleForSharing(zonePtr, shareZonePtr, ___2978)) { std::ostringstream ___2893; ___2893 << "Error in sharing connectivity for zone " << zone << " partition " << ___2978 << ": attempting to share with incompatible zone " << zonePtr->m_shareConnectivityFromZone << "." << std::endl; throw Error(___2893.str()); } } try { newPartition->m_ghostNodeInfo = GhostInfo_s(gnodes, gnpartitions, gnpnodes); } catch(std::exception const& e) { std::ostringstream ___2893; ___2893 << "Error in ghost node list for zone " << zone << " partition " << ___2978 << ": " << e.what(); throw Error(___2893.str()); } try { newPartition->m_ghostCellInfo = GhostInfo_s(numGhostCellsPerSection, gcells); } catch(std::exception const& e) { std::ostringstream ___2893; ___2893 << "Error in ghost cell list for zone " << zone << " partition " << ___2978 << ": " << e.what(); throw Error(___2893.str()); } zonePtr->m_partitionMap[___2978 - 1] = newPartition; } template void ___3971::addFEZonePartition<int32_t>( int32_t                                 zone, int32_t                                 ___2978, int64_t                                 ___2822, tecplot::___3270<int64_t const> const& numCellsPerSection, tecplot::___3270<int32_t const> const& gnodes, tecplot::___3270<int32_t const> const& gnpartitions,
tecplot::___3270<int32_t const> const& gnpnodes, tecplot::___3270<int64_t const> const& numGhostCellsPerSection, tecplot::___3270<int32_t const> const& gcells); template void ___3971::addFEZonePartition<int64_t>( int32_t                                 zone, int32_t                                 ___2978, int64_t                                 ___2822, tecplot::___3270<int64_t const> const& numCellsPerSection, tecplot::___3270<int64_t const> const& gnodes, tecplot::___3270<int32_t const> const& gnpartitions, tecplot::___3270<int64_t const> const& gnpnodes, tecplot::___3270<int64_t const> const& numGhostCellsPerSection, tecplot::___3270<int64_t const> const& gcells); namespace { void throwIfInvalidIndex(char const* indexName, int64_t value, int64_t maxValue) { if (value > maxValue) { std::ostringstream ___2893; ___2893 << "Invalid value for " << indexName << ": " << value << ". Max value is " << maxValue << "."; throw ___3971::Error(___2893.str()); } } } void ___3971::addIJKZonePartition(int32_t zone, int32_t ___2978, int64_t iMin, int64_t jMin, int64_t kMin, int64_t iMax, int64_t jMax, int64_t kMax) { REQUIRE(iMax > iMin && iMin > 0); REQUIRE(jMax > jMin && jMin > 0); REQUIRE(kMax > kMin && kMin > 0); Zone_s* zonePtr = getAndCheckZonePtr(zone); throwIfInvalidIndex("IMax", iMax, zonePtr->___2683.i());; throwIfInvalidIndex("JMax", jMax, zonePtr->___2683.___2104());; throwIfInvalidIndex("KMax", kMax, zonePtr->___2683.___2133());; zonePtr->m_partitionMap[___2978 - 1] = boost::make_shared<Zone_s>(zonePtr, iMin, jMin, kMin, iMax, jMax, kMax); } void ___3971::___8(std::string const& ___2686, std::string const& value) { ___2400->m_auxDataItems.push_back(AuxData_s::AuxDataItem(___270, ___4227, ___2686, value)); } void ___3971::___20(int32_t zone, std::string const& ___2686, std::string const& value) { REQUIRE(m_zoneMap.find(static_cast<___4636>(zone - 1)) != m_zoneMap.end()); m_zoneMap[zone - 1]->___2346->m_auxDataItems.push_back(AuxData_s::AuxDataItem(___270, ___4227, ___2686, value)); } void ___3971::___18(int32_t ___4336, std::string const& ___2686, std::string const& value) { REQUIRE(0 < ___4336 && ___4336 <= static_cast<___4352>(___2675.size())); ___2673[___4336 - 1]->m_auxDataItems.push_back(AuxData_s::AuxDataItem(___270, ___4227, ___2686, value)); } void ___3971::___6(std::vector<std::string> const& ___2172) { ___2399.push_back(___2172); } void ___3971::___9( double ___4574, double ___4591, double ___4715, CoordSys_e ___3160, ___372 ___2003, ___1170 zone, ___514 color, ___514 ___1409, ___372 ___2021, GeomType_e ___1650, LinePattern_e ___2264, double ___2987, double ___2290, uint16_t ___2794, ArrowheadStyle_e arrowheadStyle, ArrowheadAttachment_e arrowheadAttachment, double arrowheadSize, double arrowheadAngle, Scope_e ___3443, Clipping_e ___493, ___2226 ___2836, ___2226 const* ___2838,
float const* ___4572, float const* ___4589, float const* ___4712, char const* ___2328) { REQUIRE(VALID_ENUM(___3160, CoordSys_e)); REQUIRE(VALID_BOOLEAN(___2003)); REQUIRE(___1418 <= color && color <= ___2194); REQUIRE(___1418 <= ___1409 && ___1409 <= ___2194); REQUIRE(VALID_BOOLEAN(___2021)); REQUIRE(VALID_ENUM(___1650, GeomType_e)); REQUIRE(VALID_ENUM(___2264, LinePattern_e)); REQUIRE(VALID_ENUM(arrowheadStyle, ArrowheadStyle_e)); REQUIRE(VALID_ENUM(arrowheadAttachment, ArrowheadAttachment_e)); REQUIRE(VALID_ENUM(___3443, Scope_e)); REQUIRE(VALID_ENUM(___493, Clipping_e)); REQUIRE(VALID_REF(___2838)); REQUIRE(VALID_REF(___4572)); REQUIRE(IMPLICATION(___1650 != GeomType_Circle && ___1650 != GeomType_Square, VALID_REF(___4589))); REQUIRE(IMPLICATION( ___1650 == GeomType_LineSegs3D || (___1650 == GeomType_LineSegs && ___3160 == CoordSys_Grid3D), VALID_REF(___4712))); REQUIRE(VALID_REF_OR_NULL(___2328)); std::vector<std::vector<___4580> > ___1570; if (___1650 == ___1586) { ___1650 = GeomType_LineSegs; ___3160 = CoordSys_Grid3D; } switch(___1650) { case GeomType_LineSegs: { ___1570.resize(static_cast<size_t>(___2836)); int index = 0; for(___2226 i = 0; i < ___2836; ++i) { for(___2226 ___2104 = 0; ___2104 < ___2838[i]; ++___2104) { if (___3160 == CoordSys_Grid3D) ___1570[i].push_back(___4580(___4572[index], ___4589[index], ___4712[index])); else ___1570[i].push_back(___4580(___4572[index], ___4589[index], 0.0)); ++index; } } } break; case GeomType_Rectangle: case GeomType_Ellipse: ___1570.resize(1); ___1570[0].push_back(___4580(___4572[0], ___4589[0], 0.0)); break; case GeomType_Square: case GeomType_Circle: ___1570.resize(1); ___1570[0].push_back(___4580(___4572[0], 0.0, 0.0)); break; default: ___476(___1303); break; } ___2466.push_back(tecioszl::___1554( ___4574, ___4591, ___4715, ___3160, ___2003, zone, color, ___1409, ___2021, ___1650, ___2264, ___2987, ___2290, ___2794, arrowheadStyle, arrowheadAttachment, arrowheadSize, arrowheadAngle, ___3443, ___493, ___1570, ___2328 != NULL ? ___2328 : "")); } void ___3971::___9(tecioszl::___1554 const& ___1553) { ___2466.push_back(___1553); } void ___3971::___16( double ___4574, double ___4591, double ___4713, CoordSys_e ___3160, ___372 ___2003, ___1170 zone, Font_e ___1441, Units_e ___1450, double ___1448, TextBox_e ___410, double ___408, double ___406, ___514 ___402, ___514 ___404, double ___56, TextAnchor_e ___38, double ___2288, ___514 ___4081, Scope_e ___3443, Clipping_e ___493, char const* ___4043, char const* ___2328) { REQUIRE(VALID_ENUM(___3160, CoordSys_e)); REQUIRE(VALID_BOOLEAN(___2003)); REQUIRE(VALID_ENUM(___1441, Font_e) && ___1441 != ___1446); REQUIRE(VALID_ENUM(___1450, Units_e)); REQUIRE(___1448 > 0.0); REQUIRE(VALID_ENUM(___410, TextBox_e));
REQUIRE(0.0 <= ___408 && ___408 <= 100.0); REQUIRE(0.0001 <= ___406 && ___406 <= 100.0); REQUIRE(___1418 <= ___402 && ___402 <= ___2194); REQUIRE(___1418 <= ___404 && ___404 <= ___2194); REQUIRE(VALID_ENUM(___38, TextAnchor_e)); REQUIRE(___2288 > 0.0); REQUIRE(___1418 <= ___4081 && ___4081 <= ___2194); REQUIRE(VALID_ENUM(___3443, Scope_e)); REQUIRE(VALID_ENUM(___493, Clipping_e)); REQUIRE(VALID_REF(___4043)); REQUIRE(VALID_REF_OR_NULL(___2328)); std::map<Font_e, std::string> textTypefaceFamilies = boost::assign::map_list_of<Font_e, std::string> (___1452,           "Helvetica") (___1453,       "Helvetica") (Font_HelveticaItalic,     "Helvetica") (Font_HelveticaItalicBold, "Helvetica") (___1447,               "Greek") (___1457,                "Math") (___1468,         "User Defined") (___1464,               "Times") (___1466,         "Times") (___1465,           "Times") (___1467,     "Times") (___1443,             "Courier") (___1444,         "Courier") (Font_CourierItalic,       "Courier") (Font_CourierItalicBold,   "Courier"); ___372 ___4133 = (___1441 == ___1453         || ___1441 == Font_HelveticaItalicBold   || ___1441 == ___1465             || ___1441 == ___1467       || ___1441 == ___1444           || ___1441 == Font_CourierItalicBold); ___372 ___4135 = (___1441 == ___1466         || ___1441 == ___1467     || ___1441 == Font_HelveticaItalic     || ___1441 == Font_HelveticaItalicBold || ___1441 == Font_CourierItalic       || ___1441 == Font_CourierItalicBold); ___2641.push_back(tecioszl::Text( ___4574, ___4591, ___4713, ___402, ___404, ___406, ___408, ___410, ___38, ___56, ___493, ___4081, ___1448, ___2288, ___2328 != NULL ? ___2328 : "", ___3160, ___3443, ___1450, ___4043, textTypefaceFamilies[___1441], ___4133, ___4135, zone, ___2003)); } void ___3971::___16(tecioszl::Text const& ___4043) { ___2641.push_back(___4043); } void ___3971::___429(___2226 count, void const* data, bool ___2012) { if (m_zoneMap.empty()) throw Error("No zones have been defined."); boost::shared_ptr<Zone_s> zone = m_zoneMap.rbegin()->second; if (!zone->m_partitionMap.empty()) zone = zone->m_partitionMap.rbegin()->second; if (zone->___2398 < zone->___2497.size() && zone->___2497[zone->___2398]->storedValueCount() == 0) { zone->___2497[zone->___2398]-> reserveValues(zone->___2497[zone->___2398]->___2669); } for(___2226 i = 0; i < count; ++i) { if (zone->___2398 >= zone->___2497.size()) throw Error("Too many data values for this zone."); double d; if (___2012) d = ((double const*)data)[i]; else d = static_cast<double>(((float const*)data)[i]); ___1360& ___1349 = *zone->___2497[zone->___2398];
___1349.appendValue(d); if (zone->___2685 == ___4704 && ___1349.___2670 == ___4328) { padCCValuesIfNecessary(___1349, zone->___2683.i(), zone->___2683.___2104(), zone->___2683.___2133()); } if (zone->___2497[zone->___2398]->storedValueCount() == zone->___2497[zone->___2398]->___2669) { do { zone->___2398++; } while (zone->___2398 < zone->___2497.size() && zone->___2497[zone->___2398]->storedValueCount() == zone->___2497[zone->___2398]->___2669); if (zone->___2398 < zone->___2497.size()) zone->___2497[zone->___2398]->reserveValues( zone->___2497[zone->___2398]->___2669); } } } void ___3971::___431(___2226 count, int32_t const* ___2724) { boost::shared_ptr<Zone_s> zone = m_zoneMap.rbegin()->second; if (!zone->m_partitionMap.empty()) zone = zone->m_partitionMap.rbegin()->second; if (count + zone->___2498->storedValueCount() > zone->___2498->expectedValueCount()) throw Error("Too many node map values for this zone."); for (___2226 i = 0; i < count; ++i) { if (((int64_t)___2724[i] > zone->___2683.i()) || (___2724[i] < 1)) { std::ostringstream ___2893; ___2893 << "Err: (TECNODE142) Invalid node map value at position " << i << std::endl << "     node map value = " << ___2724[i] << ", max value = " << zone->___2683.i() << "."; throw ___3971::Error(___2893.str()); } zone->___2498->appendValue(___2724[i] - 1); } } namespace { void throwIf(bool doThrow, char const* ___2433, ___2226 value) { if (doThrow) { std::ostringstream ostream; ostream << ___2433 << value << "."; throw ___3971::Error(ostream.str()); } } } template <typename T> void ___3971::___430(Zone_s* zonePtr, T const* faceNeighbors) { ___2226 cellCount; ___2226 faceCount = 0; if (zonePtr->___2685 == ___4704) { cellCount = zonePtr->___2683.i() * zonePtr->___2683.___2104() * (zonePtr->___2683.___2133() - 1); int nDimensions = 0; if (zonePtr->___2683.i() > 1) ++nDimensions; if (zonePtr->___2683.___2104() > 1) ++nDimensions; if (zonePtr->___2683.___2133() > 1) ++nDimensions; if (nDimensions == 3) faceCount = 6; else if (nDimensions == 2) faceCount = 4; else faceCount = 0; } else { cellCount = zonePtr->___2683.___2104(); faceCount = zonePtr->___2683.___2133(); } ___2226 currentConnection = 0; ___2226 index = 0; while (currentConnection < zonePtr->___2504) { Zone_s::___456 ___455; ___455.first = (___1170)faceNeighbors[index++]; throwIf(___455.first < 1 || cellCount < ___455.first, "Invalid cell number in face connections: ", ___455.first); ___455.second = faceNeighbors[index++]; throwIf(___455.second < 1 || faceCount < ___455.second, "Invalid face number in face connections: ", ___455.second); Zone_s::___1273& ___1272 = zonePtr->___2458[___455]; ___2226 numNeighbors = 1;
if (zonePtr->___2459 == ___1287 || zonePtr->___2459 == ___1284) { ___2226 isObscured = faceNeighbors[index++]; throwIf(isObscured != 0 && isObscured != 1, "Invalid face obscuration flag in face connections: ", isObscured); ___1272.___2489 = (isObscured == 1 ? ___4227 : ___1303); numNeighbors = faceNeighbors[index++]; throwIf(numNeighbors < 0, "Invalid number of neighbors in face connections: ", numNeighbors); } else { ___1272.___2489 = ___4227; } for(___2226 whichNeighbor = 0; whichNeighbor < numNeighbors; ++whichNeighbor) { Zone_s::___4607 zoneCell; if (zonePtr->___2459 == ___1285 || zonePtr->___2459 == ___1284) zoneCell.first = static_cast<___1170>(faceNeighbors[index++]); else zoneCell.first = 0; throwIf(zoneCell.first < 0, "Invalid neighbor zone in face connections: ", (___2226)zoneCell.first); zoneCell.second = faceNeighbors[index++]; throwIf(zoneCell.second < 0, "Invalid neighbor cell in face connections: ", zoneCell.second); ___1272.___2679.push_back(zoneCell); } ++currentConnection; } } template void ___3971::___430<int32_t>(Zone_s* zonePtr, int32_t const* faceNeighbors); template void ___3971::___430<int64_t>(Zone_s* zonePtr, int64_t const* faceNeighbors); void ___3971::copyConnectivity(___3971 const& ___2889) { for (Zone_s::ZoneMap::iterator zonePair = m_zoneMap.begin(); zonePair != m_zoneMap.end(); ++zonePair) { Zone_s::ZoneMap::const_iterator iter = ___2889.m_zoneMap.find(zonePair->first); throwIf(iter == ___2889.m_zoneMap.end(), "Non-matching zone structure between grid and solution files\nZone not found in grid file: ", zonePair->first); if (!zonePair->second->m_partitionMap.empty()) { for (Zone_s::ZoneMap::iterator partitionPair = zonePair->second->m_partitionMap.begin(); partitionPair != zonePair->second->m_partitionMap.end(); ++partitionPair) { Zone_s::ZoneMap::const_iterator subIter = iter->second->m_partitionMap.find(partitionPair->first); throwIf(subIter == iter->second->m_partitionMap.end(), "Non-matching zone structure between grid and solution files\npartition not found in grid file: ", partitionPair->first); partitionPair->second->___2498 = subIter->second->___2498; } } else { zonePair->second->___2498 = iter->second->___2498; } } } int32_t ___3971::___2847() const { return static_cast<int32_t>(m_nextZoneIndex); } int32_t ___3971::numZonePartitions(int32_t zone) const { Zone_s::ZoneMap::const_iterator iter = m_zoneMap.find(static_cast<___4636>(zone - 1)); REQUIRE(iter != m_zoneMap.end()); if (iter->second->m_partitionOwners.empty()) return static_cast<int32_t>(iter->second->m_partitionMap.size()); return static_cast<int32_t>(iter->second->m_partitionOwners.size()); } int32_t ___3971::___2844() const { return static_cast<int32_t>(___2675.size()); } void ___3971::___4167(bool checkConnectivity) const
{ if (!m_zoneMap.empty()) { boost::shared_ptr<Zone_s> zone = m_zoneMap.rbegin()->second; if (!zone->m_partitionMap.empty()) zone = zone->m_partitionMap.rbegin()->second; else if (!zone->m_partitionOwners.empty()) return; if (!zone->m_allVarsAreShared && zone->___2398 != ___2675.size()) { std::ostringstream ostream; ___2226 valuesNeeded = zone->___2497[zone->___2398]->___2669 - (___2226)zone->___2497[zone->___2398]->storedValueCount(); ostream << "Not all variable values for the current zone have been written.\n" << "Currently need " << valuesNeeded << " for variable " << zone->___2398 + 1 << "."; throw Error(ostream.str()); } if (checkConnectivity) { if (zone->___2498 && zone->___2498->expectedValueCount() > zone->___2498->storedValueCount()) { ___2226 valuesNeeded = zone->___2498->expectedValueCount() - zone->___2498->storedValueCount(); std::ostringstream ostream; ostream << "Not all node map values for the current zone have been written.\n" << "Currently need " << valuesNeeded << " more values."; throw Error(ostream.str()); } } } } void ___3971::clear(int32_t numZonesToRetain, int32_t const* zonesToRetain) { if (!m_zoneMap.empty()) m_lastZoneFlushedToDisk = static_cast<___3934::___4636>(m_zoneMap.rbegin()->first); if (numZonesToRetain == 0) { m_zoneMap.clear(); } else { boost::unordered_set<Zone_s::ZoneMap::key_type>zoneSet; for (int32_t i = 0; i < numZonesToRetain; ++i) zoneSet.insert(zonesToRetain[i] - 1); for (Zone_s::ZoneMap::iterator it = m_zoneMap.begin(); it != m_zoneMap.end();) if (zoneSet.find(it->first) == zoneSet.end()) { Zone_s::ZoneMap::iterator eraseIt = it; ++it; m_zoneMap.erase(eraseIt); } else { ++it; } } if (___2400) ___2400->m_auxDataItems.clear(); for (size_t ___4336 = 0; ___4336 < ___2673.size(); ++___4336) if (___2673[___4336]) ___2673[___4336]->m_auxDataItems.clear(); ___2466.clear(); ___2641.clear(); ___2399.clear(); ENSURE(empty()); } bool ___3971::empty() { bool ___3359 = true; if (!m_zoneMap.empty() && m_zoneMap.rbegin()->first > m_lastZoneFlushedToDisk) ___3359 = false; if (!___2466.empty() || !___2641.empty() || !___2399.empty()) ___3359 = false; if (___2400 && !___2400->m_auxDataItems.empty()) ___3359 = false; for(size_t i = 0; i < ___2673.size(); ++i) if (___2673[i] && !___2673[i]->m_auxDataItems.empty()) ___3359 = false; return  ___3359; } std::set<___3494> ___3971::zoneSet() const { std::set<___3494> ___3359; for (Zone_s::ZoneMap::const_iterator it = m_zoneMap.begin(); it != m_zoneMap.end(); ++it) ___3359.insert(static_cast<___3494>(it->first + 1)); return ___3359; } std::set<___3494> ___3971::unflushedZoneSet() const { std::set<___3494> ___3359; for (Zone_s::ZoneMap::const_iterator it = m_zoneMap.upper_bound(m_lastZoneFlushedToDisk); it != m_zoneMap.end(); ++it) ___3359.insert(static_cast<___3494>(it->first + 1)); return ___3359; } bool ___3971::___894() const
{ return (!m_zoneMap.empty() && m_zoneMap.rbegin()->first > m_lastZoneFlushedToDisk); } Zone_s* ___3971::zonePtr(___4636 ___4658) const { REQUIRE(0 < ___4658); Zone_s::ZoneMap::const_iterator zoneIter = m_zoneMap.find(___4658 - 1); if (zoneIter != m_zoneMap.end()) return zoneIter->second.get(); else return NULL; } void ___3971::updateBaseZoneForVarCache() const { m_baseZoneForVar.resize(___2844()); for (___4352 varIndex = 0; varIndex < ___2844(); ++varIndex) { m_baseZoneForVar[varIndex].assign(m_nextZoneIndex, -1); for (___4636 ___4634 = 0; ___4634 < m_nextZoneIndex; ++___4634) { Zone_s* zPtr = zonePtr(___4634 + 1); if (zPtr) { ___4636 const sharedZoneIndex = zPtr->m_shareVarFromZone[varIndex] - 1; if (sharedZoneIndex >= 0 && validZoneNum(sharedZoneIndex + 1)) m_baseZoneForVar[varIndex][___4634] = m_baseZoneForVar[varIndex][sharedZoneIndex]; else m_baseZoneForVar[varIndex][___4634] = ___4634; } } } } ___4636 ___3971::baseZoneForVar(___4636 ___4658, ___4352 ___4368) const { REQUIRE(validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(___2675.size())); if (m_baseZoneForVar.empty() || checked_numeric_cast<___4636>(m_baseZoneForVar.size()) < ___2844() || checked_numeric_cast<___4636>(m_baseZoneForVar[0].size()) < m_nextZoneIndex) { updateBaseZoneForVarCache(); } ___4352 const varIndex = ___4368 - 1; ___4636 const ___4634 = ___4658 - 1; ___4636 ___3359 = m_baseZoneForVar[varIndex][___4634] + 1; ENSURE(validZoneNum(___3359)); return ___3359; } Zone_s* ___3971::zonePtrForVar(___4636 ___4658, ___4352 ___4368) const { REQUIRE(validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(___2675.size())); ___4636 ___341 = baseZoneForVar(___4658, ___4368); Zone_s* ___3359 = zonePtr(___341); ENSURE(VALID_REF(___3359)); return ___3359; } void ___3971::updateBaseZoneForConnectivityCache() const { m_baseZoneForConnectivity.assign(m_nextZoneIndex, -1); for (___4636 ___4634 = 0; ___4634 < m_nextZoneIndex; ++___4634) { Zone_s* zPtr = zonePtr(___4634 + 1); if (zPtr) { ___4636 const sharedZoneIndex = zPtr->m_shareConnectivityFromZone - 1; if (sharedZoneIndex >= 0) m_baseZoneForConnectivity[___4634] = sharedZoneIndex; else m_baseZoneForConnectivity[___4634] = ___4634; } } } ___4636 ___3971::baseZoneForConnectivity(___4636 ___4658) const { REQUIRE(validZoneNum(___4658)); if (m_baseZoneForConnectivity.empty() || checked_numeric_cast<___4636>(m_baseZoneForConnectivity.size()) < m_nextZoneIndex) updateBaseZoneForConnectivityCache(); ___4636 const ___4634 = ___4658 - 1; ___4636 ___3359 = m_baseZoneForConnectivity[___4634] + 1; ENSURE(validZoneNum(___3359)); return ___3359; } Zone_s* ___3971::zonePtrForConnectivity(___4636 ___4658) const { REQUIRE(validZoneNum(___4658)); ___4636 ___341 = baseZoneForConnectivity(___4658); Zone_s* ___3359 = zonePtr(___341); ENSURE(VALID_REF(___3359));
return ___3359; } bool ___3971::validPartitionNum(___3934::___4636 ___4658, ___3934::___4636 partitionNum) const { Zone_s* zPtr = zonePtr(___4658); return zPtr->m_partitionMap.find(partitionNum - 1) != zPtr->m_partitionMap.end(); } void ___3971::flattenSinglePartitionZones() { for (Zone_s::ZoneMap::iterator valuePair = m_zoneMap.begin(); valuePair != m_zoneMap.end(); ++valuePair) { Zone_s* zonePtr = valuePair->second.get();
 #if defined TECIOMPI
if (zonePtr->m_partitionMap.size() == 1 && zonePtr->m_partitionOwners.size() == 1)
 #else
if (zonePtr->m_partitionMap.size() == 1)
 #endif
{ Zone_s* partitionPtr = zonePtr->m_partitionMap.begin()->second.get(); zonePtr->___2497 = partitionPtr->___2497; zonePtr->___2498 = partitionPtr->___2498; zonePtr->m_partitionMap.clear(); } } } tecplot::___3934::___1391 ___3971::sizeInFile(bool ___4480) const { ___1391 size = 0; size += stringSizeInFile(___2650, ___4480); size += vectorSizeInFile(___2675, ___4480); size += scalarSizeInFile(m_defaultVarType, ___4480); size += scalarSizeInFile(m_nextZoneIndex, ___4480); size += scalarSizeInFile(m_lastZoneFlushedToDisk, ___4480); size += mapOfScalarsToPtrsSizeInFile(m_zoneMap, ___4480); size += ___2400->sizeInFile(___4480); size += vectorOfPtrsSizeInFile(___2673, ___4480); size += vectorOfObjectsSizeInFile(___2466, ___4480); size += vectorOfObjectsSizeInFile(___2641, ___4480); size += scalarSizeInFile((uint64_t)___2399.size(), ___4480); for (std::vector<std::vector<std::string> >::const_iterator vec = ___2399.begin(); vec != ___2399.end(); ++vec) { size += vectorSizeInFile(*vec, ___4480); } return size; } void ___3971::writeToFile(___3934::FileWriterInterface& outputFile, ___3934::___1391 fileLoc, bool ___4480) const { REQUIRE(outputFile.___2040()); outputFile.___3460(fileLoc); ___4544(outputFile, ___2650, ___4480); writeVector(outputFile, ___2675, ___4480); writeScalar(outputFile, m_defaultVarType, ___4480); writeScalar(outputFile, m_nextZoneIndex, ___4480); writeScalar(outputFile, m_lastZoneFlushedToDisk, ___4480); writeMapOfScalarsToPtrs(outputFile, m_zoneMap, ___4480); ___2400->writeToFile(outputFile, ___4480); writeVectorOfPtrs(outputFile, ___2673, ___4480); writeVectorOfObjects(outputFile, ___2466, ___4480); writeVectorOfObjects(outputFile, ___2641, ___4480); writeScalar(outputFile, (uint64_t)___2399.size(), ___4480); for (std::vector<std::vector<std::string> >::const_iterator vec = ___2399.begin(); vec != ___2399.end(); ++vec) { writeVector(outputFile, *vec, ___4480); } ENSURE(outputFile.fileLoc() == fileLoc + sizeInFile(___4480)); } ___3971::___3971(___3934::___1397& inputFile, bool readASCII) { REQUIRE(inputFile.___2040()); readString(inputFile, ___2650, readASCII); readVector(inputFile, ___2675, readASCII); readScalar(inputFile, m_defaultVarType, readASCII); readScalar(inputFile, m_nextZoneIndex, readASCII); readScalar(inputFile, m_lastZoneFlushedToDisk, readASCII); readMapOfScalarsToPtrs(inputFile, m_zoneMap, readASCII); ___2400 = AuxData_s::makePtr(inputFile, readASCII); readVectorOfPtrs(inputFile, ___2673, readASCII); readVectorOfObjects(inputFile, ___2466, readASCII); readVectorOfObjects(inputFile, ___2641, readASCII); uint64_t length; readScalar(inputFile, length, readASCII); ___2399.resize((size_t)length); for(size_t i = 0; i < ___2399.size(); ++i) readVector(inputFile, ___2399[i], readASCII);
} }}
