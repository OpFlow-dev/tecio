#include "NonSzZoneVariableWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/scoped_array.hpp>
#include <stdexcept>
#include "ThirdPartyHeadersEnd.h"
#include "AltTecUtil.h"
#include "FieldData.h"
#include "fileStuff.h"
#include "FileWriterInterface.h"
#include "ItemSetIterator.h"
#include "writeValueArray.h"
namespace tecplot { namespace ___3934 { namespace { char const* CC_FIELD_DATA_MARKER_LABEL = "ccFieldDataMarker*"; char const* NODAL_FIELD_DATA_MARKER_LABEL = "nodalFieldDataMarker*"; char const* VARIABLE_NUM_LABEL = "variableNum*"; char const* FIELD_DATA_LABEL = "FieldData"; } NonSzZoneVariableWriter::NonSzZoneVariableWriter( ItemSetIterator& varIter, ___4636      zone, ___4636      ___341, ___37&      ___36) : m_varIter(varIter) , ___2678(zone) , m_baseZone(___341) , ___2338(___36) , m_zoneNumberLabel(SZPLT_ZONE_NUM_DESCRIPTION) {} uint64_t NonSzZoneVariableWriter::varHeaderSizeInFile(bool ___2001) { if (___2001) return 3 * valueSizeInFile<uint32_t, false>(___2001); return 0; } uint64_t NonSzZoneVariableWriter::varSizeInFile(___4352 ___4336, bool ___2001) const { uint64_t ___3359 = varHeaderSizeInFile(___2001); ___1350 ___1349(&___2338, ___2678 + 1, ___4336 + 1); if (___1349.___2066()) { switch (___1349.getValueType()) { case FieldDataType_Float: ___3359 += arraySizeInFile<float, false>(static_cast<size_t>(___1349.___1782()), ___2001); break; case FieldDataType_Double: ___3359 += arraySizeInFile<double, false>(static_cast<size_t>(___1349.___1782()), ___2001); break; case FieldDataType_Int32: ___3359 += arraySizeInFile<int32_t, false>(static_cast<size_t>(___1349.___1782()), ___2001); break; case FieldDataType_Int16: ___3359 += arraySizeInFile<int16_t, false>(static_cast<size_t>(___1349.___1782()), ___2001); break; case FieldDataType_Byte: ___3359 += arraySizeInFile<uint8_t, false>(static_cast<size_t>(___1349.___1782()), ___2001); break; case ___1363: ___3359 += arraySizeInFile<uint8_t, false>(static_cast<size_t>(numBytesForNumBits(___1349.___1782())), ___2001); break; default: throw std::runtime_error("Unsupported variable type."); break; } } return ___3359; } ___372 NonSzZoneVariableWriter::writeVarHeader( FileWriterInterface& file, ValueLocation_e      ___4326, ___4352           ___4336) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); REQUIRE(___4326 == ___4328 || ___4326 == ___4330); if (file.___2001()) { if ( ___4326 == ___4328 ) ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, CC_FIELD_DATA_MARKER_LABEL, SZPLT_CC_FIELD_DATA_MARKER); else ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, NODAL_FIELD_DATA_MARKER_LABEL, SZPLT_NODAL_FIELD_DATA_MARKER); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, VARIABLE_NUM_LABEL, (___4336 - m_varIter.baseItem() + 1)); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2678 - m_baseZone + 1)); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } namespace { template <typename T, bool isBitArray> ___372 writeFieldData( FileWriterInterface& szpltFile, ___1350 const&     ___1349) { ___372 ___2038 = ___4227; size_t ___4325 = static_cast<size_t>(___1349.___1782()); void* rawPointer = ___1349.getRawPointer();
if (rawPointer) { ___2038 = ___4563<T, false, 0>(szpltFile, FIELD_DATA_LABEL, ___2746, ___4325, (T*)rawPointer); } else { boost::scoped_array<T> array; array.reset(new T[___4325]); if (___2038) { for (size_t i = 0; i < ___4325; ++i) { double ___4299 = ___1349.___1779(static_cast<___2226>(i) + 1); array[i] = static_cast<T>(___4299); } ___2038 = ___2038 && ___4563<T, false, 0>(szpltFile, FIELD_DATA_LABEL, ___2746, ___4325, array.get()); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <> ___372 writeFieldData<uint8_t, true>( FileWriterInterface& szpltFile, ___1350 const&     ___1349) { REQUIRE(___1349.getValueType() == ___1363); ___372 ___2038 = ___4227; ___1350 tempFieldData; size_t ___4325 = static_cast<size_t>(___1349.___1782()); size_t ___2780 = numBytesForNumBits(___4325); void* rawPointer = ___1349.getRawPointer(); if (!rawPointer) { tempFieldData.allocate(___1349.getValueType(), ___1349.___1785(), ___1349.___1782()); rawPointer = tempFieldData.getRawPointer(); if (rawPointer == NULL) throw std::bad_alloc(); for (___2226 i = 1; i <= ___1349.___1782(); ++i) tempFieldData.___3505(i, ___1349.___1779(i)); } ___2038 = ___2038 && ___4563<uint8_t, false, 0>(szpltFile, FIELD_DATA_LABEL, ___2746, ___2780, (uint8_t*)rawPointer); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 NonSzZoneVariableWriter::writeVar( FileWriterInterface& szpltFile, ___1350 const&     ___1349) { ___372 ___2038 = ___4227; switch (___1349.getValueType()) { case FieldDataType_Float: ___2038 = writeFieldData<float, false>(szpltFile, ___1349); break; case FieldDataType_Double: ___2038 = writeFieldData<double, false>(szpltFile, ___1349); break; case FieldDataType_Int32: ___2038 = writeFieldData<int32_t, false>(szpltFile, ___1349); break; case FieldDataType_Int16: ___2038 = writeFieldData<int16_t, false>(szpltFile, ___1349); break; case FieldDataType_Byte: ___2038 = writeFieldData<uint8_t, false>(szpltFile, ___1349); break; case ___1363: ___2038 = writeFieldData<uint8_t, true>(szpltFile, ___1349); break; default: throw std::runtime_error("Unsupported variable type."); break; } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } }}
