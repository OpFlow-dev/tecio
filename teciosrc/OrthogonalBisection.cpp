#include "SzlFileLoader.h"
#include "OrthogonalBisection.h"
#include "AltTecUtil.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cmath>
#include <fstream>
#include <utility>
#include <boost/bind/bind.hpp>
#include <boost/function.hpp>
#include <boost/make_shared.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "zoneUtil.h"
using namespace std; namespace tecplot { namespace ___3934 { OrthogonalBisection::OrthogonalBisection( ___4636                    zone, ItemAddress64::SectionOffset_t section, BisectionType_e                bisectionType, ItemAddress64::ItemOffset_t    maxDomainSize) : ___2678(zone) , m_section(section) , m_bisectionType(bisectionType) , m_maxDomainSize(maxDomainSize) , m_baseItem(0) , m_numItems(0) , m_numGhostItems(0) , m_numRecursionDepths(0) { REQUIRE(bisectionType == OrthogonalBisection::BisectionType_ZoneCells || (bisectionType == OrthogonalBisection::BisectionType_ZoneNodes && m_section == 0)); ___935(); } OrthogonalBisection::~OrthogonalBisection(void) { } OrthogonalBisection::BisectionType_e OrthogonalBisection::bisectionType() const { return m_bisectionType; } void OrthogonalBisection::___935(void) { m_baseItem = 0; m_numItems = 0; m_numGhostItems = 0; m_numRecursionDepths = 0; m_numDomains = 0; m_itemList.___935(); m_nodalFieldDataPtrs.___935(); m_ccFieldDataPtrs.___935(); m_reducedPrecisionSortDataArrays.___935(); } namespace {
 #ifdef WIN32
 #pragma warning(disable:4512) 
 #endif
class ZoneCellOrNodeSorter { private: ___1350 const&  m_fieldData; ___81 const  m_baseItem; UInt8Array const& m_reducedPrecisionSortData; public: ZoneCellOrNodeSorter( ___1350&        ___1349, ___81        baseItem, UInt8Array const& reducedPrecisionSortData) : m_fieldData(___1349) , m_baseItem(baseItem) , m_reducedPrecisionSortData(reducedPrecisionSortData) { } bool operator()(___81 aIndex, ___81 bIndex) const { if ( m_reducedPrecisionSortData[aIndex] != m_reducedPrecisionSortData[bIndex] ) { return m_reducedPrecisionSortData[aIndex] < m_reducedPrecisionSortData[bIndex]; } else { double const aVal = m_fieldData.___1779(m_baseItem+aIndex+1); double const bVal = m_fieldData.___1779(m_baseItem+bIndex+1); if ( aVal == bVal ) return aIndex < bIndex; else return aVal < bVal; } } }; } namespace { void executeBoostFunction(___90 ___2122) { boost::function<void(void)> *___1436 = reinterpret_cast<boost::function<void(void)>* >(___2122); (*___1436)(); delete ___1436; } } ___372 OrthogonalBisection::splitDomain( ___37&                    ___36, ___81                     domainStart, ___81                     domainSize, ___4352                     axisDirToSplit, ItemAddress64::SubzoneOffset_t recursionDepth, ___2119                  ___2118) { ___372 ___2038 = ___4227; REQUIRE(IMPLICATION(m_numItems > 0, domainStart < m_numItems)); REQUIRE(IMPLICATION(m_numItems > 0, domainStart+domainSize <= m_numItems)); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE(recursionDepth <= m_numRecursionDepths); REQUIRE(VALID_REF(___2118)); if ( domainSize > m_maxDomainSize ) { ___2038 = calcReducedPrecisionValues(___36, domainStart, domainSize, axisDirToSplit, recursionDepth); ___81 leftOffset; ___81 leftSize; ___81 rightOffset; ___81 rightSize; getSubdomainInfo(domainStart, domainSize, leftOffset, leftSize, rightOffset, rightSize); if ( m_bisectionType == BisectionType_ZoneCells ) { ZoneCellOrNodeSorter zoneCellSorter(*m_ccFieldDataPtrs[axisDirToSplit], m_baseItem, m_reducedPrecisionSortDataArrays[axisDirToSplit]); std::nth_element(m_itemList.begin()+domainStart, m_itemList.begin()+domainStart+leftSize, m_itemList.begin()+domainStart+domainSize, zoneCellSorter); } else { ___476(m_bisectionType == BisectionType_ZoneNodes); ZoneCellOrNodeSorter zoneNodeSorter(*m_nodalFieldDataPtrs[axisDirToSplit], m_baseItem, m_reducedPrecisionSortDataArrays[axisDirToSplit]); std::nth_element(m_itemList.begin()+domainStart, m_itemList.begin()+domainStart+leftSize, m_itemList.begin()+domainStart+domainSize, zoneNodeSorter); } ___4352 const nextDirection = (axisDirToSplit+1) % NUM_BISECTION_DIRECTIONS; ItemAddress64::SubzoneOffset_t const nextRecursionDepth = recursionDepth+1; if ( recursionDepth < m_maxRecursion && leftSize > m_maxDomainSize ) { boost::function<void(void)>* leftFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::splitDomain, this, boost::ref(___36), leftOffset, leftSize, nextDirection, nextRecursionDepth, ___2118));
___36.___4157( executeBoostFunction, reinterpret_cast<___90>(leftFunction), ___2118); boost::function<void(void)>* rightFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::splitDomain, this, boost::ref(___36), rightOffset, rightSize, nextDirection, nextRecursionDepth, ___2118)); ___36.___4157( executeBoostFunction, reinterpret_cast<___90>(rightFunction), ___2118); } else { ___2038 = ___2038 && splitDomain(___36, leftOffset, leftSize, nextDirection, nextRecursionDepth, ___2118); ___2038 = ___2038 && splitDomain(___36, rightOffset, rightSize, nextDirection, nextRecursionDepth, ___2118); }
 #if 0 
if ( rightOffset+rightSize == m_numItems ) { boost::function<void(void)>* updateStatusLineFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::updateStatusLine, this, nextRecursionDepth)); TecUtilMainlineInvoke( executeBoostFunction, reinterpret_cast<___90>(updateStatusLineFunction)); }
 #endif
} else { std::sort(m_itemList.begin()+domainStart, m_itemList.begin()+domainStart+domainSize); } return ___2038; } ___372 OrthogonalBisection::updateStatusLine(___37& ___36, ItemAddress64::SubzoneOffset_t recursionDepth) { REQUIRE(m_numRecursionDepths>0); ___372 ___2038 = ___36.___3770(100*recursionDepth/m_numRecursionDepths); return ___2038; } ___372 OrthogonalBisection::loadCoordinateVarZoneFieldData(___37& ___36, char axis) { REQUIRE(axis=='X' || axis=='Y' || axis=='Z'); REQUIRE(m_nodalFieldDataPtrs.size() == size_t(NUM_BISECTION_DIRECTIONS) && m_ccFieldDataPtrs.size() == size_t(NUM_BISECTION_DIRECTIONS)); ___4352 dir = ___4352(axis - 'X'); ___476(dir < NUM_BISECTION_DIRECTIONS); if (___36.___908(___2678 + 1, dir + 1) == ___4330) { m_nodalFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2678 + 1, dir + 1); m_ccFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2678 + 1, dir + 1, false  , true /* ___962 */); } else { m_ccFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2678 + 1, dir + 1); m_nodalFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2678 + 1, dir + 1, false  , true /* ___962 */); } ___372 ___2038 = (m_nodalFieldDataPtrs[dir] != NULL && m_nodalFieldDataPtrs[dir]->___2066() && m_ccFieldDataPtrs[dir] != NULL && m_ccFieldDataPtrs[dir]->___2066()); return ___2038; } void OrthogonalBisection::getMinMaxWeightOverRange( ___81                     rangeStart, ___81                     ___3269, ItemAddress64::SubzoneOffset_t ___2117, ItemAddress64::SubzoneOffset_t numJobs, ___4352                     axisDirToSplit, ___2480&                        weightMinMax) { REQUIRE(rangeStart < m_numItems); REQUIRE(___3269 > 0 && rangeStart+___3269 <= m_numItems); REQUIRE(___2117 < numJobs); REQUIRE(numJobs > 0); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE("weightMinMax isn't required to be initialized"); ___81 jobStart; ___81 jobEnd; getJobStartEndForRange(rangeStart, ___3269, ___2117, numJobs, jobStart, jobEnd); FieldDataPtr fieldDataPtr; if (m_bisectionType == BisectionType_ZoneCells) fieldDataPtr = m_ccFieldDataPtrs[axisDirToSplit]; else fieldDataPtr = m_nodalFieldDataPtrs[axisDirToSplit]; ___1350& ___1349 = *fieldDataPtr; ___2480 minMax; for (___81 ___2084 = jobStart; ___2084 < jobEnd; ___2084++) { double const weight = ___1349.___1779(m_baseItem + m_itemList[___2084] + 1); minMax.include(weight); } weightMinMax = minMax; } void OrthogonalBisection::rescaleWeightsOverRange( ___81                     rangeStart, ___81                     ___3269, ItemAddress64::SubzoneOffset_t ___2117, ItemAddress64::SubzoneOffset_t numJobs, ___4352                     axisDirToSplit, double                         scale, double                         ___2866) { REQUIRE(rangeStart < m_numItems); REQUIRE(___3269 > 0 && rangeStart+___3269 <= m_numItems); REQUIRE(___2117 < numJobs); REQUIRE(numJobs > 0);
REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE(scale >= 0.0); ___81 jobStart; ___81 jobEnd; getJobStartEndForRange(rangeStart, ___3269, ___2117, numJobs, jobStart, jobEnd); FieldDataPtr fieldDataPtr; if (m_bisectionType == BisectionType_ZoneCells) fieldDataPtr = m_ccFieldDataPtrs[axisDirToSplit]; else fieldDataPtr = m_nodalFieldDataPtrs[axisDirToSplit]; ___1350& ___1349 = *fieldDataPtr; UInt8Array& reducedPrecisionSortData = m_reducedPrecisionSortDataArrays[axisDirToSplit]; ___476(static_cast<___81>(reducedPrecisionSortData.size()) == m_numItems + m_numGhostItems); for (___81 ___2084 = jobStart; ___2084 < jobEnd; ___2084++) { ___2719 const index = ___2719( m_itemList[___2084] ); double const weight = ___1349.___1779(m_baseItem + index + 1); double const scaledVal = scale*(weight + ___2866); ___476(0.0 <= scaledVal && scaledVal < 256.0); uint8_t const int8Val = int8_t(scaledVal); reducedPrecisionSortData[index] = int8Val; } } ___372 OrthogonalBisection::calcReducedPrecisionValues( ___37&                    ___36, ___81                     rangeStart, ___81                     ___3269, ___4352                     axisDirToSplit, ItemAddress64::SubzoneOffset_t recursionDepth) { ___372 ___2038 = ___4227; REQUIRE(rangeStart < m_numItems); REQUIRE(___3269 > 0 && rangeStart+___3269 <= m_numItems); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE(recursionDepth < m_numRecursionDepths); static ItemAddress64::SubzoneOffset_t const REDUCED_PRECISION_RECALC_FREQUENCY = 3; if ( recursionDepth % (REDUCED_PRECISION_RECALC_FREQUENCY*NUM_BISECTION_DIRECTIONS) == ItemAddress64::SubzoneOffset_t(axisDirToSplit) ) { ___1350& ___1349 = *m_nodalFieldDataPtrs[axisDirToSplit]; static double const maxNewRange = 255.99; ___476(uint8_t(maxNewRange)==255); ___2480 itemWeightMinMax; if ( recursionDepth < ItemAddress64::SubzoneOffset_t(NUM_BISECTION_DIRECTIONS) ) { double minVal; double maxVal; ___1349.___1758(&minVal, &maxVal); itemWeightMinMax.___3500(minVal, maxVal); } else { ___81 const maxThreadsAvailable = (m_maxThreadedJobs >> recursionDepth); ___81 const maxPossibleJobs = ___3269/MIN_THREADED_ITEM_RANGE_SIZE; ItemAddress64::SubzoneOffset_t const numJobs = ItemAddress64::SubzoneOffset_t( std::min(maxThreadsAvailable, maxPossibleJobs) ); if ( numJobs > 1 ) { ___2119 ___2118 = ___36.___4159(); ___2482 jobMinMaxes; if ( ___2118 && jobMinMaxes.alloc(numJobs) ) { try { for ( ItemAddress64::SubzoneOffset_t ___2117 = 0; ___2117 < numJobs; ___2117++ ) { boost::function<void(void)>* getMinMaxFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::getMinMaxWeightOverRange, this, rangeStart, ___3269, ___2117, numJobs, axisDirToSplit, boost::ref(jobMinMaxes[___2117]))); ___36.___4157( executeBoostFunction, reinterpret_cast<___90>(getMinMaxFunction), ___2118); } } catch (...) { ___2038 = ___1303; } ___36.___4162(___2118);
___36.___4160(&___2118); } if ( ___2038 ) { for ( ItemAddress64::SubzoneOffset_t ___2117 = 0; ___2117 < numJobs; ___2117++ ) itemWeightMinMax.include(jobMinMaxes[___2117]); } } else { getMinMaxWeightOverRange(rangeStart, ___3269, 0 , 1/*numJobs*/, axisDirToSplit, itemWeightMinMax); } } if ( ___2038 ) { double const ___2866 = -itemWeightMinMax.minValue(); double const scale = (itemWeightMinMax.maxValue() > itemWeightMinMax.minValue()+___3629) ? maxNewRange / ( itemWeightMinMax.maxValue() - itemWeightMinMax.minValue() ) : 0.; ___81 const maxThreadsAvailable = (m_maxThreadedJobs >> recursionDepth); ___81 const maxPossibleJobs = ___3269/MIN_THREADED_ITEM_RANGE_SIZE; ItemAddress64::SubzoneOffset_t const numJobs = ItemAddress64::SubzoneOffset_t( std::min(maxThreadsAvailable, maxPossibleJobs) ); if ( numJobs > 1 ) { ___2119 ___2118 = ___36.___4159(); if ( ___2118 ) { try { for ( ItemAddress64::SubzoneOffset_t ___2117 = 0; ___2117 < numJobs; ___2117++ ) { boost::function<void(void)>* rescaleFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::rescaleWeightsOverRange, this, rangeStart, ___3269, ___2117, numJobs, axisDirToSplit, scale, ___2866)); ___36.___4157( executeBoostFunction, reinterpret_cast<___90>(rescaleFunction), ___2118); } } catch (...) { ___2038 = ___1303; } ___36.___4162(___2118); ___36.___4160(&___2118); } } else { rescaleWeightsOverRange(rangeStart, ___3269, 0 , 1/*numJobs*/, axisDirToSplit, scale, ___2866); } } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 OrthogonalBisection::performBisection(___37& ___36) { ___372 ___2038 = ___4227; ___36.___856(); double maxThreads = ___36.___4158() * MAX_THREADS_PER_CORE; m_maxRecursion = static_cast<ItemAddress64::SubzoneOffset_t>(std::max(1.0, log(maxThreads) / log(2.0))); m_maxThreadedJobs = 1 << m_maxRecursion; ___2685 = ___36.___4620(___2678 + 1); std::tie(m_baseItem,m_numItems) = bisectionSize(___36, ___2678, m_section, ___2685, m_bisectionType); GhostInfo_pa ghostInfo = m_bisectionType == BisectionType_ZoneCells ? ___36.zoneGhostCellInfoGetRef(___2678+1) : ___36.zoneGhostNodeInfoGetRef(___2678+1); ItemAddress64::SectionOffset_t const sectionIndex = m_bisectionType == BisectionType_ZoneCells ? m_section+1 : 1; m_numGhostItems = ghostInfo ? ___36.ghostInfoGetNumItemsByRef(ghostInfo,sectionIndex) : 0; m_numItems -= m_numGhostItems; m_numRecursionDepths = calcNumRecursionDepths(); m_numDomains = calcNumDomains(); ___2038 = ___2038 && m_nodalFieldDataPtrs.alloc(NUM_BISECTION_DIRECTIONS); ___2038 = ___2038 && m_ccFieldDataPtrs.alloc(NUM_BISECTION_DIRECTIONS); ___2038 = ___2038 && loadCoordinateVarZoneFieldData(___36, 'X'); ___2038 = ___2038 && loadCoordinateVarZoneFieldData(___36, 'Y'); ___2038 = ___2038 && loadCoordinateVarZoneFieldData(___36, 'Z'); ___2038 = ___2038 && m_itemList.alloc(m_numItems + m_numGhostItems);
if ( ___2038 ) { if ( m_numGhostItems > 0 ) { boost::unordered_set<___81> ghostItemSet; for(___81 ___1840 = 0; ___1840 < m_numGhostItems; ++___1840) ghostItemSet.insert(___36.ghostInfoGetItemByRef(ghostInfo, sectionIndex, ___1840+1) - 1); ___81 realIndex = 0; ___81 ghostIndex = m_numItems; for (___81 ___1840 = 0; ___1840 < m_numItems + m_numGhostItems; ___1840++) { if (ghostItemSet.find(___1840) != ghostItemSet.end()) m_itemList[ghostIndex++] = ___1840; else m_itemList[realIndex++] = ___1840; } ___476(realIndex == static_cast<___81>(m_numItems)); ___476(ghostIndex == m_numItems + m_numGhostItems); } else { for (___81 ___1840 = 0; ___1840 < m_numItems; ___1840++) m_itemList[___1840] = ___1840; } } ___2038 = ___2038 && m_reducedPrecisionSortDataArrays.alloc(NUM_BISECTION_DIRECTIONS); for ( ___4352 dir = 0; ___2038 && dir < NUM_BISECTION_DIRECTIONS; dir++ ) ___2038 = ___2038 && m_reducedPrecisionSortDataArrays[dir].alloc(m_numItems + m_numGhostItems); if (___2038 && m_numItems > 0) { ___2119 ___2118 = ___36.___4159(); if ( ___2118 ) { try { boost::function<void(void)>* splitFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::splitDomain, this, boost::ref(___36), 0 , m_numItems/*size*/, 0/*axisDir*/, 0/*recursionDepth*/, ___2118)); ___36.___4157( executeBoostFunction, reinterpret_cast<___90>(splitFunction), ___2118); } catch (...) { ___2038 = ___1303; } } ___36.___4162(___2118); ___36.___4160(&___2118); } m_reducedPrecisionSortDataArrays.___935(); ___36.___857(); m_nodalFieldDataPtrs.___935(); m_ccFieldDataPtrs.___935(); return ___2038; } void OrthogonalBisection::getSzCoordsByRange( ___81                     rangeStart, ___81                     ___3269, ItemAddress64::SubzoneOffset_t ___2117, ItemAddress64::SubzoneOffset_t numJobs, ItemAddressArray&              szCoordArray) { REQUIRE(IMPLICATION(m_numItems > 0, rangeStart < m_numItems)); REQUIRE(IMPLICATION(m_numItems > 0, ___3269 > 0 && rangeStart+___3269 <= m_numItems)); REQUIRE(___2117 < numJobs); REQUIRE(numJobs > 0); REQUIRE(szCoordArray.size()==size_t(m_numItems + m_numGhostItems)); ___81 jobStart; ___81 jobEnd; getJobStartEndForRange(rangeStart, ___3269, ___2117, numJobs, jobStart, jobEnd); ItemAddress64::SubzoneOffset_t const szStart = ItemAddress64::SubzoneOffset_t(jobStart); ItemAddress64::SubzoneOffset_t const szEnd = ItemAddress64::SubzoneOffset_t(jobEnd); ___81 newItem = jobStart*___81(m_maxDomainSize); for (ItemAddress64::SubzoneOffset_t ___3881 = szStart; ___3881 < szEnd; ++___3881) { ItemAddress64::ItemOffset_t subzoneSize = getDomainSize(___3881); for (ItemAddress64::ItemOffset_t ___2866 = 0; ___2866 < subzoneSize; ++___2866) { ___81 const orgItem = queryPositionbyOffset(newItem); szCoordArray[orgItem] = ItemAddress64(___2678, m_section, ___3881, ___2866); ++newItem; } } } ___372 OrthogonalBisection::getSzCoordByOriginalItemArray(___37& ___36, ItemAddressArray& szCoordByOriginalItem)
{ REQUIRE(szCoordByOriginalItem.empty()); REQUIRE(m_numItems >= 0); ___372 ___2038 = szCoordByOriginalItem.alloc(m_numItems + m_numGhostItems); if ( ___2038 ) { ___81 const maxThreadsAvailable = m_maxThreadedJobs; ___81 const maxPossibleJobs = m_numDomains/MIN_THREADED_SUBZONE_RANGE_SIZE; ItemAddress64::SubzoneOffset_t const numJobs = ItemAddress64::SubzoneOffset_t( std::min(maxThreadsAvailable, maxPossibleJobs) ); if ( numJobs > 1 ) { ___2119 ___2118 = ___36.___4159(); if ( ___2118 ) { try { for ( ItemAddress64::SubzoneOffset_t ___2117 = 0; ___2117 < numJobs; ___2117++ ) { boost::function<void(void)>* updateFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::getSzCoordsByRange, this, 0 , m_numDomains/*size*/, ___2117, numJobs, boost::ref(szCoordByOriginalItem))); ___36.___4157( executeBoostFunction, reinterpret_cast<___90>(updateFunction), ___2118); } } catch (...) { ___2038 = ___1303; } ___36.___4162(___2118); ___36.___4160(&___2118); } } else { getSzCoordsByRange(0 , m_numDomains/*___3269*/, 0/*___2117*/, 1/*numJobs*/, szCoordByOriginalItem); } } return ___2038; } std::pair<___81,___81> bisectionSize( ___37 const&                    ___36, ___4636                          zone, ItemAddress64::SectionOffset_t       section, ZoneType_e                           ___4692, OrthogonalBisection::BisectionType_e bisectionType) { REQUIRE(zone >= 0); REQUIRE(VALID_ENUM(___4692, ZoneType_e)); REQUIRE(bisectionType == OrthogonalBisection::BisectionType_ZoneCells || (bisectionType == OrthogonalBisection::BisectionType_ZoneNodes && section == 0)); ___1843 ___4632; ___36.___4615(zone + 1, ___4632); if (bisectionType == OrthogonalBisection::BisectionType_ZoneCells) { ___476(___3895(___4692, ___36.zoneGetDimension( ___36.datasetGetUniqueID(),zone + 1))); if (___4692 == ___4704) { return std::pair<___81,___81>(0,___4632.___1667()); } else { ___476(___4692 != ___4698 || ___4692 != ___4699); FECellShape_e         cellShape = FECellShape_Invalid; ___1170            gridOrder = 0; FECellBasisFunction_e basisFn = FECellBasisFunction_Invalid; ___4265 const datasetID = ___36.datasetGetUniqueID(); ___2226 baseSectionElem = 0; ___2226 numElements = 0; ___1170 numCornersPerElem = 0; ___1170 numNodesPerElem = 0; for (ItemAddress64::SectionOffset_t sec = 0; sec <= section; ++sec) { baseSectionElem += numElements; if (!___36.zoneGetSectionMetrics( datasetID, zone+1, sec+1, &cellShape, &gridOrder, &basisFn, &numElements, &numCornersPerElem, &numNodesPerElem)) throw std::runtime_error("Failed to acquire zone section metrics"); } return std::pair<___81,___81>(baseSectionElem,numElements); } } else { return std::pair<___81,___81>(0,___4632.___1669()); } } }}
