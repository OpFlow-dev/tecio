#include "stdafx.h"
#include "MASTER.h"
#include "ThirdPartyHeadersBegin.h"
#include <memory>
#include "ThirdPartyHeadersEnd.h"
 #define ___854
#include "GLOBAL.h"
#include "CodeContract.h"
#include "TASSERT.h"
#include "ALLOC.h"
#include "AUXDATA.h"
#include "DATASET.h"
#include "FILESTREAM.h"
#include "TecplotVersion.h"
#include "FileSystem.h"
#include "TecplotFileZoneFormat.h"
#include "GEOM2.h"
#include "GEOM.h"
#include "INPUT.h"
#include "SET.h"
#include "TEXT.h"
#include "DATAIO4.h"
#include "DATASET0.h"
#include "CHARTYPE.h"
#include "STRUTIL.h"
#include "ARRLIST.h"
#include "STRLIST.h"
#include "Q_MSG.h"
 #if defined ___1993
#include <ieeefp.h>
 #endif
using namespace tecplot;
 #if defined MSWIN
 #if !defined TECPLOTKERNEL
 #pragma warning(disable : 4244)
 #endif
 #pragma warning(disable: 4789)
 #endif
 #if defined DECALPHA || defined ___532
 #define _IEEE_FP_INEXACT
 #define _IEEE_FP
 #endif
 #if defined SUN41
 #define SEEK_SET 0
 #define SEEK_CUR 1
 #define SEEK_END 2
 #endif
static char FilterFloatChar(float X) { char C; if (((X >= 32.0) && (X <= 127.0)) || ((X >= 160.0) && (X <= 255.0)) || (X == 0.0)) C = (char)X; else C = '?'; return (C); } double ___1761(___1403   *___1399, FieldDataType_e ___1362, double          VMin, double          VMax, ___372      *___2039) { double X = 0.0; REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); REQUIRE(!(*___2039) || VALID_FIELD_DATA_TYPE(___1362)); REQUIRE(!(*___2039) || VALID_REF(___1399)); if (*___2039) { switch (___1362) { case FieldDataType_Float : { float XX; *___2039 = (___4199(&XX, 4, 1, ___1399->File) == 1); if (!___1399->___2006) ___3368(&XX); if (*___2039) X = XX; else X = 0.0; } break; case FieldDataType_Double : { double XX; *___2039 = (___4199(&XX, sizeof(double), 1, ___1399->File) == 1); if (!___1399->___2006) ___3371(&XX); if (*___2039) X = XX; else X = 0.0; } break; case FieldDataType_Int32  : { int32_t ___2164; *___2039 = (___4199(&___2164, sizeof(int32_t), 1, ___1399->File) == 1); if (!___1399->___2006) ___3368(&___2164); if (*___2039) X = (double)___2164; } break; case FieldDataType_Int16  : { int16_t S; *___2039 = (___4199(&S, sizeof(int16_t), 1, ___1399->File) == 1); if (!___1399->___2006) ___3365(&S); if (*___2039) X = (double)S; } break; case FieldDataType_Byte  : { uint8_t B; *___2039 = (___4199(&B, sizeof(uint8_t), 1, ___1399->File) == 1); if (*___2039) X = (double)B; } break; case ___1363 : { uint8_t B; *___2039 = (___4199(&B, sizeof(uint8_t), 1, ___1399->File) == 1); if (*___2039) X = (double)(B & (uint8_t)01); } break; default: ___476(___1303); break; } if (*___2039) { if ((X < VMin) || (X > VMax)) { *___2039 = ___1303; } } } return X; } template <typename SRC_INT_TYPE> SRC_INT_TYPE ___1749( ___1403* ___1398, short         pltFileVersion, SRC_INT_TYPE  minValue, SRC_INT_TYPE  maxValue, ___372*    ___2038) { REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); REQUIRE(!(*___2038) || (0 < pltFileVersion && pltFileVersion <= TecplotSDKBinaryFileVersion)); REQUIRE(!(*___2038) || (VALID_REF(___1398) && VALID_REF(___1398->File))); REQUIRE(!(*___2038) || minValue <= maxValue); SRC_INT_TYPE intValue = 0; if (*___2038) { if (pltFileVersion <= 63) { if (*___2038) { float X = (float)___1761(___1398, FieldDataType_Float, (double)minValue - 1.0e-10, (double)maxValue + 1.0e-10, ___2038); if (*___2038) { if (___1(X) < (float)___2181) intValue = (SRC_INT_TYPE)X; else *___2038 = ___1303; } else *___2038 = ___1303; } } else { *___2038 = (___4199(&intValue, sizeof(intValue), 1, ___1398->File) == 1); if (*___2038 && !___1398->___2006) { if (sizeof(intValue) == 2) ___3365(&intValue); else if (sizeof(intValue) == 4) ___3368(&intValue); else if (sizeof(intValue) == 8) ___3371(&intValue); } } if (static_cast<___2226>(intValue) < minValue || maxValue < static_cast<___2226>(intValue)) *___2038 = ___1303; } return intValue; } template int32_t ___1749<int32_t>(___1403*, short, int32_t, int32_t, ___372*);
template int64_t ___1749<int64_t>(___1403*, short, int64_t, int64_t, ___372*); static ___372 ReallocString(char      **___3814, size_t    NewLength) { ___372 ___2039; char *___2701; REQUIRE(VALID_REF(___3814)); REQUIRE(*___3814 == NULL || VALID_REF(*___3814)); REQUIRE((*___3814 != NULL && NewLength >= strlen(*___3814)) || (*___3814 == NULL)); ___2701 = ___23(NewLength + 1, char, "reallocated string"); ___2039 = (___2701 != NULL); if (___2039) { if (*___3814 == NULL) { ___2701[0] = '\0'; } else { strcpy(___2701, *___3814); ___1528(*___3814, "old string"); } *___3814 = ___2701; } ENSURE(VALID_BOOLEAN(___2039)); ENSURE(IMPLICATION(___2039, VALID_REF(*___3814))); return ___2039; } namespace { ___372 ___3290(___1403  *___1399, short          ___2103, int            ___2352, char         **TargetStr, ___372      ___3204) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(0 < ___2103 && ___2103 <= TecplotSDKBinaryFileVersion); REQUIRE(IMPLICATION(___2103 < 63 || ___3204, ___2352 >= 0)); REQUIRE(IMPLICATION(___3204, VALID_REF(TargetStr))); REQUIRE(VALID_BOOLEAN(___3204)); ___372 ___2039 = ___4227; if (___2103 < 63) { float X; if (___3204) { *TargetStr = ___23(___2352 + 1, char, "target string"); ___2039 = (*TargetStr != NULL); } if (___2039) { ___2226 ___1831; for (___1831 = 0; ___2039 && ___1831 < ___2352; ___1831++) { X = (float)___1761(___1399, FieldDataType_Float, 0.0, 127.0, &___2039); if (!___2039) break; if (___3204) (*TargetStr)[___1831] = FilterFloatChar(X); } if (___3204) (*TargetStr)[___1831] = '\0'; } else { ___1175(___4218("Cannot allocate memory for string during read", "'string' meaning the computer science data type")); } } else { size_t const MAX_STRBUFFER_LEN = 4095; static char  StrBuffer[MAX_STRBUFFER_LEN+1]; size_t       StrBufferLen = 0; size_t       TargetStrLen = 0; int          ___1831 = 0; ___2226    CharValue = 0; if (___3204) *TargetStr = NULL; do { CharValue = ___1749<int32_t>(___1399, ___2103, 0, 255, &___2039); if (___2039 && ___3204) { if (CharValue != '\0' && (___1831 < ___2352 || ___2352 == 0)) { StrBuffer[StrBufferLen] = (char)CharValue; StrBufferLen++; } if (CharValue == '\0' || StrBufferLen == MAX_STRBUFFER_LEN) { if (StrBufferLen != 0 || *TargetStr == NULL) { StrBuffer[StrBufferLen] = '\0'; TargetStrLen += StrBufferLen; ___2039 = ReallocString(TargetStr, TargetStrLen); if (___2039) strcat(*TargetStr, StrBuffer); StrBufferLen = 0; } } } ___1831++; } while (___2039 && (char)CharValue != '\0'); if (!___2039       && ___3204 && *TargetStr != NULL) { ___1528(*TargetStr, "failed read string"); *TargetStr = NULL; } } ENSURE(IMPLICATION(___3204, (VALID_REF(*TargetStr) || *TargetStr == NULL))); ENSURE(VALID_BOOLEAN(___2039)); return (___2039); } } namespace { ___372 ___3290(___1403* ___1398, short         iVersion, int           maxCharacters, std::string*  targetStrPtr, ___372     processData) { REQUIRE(VALID_REF(___1398) && VALID_REF(___1398->File));
REQUIRE(0 < iVersion && iVersion <= TecplotSDKBinaryFileVersion); REQUIRE(IMPLICATION(iVersion < 63 || processData, maxCharacters >= 0)); REQUIRE(IMPLICATION(processData, VALID_REF(targetStrPtr) && targetStrPtr->empty())); REQUIRE(VALID_BOOLEAN(processData)); ___372 ___2038 = ___4227; char* targetCstr = NULL; try { ___2038 = ___3290(___1398, iVersion, maxCharacters, processData ? &targetCstr : NULL, processData); if (___2038 && processData) *targetStrPtr = targetCstr; } catch (std::bad_alloc const&) { ___2038 = ___1303; } if (targetCstr != NULL) ___1528(targetCstr, "C string"); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } static void ReadDoubleBlock(___1403 *___1399, ___372     ___1097, double       *___417, ___2226     ___3686, ___2226     ___2843, ___372    *___2039) { if (___1097) { double *DPtr = ___417 + ___3686; *___2039 = (___4199(DPtr, sizeof(double), ___2843, ___1399->File) == (size_t)___2843); if (!___1399->___2006 && *___2039) { ___2226 N; for (N = 0; N < ___2843; N++) ___3371(&DPtr[N]); } } else *___2039 = (___4201(___1399->File, ___2843 * sizeof(double), SEEK_CUR) == 0); } static void ReadFloatBlock(___1403 *___1399, ___372     ___1097, float        *___417, ___2226     ___3686, ___2226     ___2843, ___372    *___2039) { if (___1097) { float *FPtr = ___417 + ___3686; *___2039 = (___4199(FPtr, sizeof(float), ___2843, ___1399->File) == (size_t)___2843); if (!___1399->___2006 && *___2039) { ___2226 N; for (N = 0; N < ___2843; N++) ___3368(&FPtr[N]); } } else *___2039 = (___4201(___1399->File, ___2843 * sizeof(float), SEEK_CUR) == 0); } static void ReadBitBlock(___1403 *___1399, ___372     ___1097, uint8_t       *___417, ___2226     ___2843, ___372    *___2039) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4227) == (___417 != NULL)); REQUIRE(___2843 > 0); REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); ___2226 const NumBytes = (___2843 + 7) / 8; if (___1097) { *___2039 = (___4199(___417, sizeof(uint8_t), NumBytes, ___1399->File) == (size_t)NumBytes); } else *___2039 = (___4201(___1399->File, NumBytes * sizeof(uint8_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2039)); } void ___3278(___1403 *___1399, ___372     ___1097, uint8_t       *___417, ___2226     ___3686, ___2226     ___2843, ___372    *___2039) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4227) == (___417 != NULL)); REQUIRE(___3686 >= 0); REQUIRE(___2843 > 0); REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); if (___1097) { *___2039 = (___4199(___417 + ___3686, sizeof(uint8_t), ___2843, ___1399->File) == (size_t)___2843); } else *___2039 = (___4201(___1399->File, ___2843 * sizeof(uint8_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2039)); } void ___3291(___1403 *___1399,
___372     ___1097, int16_t      *___417, ___2226     ___3686, ___2226     ___2843, ___372    *___2039) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4227) == (___417 != NULL)); REQUIRE(___3686 >= 0); REQUIRE(___2843 > 0); REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); if (___1097) { int16_t *___1985 = ___417 + ___3686; *___2039 = (___4199(___1985, sizeof(int16_t), ___2843, ___1399->File) == (size_t)___2843); if (!___1399->___2006 && *___2039) { ___2226 N; for (N = 0; N < ___2843; N++) ___3365(&___1985[N]); } } else *___2039 = (___4201(___1399->File, ___2843 * sizeof(int16_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2039)); } void ___3292(___1403 *___1399, ___372     ___1097, int32_t      *___417, ___2226     ___3686, ___2226     ___2843, ___372    *___2039) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4227) == (___417 != NULL)); REQUIRE(___3686 >= 0); REQUIRE(___2843 > 0); REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); if (___1097) { ___2226 EndIndex = ___3686 + ___2843; for (___2226 ValueIndex = ___3686; *___2039 && ValueIndex < EndIndex; ValueIndex++) { int16_t ___4315; *___2039 = (___4199(&___4315, sizeof(int16_t), 1, ___1399->File) == 1); if (!___1399->___2006 && *___2039) ___3365(&___4315); ___417[ValueIndex] = (int32_t)___4315; } } else *___2039 = (___4201(___1399->File, ___2843 * sizeof(int16_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2039)); } void ___3293(___1403 *___1399, ___372     ___1097, int32_t      *___417, ___2226     ___3686, ___2226     ___2843, ___372    *___2039) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4227) == (___417 != NULL)); REQUIRE(___3686 >= 0); REQUIRE(___2843 > 0); REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); if (___1097) { int32_t* int32Ptr = ___417 + ___3686; size_t const freadResult = ___4199(int32Ptr, sizeof(int32_t), ___2843, ___1399->File); *___2039 = (freadResult == (size_t)___2843); if (!___1399->___2006 && *___2039) { for (___2226 N = 0; N < ___2843; N++) ___3368(&int32Ptr[N]); } } else *___2039 = (___4201(___1399->File, ___2843 * sizeof(int32_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2039)); } void ReadInt64Block(___1403 *___1399, ___372     ___1097, int64_t      *___417, ___2226     ___3686, ___2226     ___2843, ___372    *___2039) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4227) == (___417 != NULL)); REQUIRE(___3686 >= 0); REQUIRE(___2843 > 0); REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); if (___1097) { int64_t *___1985 = ___417 + ___3686; *___2039 = (___4199(___1985,
sizeof(int64_t), ___2843, ___1399->File) == (size_t)___2843); if (!___1399->___2006 && *___2039) { ___2226 N; for (N = 0; N < ___2843; N++) ___3371(&___1985[N]); } } else *___2039 = (___4201(___1399->File, ___2843 * sizeof(int64_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2039)); } void ___3297(___1403   *___1399, ___372       ___1097, void           *___417, FieldDataType_e ___1362, ___2226       ___3686, ___2226       ___2843, ___372      *___2039) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(!___1097 || VALID_REF(___417)); REQUIRE(VALID_FIELD_DATA_TYPE(___1362)); REQUIRE(___3686 >= 0); REQUIRE(___2843 >= 0); REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); switch (___1362) { case FieldDataType_Float : { ReadFloatBlock(___1399, ___1097, (float *)___417, ___3686, ___2843, ___2039); } break; case FieldDataType_Double : { ReadDoubleBlock(___1399, ___1097, (double *)___417, ___3686, ___2843, ___2039); } break; case ___1363 : { if (___3686 != 0) { ___1175(___4218("Internal Error: Attempt to read bit data at non-zero offset", "see Tecplot User's manual for a definition of 'bit' data")); *___2039 = ___1303; } else ReadBitBlock(___1399, ___1097, (uint8_t *)___417, ___2843, ___2039); } break; case FieldDataType_Byte : { ___3278(___1399, ___1097, (uint8_t *)___417, ___3686, ___2843, ___2039); } break; case FieldDataType_Int16 : { ___3291(___1399, ___1097, (int16_t *)___417, ___3686, ___2843, ___2039); } break; case FieldDataType_Int32 : { ___3293(___1399, ___1097, (int32_t *)___417, ___3686, ___2843, ___2039); } break; case ___1364 : case ___1366 : default: ___476(___1303); break; } ENSURE(VALID_BOOLEAN(*___2039)); } void ___3277(___1403   *___1399, ___1359    ___1350, ___372       ___1097, FieldDataType_e ___1365, ___2226       ___3686, ___2226       EndIndex, ___372      *___2039) { REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); REQUIRE(IMPLICATION(___2039, VALID_REF(___1399))); REQUIRE(IMPLICATION(___2039, VALID_FIELD_DATA_TYPE(___1365))); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___1350))); ___372 ReadByBlock = IMPLICATION(___1097, ___1725(___1350) == ___1365); REQUIRE(ReadByBlock || (___1365 != ___1363)); if (*___2039) { ___2226 ___2843 = EndIndex - ___3686 + 1; if (ReadByBlock) { void *data_array; if (___1097) data_array = ___1731(___1350); else data_array = NULL; ___3297(___1399, ___1097, data_array, ___1365, ___3686, ___2843, ___2039); } else { ___2226 N; for (N = 0; *___2039 && (N < ___2843); N++) { double D = ___1761(___1399, ___1365, -___2178, ___2178, ___2039); if (___1097) ___3491(___1350, N + ___3686, D); } } } } void ___3279(___1403         *___841,
___1359          ___1350, FieldDataType_e       ___1365, ___2226             ___2811, ___2226             ___2816, ___2226             ___2819, ___372            *___2039) { REQUIRE(IMPLICATION(*___2039, VALID_REF(___841))); REQUIRE(IMPLICATION(*___2039, VALID_FIELD_DATA_TYPE(___1365))); REQUIRE(VALID_REF(___1350)); REQUIRE(___2811 >= 0); REQUIRE(___2816 >= 0); REQUIRE(___2819 >= 0); REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); if (*___2039) { ___2226 ___2105, ___2134; ___2226 ___2808  = ___2811 * ___2816; ___2226 ___1838      = MAX(___2811 - 1, 1); ___2226 ___2110      = MAX(___2816 - 1, 1); ___2226 ___2138      = MAX(___2819 - 1, 1); ___2226 ___2843 = (___1838 * ___2110 * ___2138); ___372 IsLinear  = ((___2816 == 1 && ___2819 == 1) || (___2811 == 1 && ___2819 == 1) || (___2811 == 1 && ___2816 == 1)); if (IsLinear) ___3277(___841, ___1350, ___4227, ___1365, 0, ___2843 - 1, ___2039); else for (___2134 = 0; ___2134 < ___2138 && ___2039; ___2134++) for (___2105 = 0; ___2105 < ___2110 && ___2039; ___2105++) { ___2226 ___461 = 0 + (___2105 * ___2811) + (___2134 * ___2808); ___3277(___841, ___1350, ___4227, ___1365, ___461, ___461 + ___1838 - 1, ___2039); } } ENSURE(VALID_BOOLEAN(*___2039)); } static void AdjustCustomColor(short         ___2103, ___514 *___351) { REQUIRE(0 < ___2103 && ___2103 <= TecplotSDKBinaryFileVersion); REQUIRE(VALID_REF(___351)); if ((___2103 < 70) && (*___351 >= 15) && (*___351 <= 22)) *___351 -= 7; } ___372 ___3288(___1403   *___1399, short           ___2103, char          **___901, DataFileType_e *___1406, int            *NumVars, ___3840  *___4366) { ___1170   ___716; ___372    ___2039 = ___4227; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(0 < ___2103 && ___2103 <= TecplotSDKBinaryFileVersion); REQUIRE(VALID_REF(___901) || (___901 == NULL)); REQUIRE(VALID_REF(___1406) || (___1406 == NULL)); REQUIRE(VALID_REF(NumVars)); REQUIRE(VALID_REF(___4366) || (___4366 == NULL)); *NumVars      = 0; if (___901) *___901 = NULL; if (___2103 >= 109) { if (___1406) *___1406 = (DataFileType_e)___1749<int32_t>(___1399, ___2103, 0, ___846, &___2039); else ___1749<int32_t>(___1399, ___2103, 0, ___846, &___2039); } if (___3290(___1399, ___2103, ((___2103 < 63) ? 80 : ___2356), ___901, (___372)(___901 != NULL))) { if (___901) ___4226(*___901); *NumVars = ___1749<int32_t>(___1399, ___2103, 0, ___2392, &___2039); } else ___2039 = ___1303; if (___2039 && (*NumVars > ___2383)) { ___1175(___4218("Too many variables")); ___2039 = ___1303; } if (___2039 && ___4366) { if (*NumVars > 0) { *___4366 = ___3822(); ___2039 = (*___4366 != NULL); if (___2039) ___2039 = ___3844(*___4366, *NumVars - 1, NULL);
if (!___2039) { if (*___4366 != NULL) ___3829(___4366); ___1175(___4218("Out of space while allocating var names")); } } } for (___716 = 0; ___2039 && (___716 < *NumVars); ___716++) { char *VName = NULL; ___2039 = ___3290(___1399, ___2103, ((___2103 < 63) ? 5 : ___2357), ___4366 ? &VName : NULL, (___372)(___4366 != NULL)); if (___2039 && ___4366) { if (VName == NULL) { VName = ___23(1, char, "empty variable name"); strcpy(VName, ""); } ___4226(VName); ___2039 = ___3354(&VName); ___2039 = ___2039 && ___3844(*___4366, ___716, VName); if (VName != NULL) ___1528(VName, "variable name"); } if (!___2039) { if (___4366 && *___4366) ___3829(___4366); ___1175(___4218("Out of space while allocating variable names")); } } ENSURE(VALID_BOOLEAN(___2039)); return (___2039); } namespace { ___372 ReadInPresetZoneColor( ___1403* ___1399, short         ___2103, ___4683&   ___4677) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(0 < ___2103 && ___2103 <= TecplotSDKBinaryFileVersion); ___372 ___2039 = ___4227; ___2226 ZoneColor = ___1749<int32_t>(___1399, ___2103, -1, ___2194, &___2039); if (___2039) { if (VALID_BASIC_COLOR(ZoneColor)) { ___4677.___4647.___3175 = (___1170)ZoneColor; AdjustCustomColor(___2103, &___4677.___4647.___3175); } else if (ZoneColor != -1) { ___2039 = ___1303; } } ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } } namespace{ void ConvertCommonTimeToSolutionTime(___4683& ___4677) { REQUIRE(___4677.___230 == NULL || VALID_REF(___4677.___230)); int32_t ___2095; if (___4677.___230 != NULL && ___246(___4677.___230, AuxData_Common_Time, &___2095)) { const char    *SameName; ___90     ___4315; AuxDataType_e  ___4237; ___372      ___3363; ___244(___4677.___230, ___2095, &SameName, &___4315, &___4237, &___3363); ___476(ustrcmp(AuxData_Common_Time, SameName) == 0); ___476(___4237 == ___270); char *EndPtr = NULL; double ___3642 = strtod((const char *)___4315, &EndPtr); if (EndPtr != (char *)___4315) { while (tecplot::isspace(*EndPtr)) EndPtr++; } if (EndPtr != (char *)___4315 && *EndPtr == '\0') { ___4677.___3642 = ___3642; ___4677.___3787     = ___3788; ___237(___4677.___230, ___2095); } } } } ___372 ___3296( ___1403*                ___1399, TecplotFileZoneFormat const& tecplotFileZoneFormat, ___4683&                  ___4677, ___3502                       ___2074, ___1170                   NumVars, ___90                   ___263, ___372*                   ___2052, ___2226*                   ___1439) { ___1170 ___4337; ___372  ___2039 = ___4227; ___2226  I1; short const pltFileVersion = tecplotFileZoneFormat.fileVersion(); REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(tecplotFileZoneFormat.___2066()); REQUIRE(___2074 == NULL || VALID_REF(___2074));
REQUIRE(NumVars >= 0); REQUIRE(VALID_REF(___2052)); REQUIRE(VALID_REF(___1439)); ___4677.tecplotFileZoneVersion = tecplotFileZoneFormat.zoneVersion(); if (___2074 != NULL) { ___491(___2074); ___2039 = ___1199(___2074, NumVars, ___1303); } char* zoneName = NULL; if (___2039) ___2039 = ___3290(___1399, pltFileVersion, ((pltFileVersion < 63) ? 10 : ___2359), &zoneName, ___4227); if (___2039) { try { ___4677.___2686 = zoneName; ___3859(___4677.___2686, ___2359); } catch (std::bad_alloc const&) { ___2039 = ___1303; } ___1528(zoneName, "zone name"); zoneName = NULL; } if (___2039 && pltFileVersion < 101) { ___372    IsZoneFinite   = ___1303; DataFormat_e ZoneDataFormat = ___853; I1 = ___1749<int32_t>(___1399, pltFileVersion, 0, 3, &___2039); ___2039 = (0 <= I1 && I1 <= 3); if (___2039) { ZoneDataFormat = (DataFormat_e)I1; IsZoneFinite = (ZoneDataFormat == ___850 || ZoneDataFormat == ___849); ___4677.___4647.___2026 = (ZoneDataFormat == ___851 || ZoneDataFormat == ___849); } if (___2039 && pltFileVersion > 62) ___2039 = ReadInPresetZoneColor(___1399, pltFileVersion, ___4677); if (___2039 && pltFileVersion < 60) ___1761(___1399, FieldDataType_Float, -___2178, ___2178, &___2039); ___2226 numIPts = 1; ___2226 numJPts = 1; ___2226 numKPts = 1; if (___2039) { ___476(!tecplotFileZoneFormat.has64BitFaceCounts()); numIPts = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); numJPts = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); numKPts = pltFileVersion >= 60 ? ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039) : 1; } if (___2039) { if (!((numIPts == 0) && (numJPts == 0) && (numKPts == 0)) && ((numIPts <= 0) || (numJPts <= 0) || (numKPts < 0)  || ((!IsZoneFinite && (numKPts == 0))))) { ___1175(___4218("Datafile is corrupted")); ___2039 = ___1303; } if (IsZoneFinite) { if (pltFileVersion >= 61) { ___4677.setType((ZoneType_e)(numKPts + 1)); if (___4677.___4237 == ___4704   || ___4677.___4237 == ___4698 || ___4677.___4237 == ___4699) { ___2039 = ___1303; } if (!___2039) ___1175(___4218("Datafile corrupted: Invalid element type for FE DataSet")); } else { ___4677.setType(___4700); } } else { ___4677.setType(___4704); } } if (___2039) ___4677.assignMetrics(numIPts, numJPts, numKPts); *___2052 = ___1303; *___1439  = 0; } else if (___2039) { if (___2039 && (pltFileVersion >= 107)) { ___1749<int32_t>(___1399, pltFileVersion, -___2181, ___2181, &___2039); } if (___2039 && (pltFileVersion >= 106)) { ___4677.___3787     = ___1749<int32_t>(___1399, pltFileVersion, -2, ___2392 - 1, &___2039); ___4677.___3642 = ___1761(___1399, FieldDataType_Double, -___2178, ___2178, &___2039); if (!___2039) ___1175(___4218("Invalid datafile: bad StrandID or SolutionTime")); } ___2039 = ___2039 && ReadInPresetZoneColor(___1399, pltFileVersion, ___4677);
I1 = (ZoneType_e)___1749<int32_t>(___1399, pltFileVersion, 0, 7, &___2039); switch (I1) { case 0: ___4677.setType(___4704);      break; case 1: ___4677.setType(___4696);    break; case 2: ___4677.setType(___4702);   break; case 3: ___4677.setType(___4700);       break; case 4: ___4677.setType(___4701);      break; case 5: ___4677.setType(___4695);      break; case 6: ___4677.setType(___4698);    break; case 7: ___4677.setType(___4699); break; default: { ___1175(___4218("Invalid datafile: unknown zone type.")); ___2039 = ___1303; } break; } if (pltFileVersion < 112) ___4677.___4647.___2026 = ((DataPacking_e)___1749<int32_t>(___1399, pltFileVersion, 0, 1, &___2039) == ___872); else ___4677.___4647.___2026 = ___4227; if (___1749<int32_t>(___1399, pltFileVersion, 0, 1, &___2039) != 0 && ___2039) { for (___4337 = 0; ___4337 < NumVars && ___2039; ___4337++) { if (___1749<int32_t>(___1399, pltFileVersion, 0, 1, &___2039) != 0 && ___2039 && ___2074 != NULL) { ___2039 = (___4677.___4647.___2026); if (___2039) ___2039 = ___17(___2074, ___4337, ___1303); else ___1175(___4218("Invalid datafile: cell centered " "variable must be in block format.", "See the Tecplot User's Manual for a definition of 'block format'")); } } } if (pltFileVersion >= 108 && ___2039) { *___2052 = ___1749<int32_t>(___1399, pltFileVersion, 0, 1, &___2039) != 0; if (*___2052 && (___4677.___4237 == ___4704 || ___4677.___4237 == ___4696)) { ___2039 = ___1303; ___1175(___4218("Invalid datafile: raw face neighbors may not be " "supplied for ordered or FE line segment zones.")); } } else *___2052 = ___1303; ___4677.___228 = !(*___2052); *___1439 = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); if (*___1439 != 0) ___4677.___1438 = (FaceNeighborMode_e)___1749<int32_t>(___1399, pltFileVersion, 0, 3, &___2039); if (pltFileVersion >= 108 && ___2039) { ___372 FaceNeighborsComplete = ___1303; if (*___1439 != 0 && ___4677.___4237 != ___4704) FaceNeighborsComplete = ___1749<int32_t>(___1399, pltFileVersion, 0, 1, &___2039) != 0; if (FaceNeighborsComplete) ___4677.___228 = ___1303; } ___2226 numIPts = 1; ___2226 numJPts = 1; ___2226 numKPts = 1; ___2226 ___2805 = 0; ___2226 numFaceBndryFaces = 0; ___2226 numFaceBndryItems = 0; if (___4677.___4237 == ___4704) { numIPts = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); numJPts = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); numKPts = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); if (___2039 && !(numIPts == 0 && numJPts == 0 && numKPts == 0)  && (numIPts == 0 || numJPts == 0 || numKPts == 0)) { ___1175(___4218("Invalid data file: incorrect specification of I, J, or K points for ordered data set."));
___2039 = ___1303; } } else { numIPts = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); if (___4677.___4237 == ___4698 || ___4677.___4237 == ___4699) { if (tecplotFileZoneFormat.has64BitFaceCounts()) numKPts = ___1749<int64_t>(___1399, pltFileVersion, 0, ___2182, &___2039); else numKPts = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); if (pltFileVersion >= 111) { if (tecplotFileZoneFormat.has64BitFaceCounts()) ___2805 = ___1749<int64_t>(___1399, pltFileVersion, 0, ___2182, &___2039); else ___2805 = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); numFaceBndryFaces = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); if (numFaceBndryFaces > 0) { ___476(pltFileVersion <= 191 && numFaceBndryFaces >= 2); numFaceBndryFaces -= 1; } numFaceBndryItems = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); } } else { if (___4677.___4237 == ___4704   || ___4677.___4237 == ___4698 || ___4677.___4237 == ___4699) { ___2039 = ___1303; } if (!___2039) ___1175(___4218("Invalid data file: invalid element type for FE data set.")); } numJPts = ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); ___476(pltFileVersion <= 191); ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); ___1749<int32_t>(___1399, pltFileVersion, 0, ___2181, &___2039); } if (___2039) { if (___4677.___4237 == ___4698 || ___4677.___4237 == ___4699) ___4677.assignMetrics(numIPts, numJPts, numKPts, ___2805, numFaceBndryFaces, numFaceBndryItems); else ___4677.assignMetrics(numIPts, numJPts, numKPts); } for (I1 = ___1749<int32_t>(___1399, pltFileVersion, 0, 1, &___2039); ___2039 && I1 != 0; I1 = ___1749<int32_t>(___1399, pltFileVersion, 0, 1, &___2039)) { if (___4677.___230 == NULL) ___4677.___230 = ___231(___263); ___2039 = (___4677.___230 != NULL); if (___2039) ___2039 = ___3286(___1399, pltFileVersion, ___4677.___230); } } if (pltFileVersion < 106 && ___2039) ConvertCommonTimeToSolutionTime(___4677); ENSURE(VALID_BOOLEAN(___2039)); return (___2039); } ___372 ___3287(___1403  *___1399, short          ___2103, ___372      ___2869, ___3840 *___789) { ___2226 NumLabels; short     ___1831; ___372 ___2039 = ___4227; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(___2103 > 0); REQUIRE(VALID_BOOLEAN(___2869)); REQUIRE(!(___2869) || VALID_REF(___789)); NumLabels = (short)___1749<int32_t>(___1399, ___2103, 0, ___2180, &___2039); if (___2039 && NumLabels != 0 && ___2869) { *___789 = ___3822(); ___2039 = (*___789 != NULL); if (!___2039) ___1175(___4218("Cannot allocate memory for Custom Labels.")); } for (___1831 = 0; ___2039 && (___1831 < NumLabels); ___1831++) { char *TLabel = NULL; ___2039 = ___3290(___1399, ___2103,
1024, &TLabel, ___2869); ___4226(TLabel); if (___2039 && ___2869) { ___2039 = ___3824(*___789, TLabel); if (TLabel != NULL) ___1528(TLabel, "custom label"); if (!___2039) ___1175(___4218("Cannot allocate memory for Custom Label.")); } } if (!___2039) ___1175(___4218("Invalid custom axis label record in binary datafile")); ENSURE(VALID_BOOLEAN(___2039)); ENSURE(!(___2039 && NumLabels != 0 && ___2869) || ___3849(*___789)); return ___2039; } ___372 ___3295( ___1403* ___1399, short         ___2103, char**        ___4286) { if (!___3290(___1399, ___2103, 0, ___4286, (___372)(___4286 != NULL))) { ___1175(___4218("Invalid USERREC record in binary datafile")); return (___1303); } return (___4227); } ___372 ___3286(___1403 *___1399, short         ___2103, ___264    ___230) { ___372 ___2039; ___372 DoCollectData; char      *AuxName  = NULL; ___2226 AuxValueType; char      *AuxValue = NULL; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(0 < ___2103 && ___2103 <= TecplotSDKBinaryFileVersion); REQUIRE(___230 == NULL || VALID_REF(___230)); DoCollectData = (___230 != NULL); ___2039 = ___3290(___1399, ___2103, ___2357, &AuxName, DoCollectData); if (___2039 && DoCollectData && !___249(AuxName)) { ___1175(___4218("Invalid auxiliary data name.")); ___2039 = ___1303; } if (___2039) { AuxValueType = ___1749<int32_t>(___1399, ___2103, 0, 0, &___2039); if (___2039 && (AuxValueType != (___2226)___270)) { ___1175(___4218("Unsupported auxiliary data type")); ___2039 = ___1303; } } if (___2039) ___2039 = ___3290(___1399, ___2103, ___2354, &AuxValue, DoCollectData); if (___2039 && DoCollectData) ___2039 = ___267(___230, AuxName, (___90)AuxValue, ___270, ___4227); if (AuxName != NULL) ___1528(AuxName, "data set auxiliary data item name"); if (AuxValue != NULL) ___1528(AuxValue, "data set auxiliary data item value"); ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } static void GetZoneAttachment(___1403 *___1399, short         ___2103, ___1170   *Z, ___372    *IsAttached, ___372    *___2039) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(Z)); REQUIRE(VALID_REF(IsAttached)); REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); if (___2103 >= 47) *Z = ___1749<int32_t>(___1399, ___2103, -1, ___2392, ___2039); else *Z = 0; if (___2103 < 70) (*Z)--; if (*Z == -1) { *Z          = 0; *IsAttached = ___1303; } else *IsAttached = ___4227; ENSURE(VALID_BOOLEAN(*IsAttached)); ENSURE(VALID_BOOLEAN(*___2039)); ENSURE(*Z >= 0); } static ___372 ReadMacroFunctionCommand(___1403  *___1399, short          ___2103, ___372      ___2869, char         **___2332) { ___372 ___3360 = ___1303; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(___2103 > 0); REQUIRE(VALID_BOOLEAN(___2869)); REQUIRE(VALID_REF(___2332));
___3360 = ___3290(___1399, ___2103, 0, ___2332, ___2869); ENSURE(VALID_BOOLEAN(___3360)); return (___3360); } ___372 ___3289(___1403 *___1399, short         ___2103, ___372     ___2869, ___1630       *___1554, ___2226     ___2367) { ___2226        ___1831; ___2226        S; FieldDataType_e  FFT; ___372        ___2039 = ___4227; ___4219 ErrMsgString = ___4218("Invalid geometry record"); REQUIRE(VALID_REF(___1554)); if (___2103 < 70) FFT = FieldDataType_Float; else FFT = FieldDataType_Double; if (___2103 < 101) ___1831 = ___1749<int32_t>(___1399, ___2103, 0, 1, &___2039); else ___1831 = ___1749<int32_t>(___1399, ___2103, 0, 4, &___2039); if (___1831 == 0) ___1554->___3168 = CoordSys_Grid; else if (___1831 == 1) ___1554->___3168 = CoordSys_Frame; else if (___1831 == 4) ___1554->___3168 = CoordSys_Grid3D; else { ErrMsgString = ___4218("Invalid geometry coordinate system"); ___2039 = ___1303; } ___1554->___3444 = (Scope_e)___1749<int32_t>(___1399, ___2103, 0, 1, &___2039); if (___2103 >= 102) ___1554->___1111 = (DrawOrder_e)___1749<int32_t>(___1399, ___2103, 0, 1, &___2039); ___1554->position.setXOrTheta(___1761(___1399, FFT, -___2178, ___2178, &___2039)); ___1554->position.setYOrR(___1761(___1399, FFT, -___2178, ___2178, &___2039)); if (___2103 >= 45) ___1554->position.setZ(___1761(___1399, FFT, -___2178, ___2178, &___2039)); else ___1554->position.setZ(0.0); GetZoneAttachment(___1399, ___2103, &___1554->___4600, &___1554->___227, &___2039); ___1554->___351 = ___1749<int32_t>(___1399, ___2103, 0, 255, &___2039); AdjustCustomColor(___2103, &___1554->___351); if (___2103 > 47) { ___1554->___1408 = ___1749<int32_t>(___1399, ___2103, 0, 255, &___2039); ___1554->___2022  = ___1749<int32_t>(___1399, ___2103, 0, 1, &___2039) != 0; AdjustCustomColor(___2103, &___1554->___1408); } else { ___1554->___1408 = ___1554->___351; ___1554->___2022  = ___1303; } if (___2103 < 101) { ___1554->___1651 = (GeomType_e)___1749<int32_t>(___1399, ___2103, 0, 5, &___2039); if (___1554->___1651 == GeomType_LineSegs3D) { ___1554->___1651         = GeomType_LineSegs; ___1554->___3168 = CoordSys_Grid3D; } } else { ___1554->___1651 = (GeomType_e)___1749<int32_t>(___1399, ___2103, 0, 4, &___2039); } if (___1554->___3168 == CoordSys_Grid3D && ___1554->___1651 != GeomType_LineSegs) { ErrMsgString = ___4218("Mismatch between geometry coordinate system and geometry type"); ___2039 = ___1303; } if (___2103 > 41) { ___1554->___2265 = (LinePattern_e)___1749<int32_t>(___1399, ___2103, 0, ___2267, &___2039); } else { ___1554->___2265  = (LinePattern_e)((int)___1554->___1651 % 2); ___1554->___1651     = (GeomType_e)((int)___1554->___1651 / 10); } if ((___2103 < 49) && ((short)(___1554->___1651) == 2)) { ___1554->___1651 = GeomType_Rectangle; ___1554->___2022 = ___4227; } if ((___2103 < 70) && ((short)(___1554->___1651) > 1)) ___1554->___1651 = (GeomType_e)((short)___1554->___1651 + 1); ___3356(&___1554->___2332, NULL, ___4227);
___1554->___1889 = ___1899; if (___2103 >= 70) { ___1554->___2988       = ___1761(___1399, FFT, PatternLengthInputSpec.___2471, PatternLengthInputSpec.___2347, &___2039); ___1554->___2291       = ___1761(___1399, FFT, LineThicknessInputSpec.___2471, LineThicknessInputSpec.___2347, &___2039); ___1554->___2795       = ___1749<int32_t>(___1399, ___2103, 2, ___2385, &___2039); ___1554->___188      = (ArrowheadStyle_e)___1749<int32_t>(___1399, ___2103, 0, ___190, &___2039); ___1554->___176 = (ArrowheadAttachment_e)___1749<int32_t>(___1399, ___2103, 0, ___178, &___2039); ___1554->___187  = ___1761(___1399, FFT, ArrowheadSizeInputSpec.___2471, ArrowheadSizeInputSpec.___2347, &___2039); ___1554->___171 = ___1761(___1399, FFT, ArrowheadAngleInputSpec.___2471, ArrowheadAngleInputSpec.___2347, &___2039); if (___2103 >= 75) { ___2039 = ReadMacroFunctionCommand(___1399, ___2103, ___2869, &___1554->___2332); } } else { ___1554->___2291        = 0.001; ___1554->___2988        = 0.02; ___1554->___188       = ___192; ___1554->___176  = ___181; ___1554->___187        = 0.05; ___1554->___171       = 12.0 / ___952; } if (___2103 < 41) { ___1761(___1399, FieldDataType_Float, -___2178, ___2178, &___2039); ___1761(___1399, FieldDataType_Float, -___2178, ___2178, &___2039); ___1761(___1399, FieldDataType_Float, -___2178, ___2178, &___2039); } if (___2103 < 70) ___1554->___905 = FieldDataType_Float; else ___1554->___905 = (FieldDataType_e)___1749<int32_t>(___1399, ___2103, 1, 2, &___2039); ___476(VALID_GEOM_FIELD_DATA_TYPE(___1554->___905)); ___1554->___494 = ___496; if (___2103 >= 101) { ___1554->___494 = (Clipping_e)___1749<int32_t>(___1399, ___2103, 0, 2, &___2039); if (___1554->___494 == (Clipping_e)2) ___1554->___494 = ___495; } if (___2103 < 50 || ___1554->___1651 == GeomType_LineSegs) { ___1554->___2837 = ___1749<int32_t>(___1399, ___2103, 1, ___2372, &___2039); S = -1; ___1831 = 0; while ((S + 1 < ___1554->___2837) && !feof(___1399->File) && ___2039) { S++; ___1554->___2839[S] = ___1749<int32_t>(___1399, ___2103, 1, ___2181, &___2039); if ((___1831 + ___1554->___2839[S] > ___2367) && ___2869) { ErrMsgString = ___4218("Geometry is too big"); ___2039 = ___1303; } else { ___3277(___1399, ___1554->___1571.___1546.___4294, ___2869, ___1554->___905, ___1831, ___1831 + ___1554->___2839[S] - 1, &___2039); ___3277(___1399, ___1554->___1571.___1546.___4296, ___2869, ___1554->___905, ___1831, ___1831 + ___1554->___2839[S] - 1, &___2039); if (GEOM_USES_V3(___1554)) ___3277(___1399, ___1554->___1571.___1546.___4298, ___2869, ___1554->___905, ___1831, ___1831 + ___1554->___2839[S] - 1, &___2039); ___1831 += ___1554->___2839[S]; } } if (___2039 && (___1554->___1651 == GeomType_Rectangle)) { if (___2869) { ___673(___1554->___1571.___1546.___4294, 0, ___1554->___1571.___1546.___4294, 2);
___673(___1554->___1571.___1546.___4296, 0, ___1554->___1571.___1546.___4296, 2); } } } else if (___1554->___1651 == GeomType_Rectangle || ___1554->___1651 == GeomType_Ellipse) { double XX, YY; XX = ___1761(___1399, ___1554->___905, -___2178, ___2178, &___2039); YY = ___1761(___1399, ___1554->___905, -___2178, ___2178, &___2039); if (___2869) { ___3491(___1554->___1571.___4580.___4569, 0, XX); ___3491(___1554->___1571.___4580.___4586, 0, YY); } ___1554->___2837 = 1; ___1554->___2839[0]   = 1; } else { double XX; ___476((___1554->___1651 == GeomType_Square) || (___1554->___1651 == GeomType_Circle)); XX = ___1761(___1399, ___1554->___905, -___2178, ___2178, &___2039); if (___2869) { ___3491(___1554->___1571.___4580.___4569, 0, XX); } ___1554->___2837  = 1; ___1554->___2839[0] = 1; } if (!___2039) ___1175(ErrMsgString); return (___2039); } ___372 ___3294(___1403 *___1399, short         ___2103, ___372     ___2869, ___4119       *Text, ___2226     ___2388) { ___2226        ___1831; FieldDataType_e  FFT; int32_t      TextLength = 0; ___372        ___2039 = ___4227; ___4219 ErrMsgString = ___4218("Invalid text record"); REQUIRE(VALID_REF(Text)); if (___2103 < 70) FFT = FieldDataType_Float; else FFT = FieldDataType_Double; if (___2103 < 101) ___1831 = ___1749<int32_t>(___1399, ___2103, 0, 1, &___2039); else ___1831 = ___1749<int32_t>(___1399, ___2103, 0, 4, &___2039); if (___1831 == 0) Text->___3168 = CoordSys_Grid; else if (___1831 == 1) Text->___3168 = CoordSys_Frame; else if (___1831 == 4) Text->___3168 = CoordSys_Grid3D; else { ErrMsgString = ___4218("Invalid text coordinate system."); ___2039 = ___1303; } Text->___3444   = (Scope_e)___1749<int32_t>(___1399, ___2103, 0, 1, &___2039); Text->___52.___1546.___4293 = ___1761(___1399, FFT, -___2178, ___2178, &___2039); Text->___52.___1546.___4295 = ___1761(___1399, FFT, -___2178, ___2178, &___2039); if (___2103 >= 101) Text->___52.___1546.___4297 = ___1761(___1399, FFT, -___2178, ___2178, &___2039); else Text->___52.___1546.___4297 = 0.0; if (___2103 > 40) { Text->___4122.___1442 = (Font_e)___1749<int32_t>(___1399, ___2103, 0, ___1444, &___2039); } else { Text->___4122.___1442 = ___1452; } if (___2103 < 43) ___1761(___1399, FFT, -___2178, ___2178, &___2039); if (___2103 < 70) { if (Text->___3168 == CoordSys_Grid) Text->___4122.___3602 = ___4270; else Text->___4122.___3602 = ___4269; } else Text->___4122.___3602 = (Units_e)___1749<int32_t>(___1399, ___2103, 0, ___4272, &___2039); Text->___4122.___1826 = ___1761(___1399, FFT, -___2178, ___2178, &___2039); if (___2103 > 47) { Text->___401.___411 = (TextBox_e)___1749<int32_t>(___1399, ___2103, 0, ___4070, &___2039); if (___2103 < 70) { if (Text->___401.___411 == ___4070) Text->___401.___411 = ___4064; else if (Text->___401.___411 == ___4064) Text->___401.___411 = ___4070;
} Text->___401.___2339     = ___1761(___1399, FFT, TextBoxMarginInputSpec.___2471, TextBoxMarginInputSpec.___2347, &___2039); if (___2103 >= 70) Text->___401.___2291 = ___1761(___1399, FFT, LineThicknessInputSpec.___2471, LineThicknessInputSpec.___2347, &___2039); else Text->___401.___2291 = 0.01; Text->___401.___351     = ___1749<int32_t>(___1399, ___2103, 0, 255, &___2039); Text->___401.___1408 = ___1749<int32_t>(___1399, ___2103, 0, 255, &___2039); AdjustCustomColor(___2103, &Text->___401.___351); AdjustCustomColor(___2103, &Text->___401.___1408); } else { Text->___401.___411    = ___4076; Text->___401.___2339     = 0.0; Text->___401.___351     = ___4455; Text->___401.___1408 = ___364; } if (___2103 < 70) { Text->___57       = ___1749<int32_t>(___1399, ___2103, -720, 720, &___2039) / ___952; Text->___2289 = 1; Text->___39      = ___4051; } else { Text->___57       = ___1761(___1399, FFT, TextAngleInputSpec.___2471, TextAngleInputSpec.___2347, &___2039); Text->___2289 = ___1761(___1399, FFT, TextLineSpacingInputSpec.___2471, TextLineSpacingInputSpec.___2347, &___2039); Text->___39      = (TextAnchor_e)___1749<int32_t>(___1399, ___2103, 0, ___4049, &___2039); } GetZoneAttachment(___1399, ___2103, &Text->___4600, &Text->___227, &___2039); Text->___351   = ___1749<int32_t>(___1399, ___2103, 0, 255, &___2039); AdjustCustomColor(___2103, &Text->___351); if (___2103 < 70) TextLength = (short)___1749<int32_t>(___1399, ___2103, 0, 5000, &___2039); Text->___2332.clear(); Text->___494 = ___496; if (___2103 < 70) { try { for (short i = 0; i < TextLength; i++) { short s = (short)___1749<int32_t>(___1399, ___2103, 0, 1000, &___2039); if (___2869 && (i <= ___2388)) Text->Text.push_back((char)s); } } catch (std::bad_alloc const&) { ErrMsgString = ___4218("Insufficient memory available"); ___2039 = ___1303; } } else { char *S = NULL; if (___2103 >= 75) ___2039 = ___3290(___1399, ___2103, 0, &Text->___2332, ___2869); if (___2103 >= 101) { Text->___494 = (Clipping_e)___1749<int32_t>(___1399, ___2103, 0, 2, &___2039); if (Text->___494 == (Clipping_e)2) Text->___494 = ___495; } if (___3290(___1399, ___2103, ___2388, &S, ___2869)) { if (S) { if (___2039) { try { Text->Text = S; } catch (std::bad_alloc const&) { ErrMsgString = ___4218("Insufficient memory available"); ___2039 = ___1303; } } ___1528(S, "Release temp string for new text label"); } else if (___2869) { Text->Text.clear(); } } else { ___2039 = ___1303; } } if (!___2039) ___1175(ErrMsgString); return (___2039); } static ___372 CompareVersion(float      ___4408, char      *VersionString, ___372  ___2006) { char *VersionBuf = (char *) & ___4408; REQUIRE(VALID_REF(VersionString)); if (___2006) return ((VersionString[0] == VersionBuf[0]) && (VersionString[1] == VersionBuf[1]) && (VersionString[2] == VersionBuf[2]) && (VersionString[3] == VersionBuf[3]));
else return ((VersionString[3] == VersionBuf[0]) && (VersionString[2] == VersionBuf[1]) && (VersionString[1] == VersionBuf[2]) && (VersionString[0] == VersionBuf[3])); } static float ValidVersions[] = {7.0F, 6.3F, 6.2F, 6.1F, 6.0F, 5.0F, 4.7F, 4.6F, 4.5F, 4.4F, 4.3F, 4.2F, 4.1F, 4.0F };
 #define NUMVALIDVERSIONS ((int)(sizeof(ValidVersions)/sizeof(ValidVersions[0])))
static ___372 GetDoubleVersion(char      *VersionString, float     *FInputVersion, ___372  ___2006) { int  ___1831; REQUIRE(VALID_REF(FInputVersion)); for (___1831 = 0; ___1831 < NUMVALIDVERSIONS; ___1831++) if (CompareVersion(ValidVersions[___1831], VersionString, ___2006)) { *FInputVersion = ValidVersions[___1831]; return (___4227); } return (___1303); } static short GetNewInputVersion(___1403 *___1399) { char       Buf[4] = { 0, 0, 0, 0 }; short      ___2103 = 0; short      ___1831; ___2226  OneValue; ___372  ___2039 = ___4227; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(___1399->___2006); if (___4199(Buf, 4, 1, ___1399->File) != 1) return (0); if (strncmp(Buf, "#!TD", 4)) return (0); if (___4199(Buf, 4, 1, ___1399->File) != 1) return (0); if (Buf[0] != 'V') return (0); ___1831 = 1; while ((___1831 < 4) && tecplot::___2011(Buf[___1831])) ___2103 = ___2103 * 10 + Buf[___1831++] - '0'; if (___2103 < 70) return (0); else if (___2103 > TecplotSDKBinaryFileVersion) { ___1175(___4218("Binary file version newer than Tecplot version. " "Upgrade Tecplot or use an older Preplot to produce " "the datafile.")); return (___2103); } OneValue = ___1749<int32_t>(___1399, ___2103, -___2181, ___2181, &___2039); if (!___2039) return (0); ___1399->___2006 = (OneValue == 1); return (___2103); } short ___1748(___1403 *___1399) { ___372    ___2039 = ___4227; float        FInputVersion; short        ___2103; char         VersionString[4]; ___1396 ___3687 = 0; ___3687 = ___4202(___1399->File); ___2103 = GetNewInputVersion(___1399); if (___2103 > TecplotSDKBinaryFileVersion) return ___2103; else if (___2103 == 0) { rewind(___1399->File); ___2039 = (___4201(___1399->File, ___3687, SEEK_SET) == 0); if (___2039 && ___4199(VersionString, 4, 1, ___1399->File) == 1) { if (!GetDoubleVersion(VersionString, &FInputVersion, ___1399->___2006)) { ___1399->___2006 = !___1399->___2006; ___2039 = GetDoubleVersion(VersionString, &FInputVersion, ___1399->___2006); } if (___2039) ___2103 = ___3423(FInputVersion * 10); } } if (___2039) return (___2103); else return ((short)0); } ___372 ___4486( ___1403*  ___1399, uint8_t const* ___428, ___2226      ___2843) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___428)); REQUIRE(___2843 >= 0); ___372 ___2039 = ___4203(___428, sizeof(uint8_t), (size_t)___2843, ___1399->File) == (size_t)___2843; ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } static inline ___372 WriteBinaryByte(___1403 *___1399, uint8_t        ByteValue) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); ___372 ___2039 = ___4486(___1399, &ByteValue, 1); ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } template <typename T> void CopyAndReverseUnalignedBytes(T            *___1121, const uint8_t *___3659) { REQUIRE(VALID_REF(___1121));
REQUIRE(VALID_REF(___3659)); size_t typeSize = sizeof(T); for (size_t ___1840 = 0; ___1840 < typeSize; ___1840++) ((uint8_t *)(___1121))[___1840] = ((uint8_t *)(___3659))[typeSize-1-___1840]; } template <typename T> void CopyUnalignedBytes(T            *___1121, const uint8_t *___3659) { REQUIRE(VALID_REF(___1121)); REQUIRE(VALID_REF(___3659)); for (size_t ___1840 = 0; ___1840 < sizeof(T); ___1840++) ((uint8_t *)(___1121))[___1840] = ((uint8_t *)(___3659))[___1840]; } template <typename T> ___372 WriteBinaryDataUnaligned(___1403    *___1399, const uint8_t    *ValueBuffer, const ___372  ValueInNativeOrder) { REQUIRE(VALID_REF(___1399) && VALID_FILE_HANDLE(___1399->File)); REQUIRE(VALID_REF(ValueBuffer)); REQUIRE(VALID_BOOLEAN(ValueInNativeOrder)); T DataValue; if (ValueInNativeOrder != ___1399->___2006) CopyAndReverseUnalignedBytes<T>(&DataValue, ValueBuffer); else CopyUnalignedBytes<T>(&DataValue, ValueBuffer); ___372 ___2039 = ___4203(&DataValue, sizeof(T), 1, ___1399->File) == 1; ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 ___4488(___1403 *___1399, int16_t       ___4315) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE("Value can be any int16_t"); return WriteBinaryDataUnaligned<int16_t>(___1399, (uint8_t *) & ___4315, ___4227 ); } ___372 ___4490(___1403 *___1399, int32_t       ___4315) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); return WriteBinaryDataUnaligned<int32_t>(___1399, (uint8_t *) & ___4315, ___4227 ); } ___372 WriteBinaryInt64(___1403 *___1399, int64_t       ___4315) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE("Value can be any int64_t"); return WriteBinaryDataUnaligned<int64_t>(___1399, (uint8_t *) & ___4315, ___4227 ); } template <typename T> ___372 WriteBinaryBlockUnaligned(___1403    *___1399, const uint8_t    *___4332, const ___2226  ___2843, const ___372  ___4333) { ___372 ___2039 = ___4227; ___372 WriteEachValueSeparately; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___4332)); REQUIRE(___2843 >= 0); REQUIRE(VALID_BOOLEAN(___4333)); WriteEachValueSeparately = (___4333 != ___1399->___2006); if (WriteEachValueSeparately) { for (___2226 NIndex = 0; ___2039 && NIndex < ___2843; NIndex++) { ___2039 = WriteBinaryDataUnaligned<T>(___1399, ___4332 + NIndex * sizeof(T), ___4333); } } else {
 #if 1
size_t NumBytesToWrite = ___2843 * sizeof(T); size_t NumBytesWritten = ___4203(___4332, sizeof(uint8_t), NumBytesToWrite, ___1399->File); ___2039 = NumBytesToWrite == NumBytesWritten;
 #else
___2039 = ___4486(___1399, ___4332, ___2843 * sizeof(T));
 #endif
} ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 ___4489( ___1403*  ___1399, uint8_t const* ___1962, ___2226      ___2843, ___372      ___4333) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___1962)); REQUIRE(___2843 >= 0); REQUIRE(VALID_BOOLEAN(___4333)); ___372 ___2039 = WriteBinaryBlockUnaligned<int16_t>(___1399, ___1962, ___2843, ___4333); ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 ___4491( ___1403*  ___1399, uint8_t const* ___1967, ___2226      ___2843, ___372      ___4333) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___1967)); REQUIRE(___2843 >= 0); REQUIRE(VALID_BOOLEAN(___4333)); ___372 ___2039 = WriteBinaryBlockUnaligned<int32_t>(___1399, ___1967, ___2843, ___4333); ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 WriteBinaryInt64BlockUnaligned( ___1403*  ___1399, uint8_t const* Int64Values, ___2226      ___2843, ___372      ___4333) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(Int64Values)); REQUIRE(___2843 >= 0); REQUIRE(VALID_BOOLEAN(___4333)); ___372 ___2039 = WriteBinaryBlockUnaligned<int64_t>(___1399, Int64Values, ___2843, ___4333); ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 ___4493(___1403    *___1399, double           ___3426, FieldDataType_e  ___1362) { ___372 ___2039 = ___1303; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE((___1362 == FieldDataType_Float)  || (___1362 == FieldDataType_Double) || (___1362 == FieldDataType_Byte)); switch (___1362) { case FieldDataType_Float : { float FloatVal = ___648(___3426); ___2039 = WriteBinaryDataUnaligned<float>(___1399, (uint8_t *) & FloatVal, ___4227 ); } break; case FieldDataType_Double : { double DoubleVal = ___487(___3426); ___2039 = WriteBinaryDataUnaligned<double>(___1399, (uint8_t *) & DoubleVal, ___4227 ); } break; case FieldDataType_Byte : { uint8_t B; if (___3426 > 255) B = 255; else if (___3426 < 0) B = 0; else B = (uint8_t)___3426; ___2039 = WriteBinaryByte(___1399, B); } break; default: ___476(___1303); break; } ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 ___4513(___1403    *___1399, FieldDataType_e  ___1308, ___372        ___4485) { if (___4485) return (___4490(___1399, (___2226)___1308)); else { int32_t S = 0; switch (___1308) { case FieldDataType_Float :  S = fprintf(___1399->File, "SINGLE "); break; case FieldDataType_Double : S = fprintf(___1399->File, "DOUBLE "); break; case FieldDataType_Int32 :  S = fprintf(___1399->File, "LONGINT "); break; case FieldDataType_Int16 :  S = fprintf(___1399->File, "SHORTINT "); break; case FieldDataType_Byte :   S = fprintf(___1399->File, "BYTE "); break;
case ___1363 :    S = fprintf(___1399->File, "BIT "); break; default: ___476(___1303); } return (___1480(S)); } } template <typename T> ___372 WriteBinaryByteValues( ___1403*  ___1399, uint8_t const* ___428, ___2226      ___2843 ) { REQUIRE(VALID_REF(___1399) && VALID_FILE_HANDLE(___1399->File)); REQUIRE(VALID_REF(___428)); REQUIRE(___2843 >= 1); ___372 ___2039; if (___2843 == 1) ___2039 = WriteBinaryDataUnaligned<T>(___1399, ___428, ___4227); else ___2039 = WriteBinaryBlockUnaligned<T>(___1399, ___428, ___2843, ___4227); ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } template <typename T> ___372 WriteBinaryFieldDataBlockOfType( ___1403* ___1399, ___1359  ___1350, ___2226     ___3687, ___2226     ___2843) { ___372 ___2039 = ___1303; if (___2018(___1350)) { uint8_t *ByteArray = ___1680(___1350) + ___3687 * sizeof(T); ___2039 = WriteBinaryByteValues<T>( ___1399, ByteArray, (___2226)___2843 ); } else { for (___2226 ___2867 = ___3687; ___2867 < ___2843; ___2867++) { T ValueBuffer = (T)___1734(___1350, ___2867); uint8_t* ByteValue = (uint8_t *) & ValueBuffer; ___2039 = WriteBinaryByteValues<T>( ___1399, ByteValue, 1 ); } } ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } static ___372 WriteBinaryFieldDataBlockOfTypeBit( ___1403* ___1399, ___1359  ___1350, ___2226     ___3687, ___2226     ___2843) { ___4279(___3687); ___372 ___2039 = ___1303; size_t NumBytes = 1 + (___2843 - 1) / 8; if (___2018(___1350)) { uint8_t *ByteArray = ___1680(___1350); ___2039 = WriteBinaryByteValues<uint8_t>( ___1399, ByteArray, (___2226)NumBytes ); } else { for (___2226 ___2867 = 0; ___2867 < ___2843; ___2867 += 8) { uint8_t ValueBuffer = 0; for (int ___1840 = 0; ___1840 < 8; ___1840++) { uint8_t CurBit = (uint8_t)___1734(___1350, ___2867 + ___1840); ValueBuffer |= (CurBit << ___1840); } ___2039 = WriteBinaryByteValues<uint8_t>( ___1399, &ValueBuffer, 1 ); } } ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 ___4487( ___1403* ___1399, ___1359  ___1350, ___2226     ___3687, ___2226     ___2843) { ___372 ___2039 = ___1303; switch (___1725(___1350)) { case FieldDataType_Float  : ___2039 = WriteBinaryFieldDataBlockOfType<float>(___1399, ___1350, ___3687, ___2843); break; case FieldDataType_Double : ___2039 = WriteBinaryFieldDataBlockOfType<double>(___1399, ___1350, ___3687, ___2843); break; case FieldDataType_Int32  : ___2039 = WriteBinaryFieldDataBlockOfType<int32_t>(___1399, ___1350, ___3687, ___2843); break; case FieldDataType_Int16  : ___2039 = WriteBinaryFieldDataBlockOfType<int16_t>(___1399, ___1350, ___3687, ___2843); break; case FieldDataType_Byte   : ___2039 = WriteBinaryFieldDataBlockOfType<uint8_t>(___1399, ___1350, ___3687, ___2843); break; case ___1363    : ___2039 = WriteBinaryFieldDataBlockOfTypeBit(___1399, ___1350, ___3687, ___2843); break;
default: ___476(___1303); break; } ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } static ___372 WriteASCIIFieldDataValue( ___1403* ___1399, ___1359  ___1350, ___2226     ___2867, int32_t       ___200) { double V = ___1734(___1350, ___2867); char ___416[100*MAX_SIZEOFUTF8CHAR]; switch (___1725(___1350)) { case FieldDataType_Float : case FieldDataType_Double : sprintf(___416, " %.*E", (int)___200, V); break; case FieldDataType_Int32 : sprintf(___416, " %*d", (int)___200, ROUND32(V)); break; case FieldDataType_Int16 : sprintf(___416, " %6d", ___3421(V)); break; case FieldDataType_Byte : sprintf(___416, " %3d", ___3423(V)); break; case ___1363 : sprintf(___416, " %c", ((V == 0) ? '0' : '1')); break; default: ___476(___1303); break; } ___372 ___2039 = ___1480(fprintf(___1399->File, "%s", ___416)); ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 ___4495(___1403 *___1399, ___1359  ___1350, ___372     ___2042, ___2226     ___2810, ___2226     ___2815, ___2226     ___2818, ___372     ___4485, int32_t   ___200) { ___372 ___2039 = ___4227; ___2226 ___2843; ___2226 ___1831, ___2105, ___2134; ___2226 ___2808 = -1; ___2226 ___1838     = -1; ___2226 ___2110     = -1; ___2226 ___2138     = -1; ___372 IsLinear = -1; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___1350)); REQUIRE(VALID_BOOLEAN(___2042)); REQUIRE(___2810 >= 0); REQUIRE(___2815 >= 0); REQUIRE(___2818 >= 0); REQUIRE(VALID_BOOLEAN(___4485)); REQUIRE(IMPLICATION(!___4485, ___200 >= 0)); if (___2042 && !___4485) { ___2808  = ___2810 * ___2815; ___1838      = MAX(___2810 - 1, 1); ___2110      = MAX(___2815 - 1, 1); ___2138      = MAX(___2818 - 1, 1); ___2843 = (___1838 * ___2110 * ___2138); IsLinear  = ((___2815 == 1 && ___2818 == 1) || (___2810 == 1 && ___2818 == 1) || (___2810 == 1 && ___2815 == 1)); } else { ___2843 = ___1716(___1350); } if (___4485) { ___2039 = ___4487(___1399, ___1350, 0, ___2843); } else { ___2226 NumValuesPerLine = 80 / (___200 + 5); if (___2042 && !IsLinear) { ___2226 ValueIndex = 0; for (___2134 = 0; ___2134 < ___2138 && ___2039; ___2134++) for (___2105 = 0; ___2105 < ___2110 && ___2039; ___2105++) for (___1831 = 0; ___1831 < ___1838 && ___2039; ___1831++) { ___2226 ___461 = ___1831 + (___2105 * ___2810) + (___2134 * ___2808); ___2039 = WriteASCIIFieldDataValue(___1399, ___1350, ___461, ___200); if ((ValueIndex + 1) % NumValuesPerLine == 0 || ValueIndex == ___2843 - 1) ___2039 = (fputc('\n', ___1399->File) != EOF); ValueIndex++; } } else { for (___1831 = 0; ___1831 < ___2843 && ___2039; ___1831++) { ___2039 = WriteASCIIFieldDataValue(___1399, ___1350, ___1831, ___200); if ((___1831 + 1) % NumValuesPerLine == 0 || ___1831 == ___2843 - 1) ___2039 = (fputc('\n', ___1399->File) != EOF); } } } ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 ___1129(___1403 *___1399, const char   *S, ___372     ___4485) { ___372 ___2039 = ___4227;
if (___4485) { const char *___683 = S; while (___2039 && ___683 && *___683) ___2039 = ___4490(___1399, (___2226)(unsigned char) * ___683++); if (___2039) ___2039 = ___4490(___1399, 0); } else { const char *___683 = S; fputc('"', ___1399->File); while (___683 && *___683) { if (*___683 == '\n') { ___683++; fputc('\\', ___1399->File); fputc('\\', ___1399->File); fputc('n', ___1399->File); } else { if ((*___683 == '"') || (*___683 == '\\')) fputc('\\', ___1399->File); fputc(*___683++, ___1399->File); } } fputc('"', ___1399->File); ___2039 = (fputc('\n', ___1399->File) != EOF); } return (___2039); } static void WriteAsciiColor(FILE        *File, ___514 Color) { if (Color >= ___1420 && Color <= ___2195) fprintf(File, "CUST%1d ", Color - ___1420 + 1); else { switch (Color) { case ___364  : fprintf(File, "BLACK "); break; case ___3302    : fprintf(File, "RED "); break; case ___1809  : fprintf(File, "GREEN "); break; case ___366   : fprintf(File, "BLUE "); break; case ___797   : fprintf(File, "CYAN "); break; case ___4587 : fprintf(File, "YELLOW "); break; case ___3257 : fprintf(File, "PURPLE "); break; case ___4455  : fprintf(File, "WHITE "); break; } } } static void WriteAsciiTextGeomBasics(FILE*              File, CoordSys_e         CoordSys, ___372          ___227, ___1170         ___4600, ___514       Color, Scope_e            ___3444, ___372          IncludeZ, ___372          ___4525, ___54 const* ___52, double             ___3435) { REQUIRE(VALID_REF(File)); REQUIRE(VALID_TEXT_COORDSYS(CoordSys) || VALID_GEOM_COORDSYS(CoordSys)); REQUIRE(VALID_BOOLEAN(___227)); REQUIRE(IMPLICATION(___227, ___4600 >= 0)); REQUIRE(VALID_ENUM(___3444, Scope_e)); REQUIRE(VALID_BOOLEAN(IncludeZ)); REQUIRE(VALID_BOOLEAN(___4525)); fprintf(File, "CS="); if (CoordSys == CoordSys_Frame) { fprintf(File, "FRAME"); } else if (CoordSys == CoordSys_Grid) { fprintf(File, "GRID"); } else if (CoordSys == CoordSys_Grid3D) { fprintf(File, "GRID3D"); }
 #if 0 
else if (CoordSys == ___659) { fprintf(File,"FRAMEOFFSET"); }
 #endif
else { ___476(___1303); } if (CoordSys == CoordSys_Grid && !IncludeZ && ___4525) { fprintf(File, "\nTHETA=%.12G,R=%.12G", ___3435*___52->___4148.___4142, ___3435*___52->___4148.___3266); ___476(!IncludeZ); } else { fprintf(File, "\nX=%.12G,Y=%.12G", ___3435*___52->___4580.X, ___3435*___52->___4580.Y); if (IncludeZ) fprintf(File, ",Z=%.12G", ___3435*___52->___4580.Z); } if (___227) fprintf(File, "\nZN=%d", ___4600 + 1); fprintf(File, "\nC="); WriteAsciiColor(File, Color); fprintf(File, "\nS="); if (___3444 == ___3445) { fprintf(File, "GLOBAL"); } else { ___476(___3444 == ___3447); fprintf(File, "LOCAL"); } fputc('\n', File); } bool ___1130(___1403* ___1399, ___1630 const* ___1554, ___372     ___4485, ___372     ___4525) { ___2226       ___1831, ___1925; ___2226       SegIndex; bool            ___2039 = ___4227; FieldDataType_e ___1308; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___1554)); REQUIRE(___1554->___1651 != GeomType_Image); if (___4485) { ___4493(___1399, ___1615, FieldDataType_Float); if (___1554->___3168 == CoordSys_Grid) { ___4490(___1399, 0); } else if (___1554->___3168 == CoordSys_Frame) { ___4490(___1399, 1); } else if (___1554->___3168 == CoordSys_Grid3D) { ___4490(___1399, 4); }
 #if 0 
else if (___1554->___3168 == ___659) { ___4490(___1399, 2); }
 #endif
else { ___476(___1303); } ___4490(___1399, (___2226)___1554->___3444); ___4490(___1399, (___2226)___1554->___1111); ___4493(___1399, ___1554->position.XOrTheta(), FieldDataType_Double); ___4493(___1399, ___1554->position.YOrR(), FieldDataType_Double); ___4493(___1399, ___1554->position.Z(), FieldDataType_Double); if (___1554->___227) ___4490(___1399, (___2226)___1554->___4600); else ___4490(___1399, (___2226) - 1); ___4490(___1399, (___2226)___1554->___351); ___4490(___1399, (___2226)___1554->___1408); ___4490(___1399, (___2226)___1554->___2022); ___476(___1554->___1651 != GeomType_LineSegs3D); ___4490(___1399, (___2226)___1554->___1651); ___4490(___1399, (___2226)___1554->___2265); ___4493(___1399, ___1554->___2988, FieldDataType_Double); ___4493(___1399, ___1554->___2291, FieldDataType_Double); ___4490(___1399, (___2226)___1554->___2795); ___4490(___1399, (___2226)___1554->___188); ___4490(___1399, (___2226)___1554->___176); ___4493(___1399, ___1554->___187, FieldDataType_Double); ___4493(___1399, ___1554->___171, FieldDataType_Double); ___1129(___1399, ___1554->___2332, ___4227); ___1308 = ___1746(___1554); ___4513(___1399, ___1308, ___4227); ___4490(___1399, (___2226)___1554->___494); if (___1554->___1651 == GeomType_LineSegs) { short S; ___4490(___1399, ___1554->___2837); ___1831 = 0; for (S = 0; ___2039 && (S < ___1554->___2837); S++) { ___4490(___1399, ___1554->___2839[S]); ___4487(___1399, ___1554->___1571.___1546.___4294, ___1831, ___1554->___2839[S]); ___2039 = ___4487(___1399, ___1554->___1571.___1546.___4296, ___1831, ___1554->___2839[S]) == ___4227; if (GEOM_USES_V3(___1554)) ___2039 = ___4487(___1399, ___1554->___1571.___1546.___4298, ___1831, ___1554->___2839[S]) == ___4227; ___1831 += ___1554->___2839[S]; } } else if (___1554->___1651 == GeomType_Rectangle || ___1554->___1651 == GeomType_Ellipse) { ___4493(___1399, ___1734(___1554->___1571.___4580.___4569, 0), ___1308); ___2039 = ___4493(___1399, ___1734(___1554->___1571.___4580.___4586, 0), ___1308) == ___4227; } else { ___476((___1554->___1651 == GeomType_Square) || (___1554->___1651 == GeomType_Circle)); ___2039 = ___4493(___1399, ___1734(___1554->___1571.___4580.___4569, 0), ___1308) == ___4227; } } else { double ___3435; if (___1554->___3168 == CoordSys_Frame) ___3435 = 100.0; else ___3435 = 1.0; fprintf(___1399->File, "GEOMETRY\nF=POINT\n"); ___54 const positon = ___1554->position.anchorPosition(); WriteAsciiTextGeomBasics(___1399->File, ___1554->___3168, ___1554->___227, ___1554->___4600, ___1554->___351, ___1554->___3444, ___4227, ___4525, &positon, ___3435); switch (___1554->___2265) { case ___2272      : fprintf(___1399->File, "L=SOLID\n"); break;
case ___2268     : fprintf(___1399->File, "L=DASHED\n"); break; case ___2266    : fprintf(___1399->File, "L=DASHDOT\n"); break; case ___2269     : fprintf(___1399->File, "L=DOTTED\n"); break; case ___2271   : fprintf(___1399->File, "L=LONGDASH\n"); break; case ___2267 : fprintf(___1399->File, "L=DASHDOTDOT\n"); break; default: ___476(___1303); break; } fprintf(___1399->File, "PL=%.12G\n", ___1554->___2988*PatternLengthInputSpec.___1977.___3435); fprintf(___1399->File, "LT=%.12G\n", ___1554->___2291*LineThicknessInputSpec.___1977.___3435); if (___1554->___2022) { fprintf(___1399->File, "FC="); WriteAsciiColor(___1399->File, ___1554->___1408); } if (___1554->___494 == ___496) { fprintf(___1399->File, "CLIPPING=CLIPTOVIEWPORT\n"); } else { ___476(___1554->___494 == ___495); fprintf(___1399->File, "CLIPPING=CLIPTOFRAME\n"); } if (___1554->___1111 == ___1112) { fprintf(___1399->File, "DRAWORDER=AFTERDATA\n"); } else { ___476(___1554->___1111 == ___1113); fprintf(___1399->File, "DRAWORDER=BEFOREDATA\n"); } fprintf(___1399->File, "MFC="); ___1129(___1399, ___1554->___2332, ___1303); if ((___1554->___1651 == GeomType_Circle) || (___1554->___1651 == GeomType_Ellipse)) fprintf(___1399->File, "EP=%lld\n", (lldfmt_t)___1554->___2795); if (___1554->___1651 == GeomType_LineSegs && ___1554->___3168 != CoordSys_Grid3D) { switch (___1554->___188) { case ___192  : fprintf(___1399->File, "AST=PLAIN\n"); break; case ___189 : fprintf(___1399->File, "AST=FILLED\n"); break; case ___190 : fprintf(___1399->File, "AST=HOLLOW\n"); break; default: ___476(___1303); break; } switch (___1554->___176) { case ___181        : break; case ___177 : fprintf(___1399->File, "AAT=BEGINNING\n"); break; case ___179       : fprintf(___1399->File, "AAT=END\n"); break; case ___178  : fprintf(___1399->File, "AAT=BOTH\n"); break; default: ___476(___1303); break; } if (___1554->___176 != ___181) { fprintf(___1399->File, "ASZ=%.12G\n", ___1554->___187*ArrowheadSizeInputSpec.___1977.___3435); fprintf(___1399->File, "AAN=%.12G\n", ___1554->___171*ArrowheadAngleInputSpec.___1977.___3435); } } switch (___1554->___1651) { case GeomType_LineSegs : { fprintf(___1399->File, "T=LINE\n"); fprintf(___1399->File, "DT="); ___4513(___1399, ___1725(___1554->___1571.___1546.___4294), ___1303); fputc('\n', ___1399->File); fprintf(___1399->File, "%d\n", (int)___1554->___2837); SegIndex = 0; for (___1831 = 0; ___2039 && (___1831 < ___1554->___2837); ___1831++) { fprintf(___1399->File, "%lld\n", (lldfmt_t)___1554->___2839[___1831]); for (___1925 = 0; ___1925 < ___1554->___2839[___1831]; ___1925++) { fprintf(___1399->File, "%.12G ", ___1734(___1554->___1571.___1546.___4294, SegIndex + ___1925)*___3435);
fprintf(___1399->File, "%.12G", ___1734(___1554->___1571.___1546.___4296, SegIndex + ___1925)*___3435); if (GEOM_USES_V3(___1554)) ___2039 = ___1480(fprintf(___1399->File, " %.12G\n", ___1734(___1554->___1571.___1546.___4298, SegIndex + ___1925))); else ___2039 = (___372)(fputc('\n', ___1399->File) != EOF); } SegIndex += ___1554->___2839[___1831]; } } break; case GeomType_Rectangle : { fprintf(___1399->File, "T=RECTANGLE %.12G %.12G\n", ___1734(___1554->___1571.___4580.___4569, 0)*___3435, ___1734(___1554->___1571.___4580.___4586, 0)*___3435); } break; case GeomType_Square : { fprintf(___1399->File, "T=SQUARE %.12G\n", ___1734(___1554->___1571.___4580.___4569, 0)*___3435); } break; case GeomType_Circle : { fprintf(___1399->File, "T=CIRCLE %.12G\n", ___1734(___1554->___1571.___4580.___4569, 0)*___3435); } break; case GeomType_Ellipse : { fprintf(___1399->File, "T=ELLIPSE %.12G %.12G\n", ___1734(___1554->___1571.___4580.___4569, 0)*___3435, ___1734(___1554->___1571.___4580.___4586, 0)*___3435); } break; default: ___476(___1303); } } return ___2039; } bool ___1131(___1403* ___1399, ___4119 const* Text, ___372     ___4485, ___372     ___4525) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(Text)); REQUIRE(VALID_BOOLEAN(___4485)); REQUIRE(VALID_BOOLEAN(___4525)); if (___4485) { ___4493(___1399, ___4113, FieldDataType_Float); if (Text->___3168 == CoordSys_Grid) { ___4490(___1399, 0); } else if (Text->___3168 == CoordSys_Frame) { ___4490(___1399, 1); } else if (Text->___3168 == CoordSys_Grid3D) { ___4490(___1399, 4); }
 #if 0 
else if (___1554->___3168 == ___659) { ___4490(___1399, 2); }
 #endif
else { ___476(___1303); } ___4490(___1399, (___2226)Text->___3444); ___4493(___1399, Text->___52.___1546.___4293, FieldDataType_Double); ___4493(___1399, Text->___52.___1546.___4295, FieldDataType_Double); ___4493(___1399, Text->___52.___1546.___4297, FieldDataType_Double); { ___4490(___1399, static_cast<___2226>(Text->___4122.___1442)); } ___4490(___1399, (___2226)Text->___4122.___3602); ___4493(___1399, Text->___4122.___1826, FieldDataType_Double); ___4490(___1399, (___2226)Text->___401.___411); ___4493(___1399, Text->___401.___2339, FieldDataType_Double); ___4493(___1399, Text->___401.___2291, FieldDataType_Double); ___4490(___1399, (___2226)Text->___401.___351); ___4490(___1399, (___2226)Text->___401.___1408); ___4493(___1399, Text->___57, FieldDataType_Double); ___4493(___1399, Text->___2289, FieldDataType_Double); ___4490(___1399, (___2226)Text->___39); if (Text->___227) ___4490(___1399, (___2226)Text->___4600); else ___4490(___1399, (___2226) - 1); ___4490(___1399, (___2226)Text->___351); } else { double ___3435; ___372 IncludeZ = Text->___3168 == CoordSys_Grid3D; if (Text->___3168 == CoordSys_Frame) ___3435 = 100.0; else ___3435 = 1.0; fprintf(___1399->File, "TEXT\n"); WriteAsciiTextGeomBasics(___1399->File, Text->___3168, Text->___227, Text->___4600, Text->___351, Text->___3444, IncludeZ, ___4525, &Text->___52, ___3435); fprintf(___1399->File, "HU="); switch (Text->___4122.___3602) { case ___4270  : fprintf(___1399->File, "GRID\n"); break; case ___4269 : fprintf(___1399->File, "FRAME\n"); break; case ___4272 : fprintf(___1399->File, "POINT\n"); break; case ___4268 : default: ___476(___1303); break; } fprintf(___1399->File, "LS=%.4G ", Text->___2289); fprintf(___1399->File, "AN="); switch (Text->___39) { case ___4051       : fprintf(___1399->File, "LEFT\n");        break; case ___4046     : fprintf(___1399->File, "CENTER\n");      break; case ___4056      : fprintf(___1399->File, "RIGHT\n");       break; case ___4053    : fprintf(___1399->File, "MIDLEFT\n");     break; case ___4052  : fprintf(___1399->File, "MIDCENTER\n");   break; case ___4054   : fprintf(___1399->File, "MIDRIGHT\n");    break; case ___4048   : fprintf(___1399->File, "HEADLEFT\n");    break; case ___4047 : fprintf(___1399->File, "HEADCENTER\n");  break; case ___4049  : fprintf(___1399->File, "HEADRIGHT\n");   break; default: ___476(___1303); break; } switch (Text->___401.___411) { case ___4070 : fprintf(___1399->File, "BX=Hollow "); break; case ___4064 : fprintf(___1399->File, "BX=Filled "); break; default :;
} fprintf(___1399->File, "BXM=%.4G ", Text->___401.___2339*100); fprintf(___1399->File, "LT=%.4G ", Text->___401.___2291*100.0); fprintf(___1399->File, "BXO="); WriteAsciiColor(___1399->File, Text->___401.___351); fprintf(___1399->File, "BXF="); WriteAsciiColor(___1399->File, Text->___401.___1408); fprintf(___1399->File, "\nF="); Font_e ___1441; { ___1441 = Text->___4122.___1442; } switch (___1441) { case ___1452                  : fprintf(___1399->File, "HELV");                break; case ___1453              : fprintf(___1399->File, "HELV-BOLD");           break; case Font_HelveticaItalic            : fprintf(___1399->File, "HELV-ITALIC");         break; case Font_HelveticaItalicBold        : fprintf(___1399->File, "HELV-ITALIC-BOLD");    break; case ___1464                      : fprintf(___1399->File, "TIMES");               break; case ___1465                  : fprintf(___1399->File, "TIMES-BOLD");          break; case ___1466                : fprintf(___1399->File, "TIMES-ITALIC");        break; case ___1467            : fprintf(___1399->File, "TIMES-ITALIC-BOLD");   break; case ___1443                    : fprintf(___1399->File, "COURIER");             break; case ___1444                : fprintf(___1399->File, "COURIER-BOLD");        break; case Font_CourierItalic              : fprintf(___1399->File, "COURIER-ITALIC");      break; case Font_CourierItalicBold          : fprintf(___1399->File, "COURIER-ITALIC-BOLD"); break; case ___1447                      : fprintf(___1399->File, "GREEK");               break; case ___1457                       : fprintf(___1399->File, "MATH");                break; case ___1468                : fprintf(___1399->File, "USER-DEF");            break; default: ___476(___1303); break; } if (Text->___4122.___3602 == ___4269) ___3435 = 100.0; else ___3435 = 1.0; fprintf(___1399->File, "\nH=%.12G A=%.12G", Text->___4122.___1826*___3435, Text->___57*___952); } if (!___4485) fprintf(___1399->File, "\nMFC="); ___1129(___1399, Text->___2332.c_str(), ___4485); if (!___4485) { if (Text->___494 == ___496) { fprintf(___1399->File, "CLIPPING=CLIPTOVIEWPORT\n"); } else { ___476(Text->___494 == ___495); fprintf(___1399->File, "CLIPPING=CLIPTOFRAME\n"); } } else { ___4490(___1399, (___2226)Text->___494); } if (!___4485) fprintf(___1399->File, "T="); return ___1129(___1399, Text->Text.c_str(), ___4485) == ___4227; } ___372 ___1128(___1403  *___1399, ___372      ___4485, ___3840  ___2169) { ___372 ___2039 = ___4227; ___2226 ___1925 = 0; ___2226 ___682 = 0; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_BOOLEAN(___4485)); REQUIRE(___3849(___2169)); ___682 = ___3827(___2169);
if (___4485) { ___4493(___1399, ___790, FieldDataType_Float); ___4490(___1399, ___682); } else { fprintf(___1399->File, " CUSTOMLABELS = \n"); } for (___1925 = 0, ___2039 = ___4227; ___1925 < ___682 && ___2039; ___1925++) { const char *CurLabel = ___3836(___2169, ___1925); ___2039 = ___1129(___1399, CurLabel, ___4485); } ENSURE(VALID_BOOLEAN(___2039)); return ___2039; } ___372 ___4492(___1403 *___1399) { return (___4490(___1399, 1)); } bool ___4494(___1403& ___1398, int           ___4409) { char ___416[5]; sprintf(___416, "V%-3d", ___4409); ___476(strlen(___416) == 4); return fprintf(___1398.File, "#!TD%s", ___416) > 0; }
