#include "TecioTecUtil.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cfloat>
#include <cstring>
#include <limits>
#include <map>
#include <set>
#include <sstream>
#include <tuple>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "feCellTypeMetrics.h"
#include "FieldData_s.h"
#include "NodeMap_s.h"
#include "NodeToElemMap_s.h"
#include "zoneUtil.h"
 #if defined TECIOMPI
struct ___2121 {}; struct ___2666 {};
 #else
#include "JobControl_s.h"
#include "Mutex_s.h"
 #endif
using namespace tecplot::___3934; namespace { tecplot::tecioszl::___1360* toSzlioFieldData(___1359 ___1349) { return reinterpret_cast<tecplot::tecioszl::___1360*>(___1349); } ___1359 toTecUtilFieldData(tecplot::tecioszl::___1360* ___1349) { return reinterpret_cast<___1359>(___1349); } } namespace { tecplot::tecioszl::___2731* toSzlioNodeMap(___2728 ___2724) { return reinterpret_cast<tecplot::tecioszl::___2731*>(___2724); } ___2728 toTecUtilNodeMap(tecplot::tecioszl::___2731* ___2724) { return reinterpret_cast<___2728>(___2724); } } namespace { tecplot::tecioszl::___2744* toSzlioNodeToElemMap(___2743 nodeToElem) { return reinterpret_cast<tecplot::tecioszl::___2744*>(nodeToElem); } ___2743 toTecUtilNodeToElemMap(tecplot::tecioszl::___2744* nodeToElem) { return reinterpret_cast<___2743>(nodeToElem); } } struct StringList_s { std::vector<std::string> m_strings; }; namespace tecplot { namespace tecioszl { namespace { char* copyString(std::string const& str) { char* ___3359 = new char[strlen(str.c_str()) + 1]; strcpy(___3359, str.c_str()); return ___3359; } } ___4017::___4017(___3971& tecioData) : m_tecioData(tecioData) {} ___4017::~___4017() {} void ___4017::___3818(char** ___3856) const { delete[] *___3856; *___3856 = 0; } void ___4017::___3828(___3840* ___3820) const { delete *___3820; *___3820 = 0; } ___2226 ___4017::___3833(___3840 ___3820) const { return (___2226)___3820->m_strings.size(); } char* ___4017::___3834(___3840 ___3820, ___2226 ___3854) const { REQUIRE(0 < ___3854 && ___3854 <= ___3833(___3820)); return copyString(___3820->m_strings[___3854 - 1]); } ___264 ___4017::___235() const { return m_tecioData.dataSetAuxData().get(); } ___264 ___4017::___274(___4636 zone) const { REQUIRE(m_tecioData.validZoneNum(zone)); Zone_s const* zonePtr = m_tecioData.zonePtr(zone); return zonePtr->___2346.get(); } ___264 ___4017::___273(___4352 ___4336) const { REQUIRE(0 < ___4336 && ___4336 <= static_cast<___1170>(m_tecioData.variableNames().size())); return m_tecioData.varAuxData()[___4336 - 1].get(); } int32_t ___4017::___247(___264 ___265) const { return static_cast<int32_t>(___265->m_auxDataItems.size()); } void ___4017::___243(___264 ___265, int32_t index, char** ___2686, ___90* value, AuxDataType_e* type, ___372* ___3362) const { REQUIRE(VALID_REF(___265)); REQUIRE(0 < index && (size_t)index <= ___265->m_auxDataItems.size()); REQUIRE(VALID_REF(___2686) && *___2686 == 0); REQUIRE(VALID_REF(value) && *value == 0); REQUIRE(VALID_REF(type)); REQUIRE(VALID_REF(___3362)); AuxData_s::AuxDataItem const& auxDataItem = ___265->m_auxDataItems[index - 1]; *___2686 = copyString(auxDataItem.___2496);
*value = reinterpret_cast<___90>(copyString(auxDataItem.___2668)); *type = ___270; *___3362 = auxDataItem.m_retain; } ___372 ___4017::___894() const { return static_cast<___372>(m_tecioData.___894()); } ___372 ___4017::datasetGetTitle(char** datasetTitle) const { *datasetTitle = copyString(m_tecioData.___4178()); return ___4227; } int32_t ___4017::___887() const { return 0; } ___3502 ___4017::datasetGetRelevantZones(double  , double /*solutionTimeMax*/, ___372 /*ignoreStaticZones*/) const { ___476(___1303); return ___3502(0); } ___4636 ___4017::___889() const { REQUIRE(___894()); return static_cast<___4636>(m_tecioData.___2847()); } ___4352 ___4017::___888() const { REQUIRE(___894()); return static_cast<___4352>(m_tecioData.variableNames().size()); } ___4265 ___4017::datasetGetUniqueID() const { REQUIRE(___894()); return static_cast<___4265>(0); } ___4352 ___4017::___4345(char ___214) const { REQUIRE('X' <= ___214 && ___214 <= 'Z'); return static_cast<___4352>(___214 - 'X' + 1); } ___372 ___4017::___4344(___4352 ___4368, char** ___4362) const { REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); REQUIRE(VALID_REF(___4362) && !*___4362); *___4362 = copyString(m_tecioData.variableNames()[___4368 - 1]); return ___4227; } int32_t ___4017::___4343(___4352 ___4368) const { REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); return static_cast<int32_t>(m_tecioData.varAuxData()[___4368]->m_auxDataItems.size()); } ___372 ___4017::___4638(___4636 ___4658) const { return (m_tecioData.zonePtr(___4658) != NULL) ? ___4227 : ___1303; } ___372 ___4017::___4614(___3502* ___1151) const { try { std::set<___3494>* ___3359 = new std::set<___3494>(m_tecioData.unflushedZoneSet()); *___1151 = reinterpret_cast<___3502>(___3359); return ___4227; } catch (...) { return ___1303; } } ZoneType_e ___4017::___4620(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2685; } ___372 ___4017::zoneGetNumSections(___4265 ASSERT_ONLY(dataSetID), ___4636 ___4658, ___1170* numSections) const { REQUIRE(dataSetID == 0); REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(___4620(___4658) != ___4704 && ___4620(___4658) != ___4698 && ___4620(___4658) != ___4699); ZoneType_e const ___4692 = ___4620(___4658); if (___4692 == ___4702 || ___4692 == ___4700     || ___4692 == ___4701    || ___4692 == ___4695    || ___4692 == ___4696) { *numSections = 1; } else { ___476(___4692 == ZoneType_FEMixed); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658);
*numSections = checked_numeric_cast<___1170>(zonePtr->m_cellShapes.size()); } ENSURE(*numSections >= 1); return ___4227; } namespace { std::pair<___1170 ,___1170/*___2822*/> numNodesForFECellType( FECellShape_e         cellShape, ___1170            gridOrder, FECellBasisFunction_e basisFn) { ___1170 numEdges; ___1170 numFacesOrEdges; ___1170 ___2790; ___1170 ___2822; ___1170 numHighOrderNodes; ___1170 numNaturalSubElems; ___1170 const MAX_NUM_FACES_PER_ELEM = 6; std::vector<___1170> numCornersPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numHighOrderNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); tecplot::feCellTypeMetrics( cellShape, gridOrder, basisFn, numEdges, numFacesOrEdges, ___2790, ___2822, numHighOrderNodes, numNaturalSubElems, numCornersPerFaceOrEdge.begin(), numNodesPerFaceOrEdge.begin(), numHighOrderNodesPerFaceOrEdge.begin()); ENSURE(2 <= ___2790 && ___2790 <= ___2822 && ___2822 <= static_cast<___1170>(MAX_NODES_PER_ELEM)); return std::make_pair(___2790, ___2822); } } namespace { ___372 getSectionMetrics(Zone_s const& zone, ___1170             section, FECellShape_e&         cellShape, ___1170&            gridOrder, FECellBasisFunction_e& basisFn, ___2226&             numElements, ___1170&            numCornersPerElem, ___1170&            numNodesPerElem) { if (zone.___2685 == ZoneType_FEMixed) { cellShape = zone.m_cellShapes[section]; gridOrder = zone.m_gridOrders[section]; basisFn = zone.m_basisFns[section]; numElements = zone.m_numElementsPerSection[section]; } else { switch (zone.___2685) { case ___4702: cellShape = FECellShape_Triangle;      break; case ___4700:     cellShape = FECellShape_Quadrilateral; break; case ___4701:    cellShape = FECellShape_Tetrahedron;   break; case ___4695:    cellShape = FECellShape_Hexahedron;    break; case ___4696:  cellShape = FECellShape_Bar;           break; default: ___476(___1303); break; } gridOrder = 1; basisFn = FECellBasisFunction_Lagrangian; numElements = zone.___2683.___2104(); } std::tie(numCornersPerElem, numNodesPerElem) = numNodesForFECellType(cellShape, gridOrder, basisFn); return ___4227; } } ___372 ___4017::zoneGetSectionMetrics( ___4265 ASSERT_ONLY(dataSetID), ___4636 ___4658, ___1170 section, FECellShape_e* cellShape, ___1170* gridOrder, FECellBasisFunction_e* basisFn, ___2226* numElements, ___1170* numCornersPerElem, ___1170* numNodesPerElem) const { REQUIRE(dataSetID == 0); REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(___4620(___4658) != ___4704 && ___4620(___4658) != ___4698 && ___4620(___4658) != ___4699); ASSERT_ONLY(___1170 numSections = 0); REQUIRE(zoneGetNumSections(dataSetID, ___4658, &numSections) && section <= numSections); REQUIRE(VALID_REF(cellShape)); REQUIRE(VALID_REF(gridOrder));
REQUIRE(VALID_REF(basisFn)); REQUIRE(VALID_REF(numElements)); REQUIRE(VALID_REF(numCornersPerElem)); REQUIRE(VALID_REF(numNodesPerElem)); return getSectionMetrics( *m_tecioData.zonePtr(___4658), section-1, *cellShape, *gridOrder, *basisFn, *numElements, *numCornersPerElem, *numNodesPerElem); } int32_t ___4017::zoneGetDimension( ___4265  ASSERT_ONLY(dataSetID), ___4636 ___4658) const { REQUIRE(dataSetID == 0); REQUIRE(m_tecioData.validZoneNum(___4658)); int32_t ___3359 = 0; Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); ZoneType_e const ___4692 = ___4620(___4658); if (___4692 == ___4704) { ___3359 = ___2884(zonePtr->___2683); } else if (___4692 == ZoneType_FEMixed) { ___476(!zonePtr->m_cellShapes.empty()); ___3359 = feMixedZoneDimension(zonePtr->m_cellShapes[0]); } else { ___3359 = feNonMixedZoneDimension(___4692); } ENSURE(1 <= ___3359 && ___3359 <= 3); return ___3359; } void ___4017::___4615(___4636 ___4658, ___1843& ___2716) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); ___2716 = zonePtr->___2683; } ___372 ___4017::___4616(___4636 ___4658, char** ___4652) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(VALID_REF(___4652) && !*___4652); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); *___4652 = copyString(zonePtr->___2684); return ___4227; } ___4636 ___4017::___4617(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2615; } double ___4017::___4618(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2622; } ___1170 ___4017::___4619(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2623; } int32_t ___4017::___4613(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return static_cast<int32_t>(zonePtr->___2346->m_auxDataItems.size()); } ___372 ___4017::___4640(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return static_cast<___372>(zonePtr->___2685 != ___4704); } ___372 ___4017::___4641(tecplot::___3934::___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return static_cast<___372>(zonePtr->___2685 == ___4704); } ___372 ___4017::___4353(___4352 ASSERT_ONLY(___4368)) const { REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); return ___4227; } ___372 ___4017::varGetEnabled(___3502* enabledVars) const
{ ___476(___1303); *enabledVars = ___3502(0); return ___4227; } int32_t ___4017::solutionTimeGetNumTimeSteps() const { ___476(___1303); return 0; } double ___4017::solutionTimeGetMinTime() const { ___476(___1303); return 0.0; } double ___4017::solutionTimeGetMaxTime() const { ___476(___1303); return 0.0; } ___372 ___4017::___3769() const { return ___4227; } GeomID_t ___4017::___1590(void) { if (!m_tecioData.geoms().empty()) return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[0]); return ___4036; } TextID_t ___4017::___4088(void) { if (!m_tecioData.texts().empty()) return reinterpret_cast<TextID_t>(&m_tecioData.texts()[0]); return ___4036; } int32_t ___4017::___795(void) { return (int32_t)m_tecioData.customLabels().size(); } ___372 ___4017::___794(___3840* ___2170, int32_t ___4453) { REQUIRE(0 < ___4453 && ___4453 <= (int32_t)m_tecioData.customLabels().size()); try { *___2170 = new StringList_s; (*___2170)->m_strings = m_tecioData.customLabels()[___4453 - 1]; return ___4227; } catch(...) { return ___1303; } } void ___4017::___856() { } void ___4017::___857() { } void ___4017::___3780(char const* ___3002, ___372 ___3585, ___372 ___3580) const { ___4279(___3002); ___4279(___3585); ___4279(___3580); } void ___4017::___3779(char const* ___3002) const { ___4279(___3002); } ___372 ___4017::___3770(int percentDone) const { ___4279(percentDone); return ___4227; } void ___4017::___3771(void) const { } ___372 ___4017::___1982(void) const { return ___1303; } ___4636 ___4017::___542(___3502 ___4684, ___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); std::set<___3494>* ___4671 = reinterpret_cast<std::set<___3494>*>(___4684); if (!zonePtr->m_shareConnectivityFromZone) return ___4036; else if (!___4671 || ___4671->find(zonePtr->m_shareConnectivityFromZone) != ___4671->end()) return zonePtr->m_shareConnectivityFromZone; return ___4036; } ___3502 ___4017::___543(___4636 zone) const { REQUIRE(m_tecioData.validZoneNum(zone)); Zone_s const* zonePtr = m_tecioData.zonePtr(zone); try { std::set<___3494>* ___3359 = new std::set<___3494>; if (zonePtr->___2498) { ___4636 const ___341 = m_tecioData.baseZoneForConnectivity(zone); std::set<___3494> const zoneSet = m_tecioData.zoneSet(); for (std::set<___3494>::const_iterator ___4658 = zoneSet.begin(); ___4658 != zoneSet.end(); ++___4658) { if (m_tecioData.baseZoneForConnectivity(static_cast<___4636>(*___4658)) == ___341) ___3359->insert(*___4658); } } return reinterpret_cast<___3502>(___3359); } catch (...) { return NULL; } } ValueLocation_e ___4017::___908(___4636 ___4658, ___4352 ___4368) const
{ REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2671[___4368 - 1]; } ValueLocation_e ___4017::___909(___1359 ___1349) const { REQUIRE(VALID_REF(___1349)); return toSzlioFieldData(___1349)->___2670; } ___372 ___4017::___911( ___4636 ___4658, ___4352 ___4336, double* minVal, double* maxVal) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4336 && ___4336 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4336); if (zoneIsPartitioned(___4658)) { if (zonePtr->m_partitionMap.empty()) { *minVal = 0.0; *maxVal = 0.0; } else { *minVal = std::numeric_limits<double>::max(); *maxVal = -std::numeric_limits<double>::max(); for (Zone_s::ZoneMap::const_iterator valuePair = zonePtr->m_partitionMap.begin(); valuePair != zonePtr->m_partitionMap.end(); ++valuePair) { double partitionMinVal = 0.0; double partitionMaxVal = 0.0; valuePair->second->___2497[___4336 - 1]->___1758(partitionMinVal, partitionMaxVal); *minVal = std::min(*minVal, partitionMinVal); *maxVal = std::max(*maxVal, partitionMaxVal); } } } else if (zonePtr->___2497[___4336 - 1]) { zonePtr->___2497[___4336 - 1]->___1758(*minVal, *maxVal); } else { ___476(zonePtr->m_shareVarFromZone[___4336 - 1] != 0); *minVal = 0.0; *maxVal = 0.0; } ENSURE(*minVal <= *maxVal); return ___4227; } ___372 ___4017::___910( ___1359 ___1349, double* minVal, double* maxVal) const { toSzlioFieldData(___1349)->___1758(*minVal, *maxVal); return ___4227; } FieldDataType_e ___4017::___921(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2461[___4368 - 1]; } ___1170 ___4017::___919(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); ___1170 shareCount = 0; ___3502 shareSet = ___920(___4658, ___4368); if (shareSet) { shareCount = checked_numeric_cast<___1170>(setGetMemberCount(shareSet)); ___3485(&shareSet); } return shareCount; } ___1359 ___4017::___916(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); if (zonePtr->___2497[___4368 - 1]->___2670 == ___4330) return ___915(___4658, ___4368);
else return ___914(___4658, ___4368); } ___1359 ___4017::___913(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); if (zonePtr->___2497[___4368 - 1]->___2670 == ___4328) return ___915(___4658, ___4368); else return ___914(___4658, ___4368); } ___1359 ___4017::___915(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); return toTecUtilFieldData(zonePtr->___2497[___4368 - 1].get()); } ___1359 ___4017::___914(___4636 ___4658, ___4352 ___4368) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); try { if (zonePtr->___2401[___4368 - 1]->storedValueCount() == 0) { Zone_s* connectivityZonePtr = m_tecioData.zonePtrForConnectivity(___4658); if (zonePtr->___2497[___4368 - 1]->___2670 == ___4328) zonePtr->___963(___4368, connectivityZonePtr->___2498.get()); else zonePtr->deriveCCValues(___4368, connectivityZonePtr->___2498.get()); } } catch (std::exception const&) { } return toTecUtilFieldData(zonePtr->___2401[___4368 - 1].get()); } ___1359 ___4017::___922(___4636 ___4658, ___4352 ___4368) { return ___915(___4658, ___4368); } namespace { double fieldValueGetFunction(___1359 ___1349, ___2226 ___2734) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 <= ___2734); tecplot::tecioszl::___1360* const szlioFD = toSzlioFieldData(___1349); size_t index = static_cast<size_t>(___2734); REQUIRE(szlioFD->___2669 == 0 || index < szlioFD->___2669); if (index < szlioFD->___2669) return szlioFD->___1779(index); return 0.0; } void fieldValueSetFunction(___1359 ___1349, ___2226 ___2734, double ___4299) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 <= ___2734); tecplot::tecioszl::___1360* const szlioFD = toSzlioFieldData(___1349); size_t index = static_cast<size_t>(___2734); REQUIRE(szlioFD->___2669 == 0 || index < szlioFD->___2669); if (index < szlioFD->___2669) szlioFD->___3505(index, ___4299); } } double ___4017::___907(___1359 ___1349, ___81 ___2734) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 < ___2734); return fieldValueGetFunction(___1349, ___2734 - 1); } void ___4017::dataValueSetByRef(___1359 ___1349, ___81 ___2734, double ___4299)
{ REQUIRE(VALID_REF(___1349)); REQUIRE(0 < ___2734); fieldValueSetFunction(___1349, ___2734 - 1, ___4299); } void ___4017::___917(___4636 ___4658, ___4352 ___4368, void** ___878, FieldDataType_e* ___1361) { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); *___878 = zonePtr->___2497[___4368 - 1]->getRawPointer(); *___1361 = zonePtr->___2497[___4368 - 1]->___2460; } void ___4017::___923(___4636 ___4658, ___4352 ___4368, void** ___878, FieldDataType_e* ___1361) { ___917(___4658, ___4368, ___878, ___1361); } ___4636 ___4017::___912(___3502 ___4684, ___4636 ___4658, ___4352 ___4336) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); std::set<___3494>* ___4671 = reinterpret_cast<std::set<___3494>*>(___4684); if (zonePtr->m_shareVarFromZone.empty() || zonePtr->m_shareVarFromZone[___4336 - 1] == 0) return ___4036; else if (___4671 == NULL || ___4671->find(zonePtr->m_shareVarFromZone[___4336 - 1]) != ___4671->end()) return zonePtr->m_shareVarFromZone[___4336 - 1]; return ___4036; } ___3502 ___4017::___920(___4636 ___4658, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); ___4636 const ___341 = m_tecioData.baseZoneForVar(___4658, ___4368); try { std::set<___3494>* ___3359 = new std::set<___3494>; std::set<___3494> const zoneSet = m_tecioData.zoneSet(); for (std::set<___3494>::const_iterator zoneNumber = zoneSet.begin(); zoneNumber != zoneSet.end(); ++zoneNumber) { if (m_tecioData.baseZoneForVar(checked_numeric_cast<___4636>(*zoneNumber), ___4368) == ___341) ___3359->insert(*zoneNumber); } return reinterpret_cast<___3502>(___3359); } catch (...) { return NULL; } } ___372 ___4017::___924(___4636 ___4658, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return (zonePtr->m_passiveVars[___4368 - 1] != 0); } ___1381 ___4017::___925(___1359 ___1307) { ___4279(___1307); return fieldValueGetFunction; } ___1382 ___4017::___926(___1359 ___1307) { ___4279(___1307); return fieldValueSetFunction; } FieldDataType_e ___4017::___918(___1359 ___1349) { return toSzlioFieldData(___1349)->___2460; } ___2728 ___4017::___865(___4636 ___4658) { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4658);
return toTecUtilNodeMap(zonePtr->___2498.get()); } ___2728 ___4017::___867(___4636 ___4658) { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4658); return toTecUtilNodeMap(zonePtr->___2498.get()); } ___2719 ___4017::___863( ___2728 ___2724, ___463 ___466, CellNodeIndex_t ___681) { tecplot::tecioszl::___2731* const szlioNM = toSzlioNodeMap(___2724); REQUIRE(VALID_REF(szlioNM)); REQUIRE(szlioNM->m_numCellsPerSection.size() == 0); size_t const section = 0; REQUIRE(0 < ___466 && ___466 <= static_cast<___463>(szlioNM->m_numCellsPerSection[section])); REQUIRE(0 < ___681 && ___681 <= szlioNM->m_numNodesPerCellPerSection[section]); ___463 ___460 = ___466 - 1; int64_t ___2717 = szlioNM->value(section, ___460 * szlioNM->m_numNodesPerCellPerSection[section] + ___681 - 1); return (___2719)___2717 + 1; } void ___4017::___868(___2728 ___2724, ___463 ___466, CellNodeIndex_t ___681, ___2719 ___2717) { tecplot::tecioszl::___2731* const szlioNM = toSzlioNodeMap(___2724); REQUIRE(VALID_REF(szlioNM)); REQUIRE(szlioNM->m_numCellsPerSection.size() == 0); size_t const section = 0; REQUIRE(0 < ___466 && ___466 <= static_cast<___463>(szlioNM->m_numCellsPerSection[section])); REQUIRE(0 < ___681 && ___681 <= szlioNM->m_numNodesPerCellPerSection[section]); szlioNM->___3505(section, (___466 - 1) * szlioNM->m_numNodesPerCellPerSection[section] + ___681 - 1, ___2717 - 1); } OffsetDataType_e ___4017::dataNodeGetRawItemType(___2728 ___2724) { REQUIRE(VALID_REF(___2724)); return toSzlioNodeMap(___2724)->getRawItemType(); } int32_t* ___4017::dataNodeGetRawPtrByRef(___2728 ___2724) { REQUIRE(VALID_REF(___2724)); return reinterpret_cast<int32_t*>(toSzlioNodeMap(___2724)->getRawPtr(0  )); } int64_t* ___4017::dataNodeGetRawPtrByRef64(___2728 ___2724) { REQUIRE(VALID_REF(___2724)); return reinterpret_cast<int64_t*>(toSzlioNodeMap(___2724)->getRawPtr(0  )); } void ___4017::dataNodeSectionArrayGetByRef(___2728 ___2724, ___1170 sectionIndex, ___2226 index, ___2226 count, int32_t* nodeArray) const { tecplot::tecioszl::___2731* const szlioNM = toSzlioNodeMap(___2724); REQUIRE(VALID_REF(szlioNM)); for (___2226 nOffset = 0; nOffset < count; ++nOffset) nodeArray[nOffset] = checked_numeric_cast<int32_t>(szlioNM->value(sectionIndex - 1, index + nOffset - 1) + 1); } void ___4017::dataNodeSectionArrayGetByRef(___2728 ___2724, ___1170 sectionIndex, ___2226 index, ___2226 count, int64_t* nodeArray) const { tecplot::tecioszl::___2731* const szlioNM = toSzlioNodeMap(___2724); REQUIRE(VALID_REF(szlioNM)); for (___2226 nOffset = 0; nOffset < count; ++nOffset) nodeArray[nOffset] = checked_numeric_cast<int64_t>(szlioNM->value(sectionIndex, index + nOffset - 1) + 1); } void ___4017::dataNodeSectionArraySetByRef(___2728 ___2724, ___1170 sectionIndex,
___2226 index, ___2226 count, int32_t const* nodeArray) { tecplot::tecioszl::___2731* const szlioNM = toSzlioNodeMap(___2724); REQUIRE(VALID_REF(szlioNM)); for (___2226 nOffset = 0; nOffset < count; ++nOffset) szlioNM->___3505(sectionIndex - 1, index + nOffset - 1, nodeArray[nOffset]); } void ___4017::dataNodeSectionArraySetByRef(___2728 ___2724, ___1170 sectionIndex, ___2226 index, ___2226 count, int64_t const* nodeArray) { tecplot::tecioszl::___2731* const szlioNM = toSzlioNodeMap(___2724); REQUIRE(VALID_REF(szlioNM)); for (___2226 nOffset = 0; nOffset < count; ++nOffset) szlioNM->___3505(sectionIndex - 1, index + nOffset - 1, nodeArray[nOffset]); } int32_t* ___4017::dataNodeSectionGetRawPtrByRef(___2728 ___2724, ___1170 sectionIndex) { REQUIRE(VALID_REF(___2724)); return reinterpret_cast<int32_t*>(toSzlioNodeMap(___2724)->getRawPtr(sectionIndex - 1)); } int64_t* ___4017::dataNodeSectionGetRawPtrByRef64(___2728 ___2724, ___1170 sectionIndex) { REQUIRE(VALID_REF(___2724)); return reinterpret_cast<int64_t*>(toSzlioNodeMap(___2724)->getRawPtr(sectionIndex - 1)); } void ___4017::feCellTypeGetNumNodes(FECellShape_e         cellShape, ___1170            gridOrder, FECellBasisFunction_e basisFn, ___1170*           numCornerNodes, ___1170*           ___2822) const { std::tie(*numCornerNodes, *___2822) = numNodesForFECellType(cellShape, gridOrder, basisFn); } ___2743 ___4017::dataNodeToElemMapGetReadableRef(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s* zonePtr = m_tecioData.zonePtrForConnectivity(___4658); if (!zonePtr->m_nodeToElemMap) zonePtr->m_nodeToElemMap.reset(new ___2744(*zonePtr->___2498, zonePtr->___2683.___1669())); return toTecUtilNodeToElemMap(zonePtr->m_nodeToElemMap.get()); } ___463 ___4017::dataNodeToElemMapGetNumElems(___2743 nodeToElemMap, ___2719 ___2710) const { tecplot::tecioszl::___2744* const szlioNEM = toSzlioNodeToElemMap(nodeToElemMap); REQUIRE(VALID_REF(szlioNEM)); REQUIRE(0 < ___2710 && ___2710 <= szlioNEM->m_nodeCount); return szlioNEM->m_elemIndex[___2710] - szlioNEM->m_elemIndex[___2710 - 1]; } ___463 ___4017::dataNodeToElemMapGetElem(___2743 nodeToElemMap, ___2719 ___2710, ___463 elemOffset) const { tecplot::tecioszl::___2744* const szlioNEM = toSzlioNodeToElemMap(nodeToElemMap); REQUIRE(VALID_REF(szlioNEM)); REQUIRE(0 < ___2710 && ___2710 <= szlioNEM->m_nodeCount); REQUIRE(0 < elemOffset && elemOffset <= szlioNEM->m_elemIndex[___2710] - szlioNEM->m_elemIndex[___2710 - 1]); return szlioNEM->m_elem[szlioNEM->m_elemIndex[___2710 - 1] + elemOffset - 1] + 1; } FaceNeighborMode_e ___4017::___834(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return zonePtr->___2459; } void ___4017::___835( ___1290 ___1272, ___2226 ___1142,
int32_t face, int32_t ___2693, ___2226* ___2692, ___4636* ___2696) const { Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1272); REQUIRE(VALID_REF(zonePtr)); Zone_s::___456 ___455; ___455.first = static_cast<int32_t>(___1142); ___455.second = face; Zone_s::___1274::const_iterator iter = zonePtr->___2458.find(___455); ___476(iter != zonePtr->___2458.end()); ___476(0 < ___2693 && ___2693 <= (___2226)iter->second.___2679.size()); *___2692 = iter->second.___2679[___2693 - 1].second; *___2696 = iter->second.___2679[___2693 - 1].first; } ___372 ___4017::___833( ___1290 ___1272, ___2226 ___1142, int32_t face, ___3502 ___4) const { ___4279(___4); Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1272); REQUIRE(VALID_REF(zonePtr)); Zone_s::___456 ___455; ___455.first = static_cast<int32_t>(___1142); ___455.second = face; Zone_s::___1274::const_iterator iter = zonePtr->___2458.find(___455); if (iter == zonePtr->___2458.end()) return ___1303; else return iter->second.___2489; } int32_t ___4017::___836(___1290 ___1272, ___2226 ___1142, int32_t face, ___372*  ) const { Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1272); REQUIRE(VALID_REF(zonePtr)); Zone_s::___456 ___455; ___455.first = static_cast<int32_t>(___1142); ___455.second = face; Zone_s::___1274::const_iterator iter = zonePtr->___2458.find(___455); if (iter == zonePtr->___2458.end()) return 0; else return (int32_t)iter->second.___2679.size(); } ___1290 ___4017::___837(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s* zonePtr = m_tecioData.zonePtrForConnectivity(___4658); return reinterpret_cast<___1290>(zonePtr); } ___372 ___4017::setAddMember(___3502 set, ___3494 ___2402, ___372 showErr) const { std::set<___3494>* setPtr = reinterpret_cast<std::set<___3494>*>(set); REQUIRE(VALID_REF(setPtr)); try { setPtr->insert(___2402); } catch (std::bad_alloc const&) { if (showErr) std::cerr << "Allocation failure adding member to set." << std::endl; return ___1303; } return ___4227; } ___3502 ___4017::setAlloc(___372 showErr) const { std::set<___3494>* ___3359 = NULL; try { ___3359 = new std::set<___3494>(); } catch (std::bad_alloc const&) { if (showErr) std::cerr << "Allocation failure allocating set." << std::endl; } return reinterpret_cast<___3502>(___3359); } void ___4017::___3485(___3502* set) const { REQUIRE(VALID_REF(set)); std::set<___3494>* setPtr = *(reinterpret_cast<std::set<___3494>**>(set)); REQUIRE(VALID_REF_OR_NULL(setPtr)); delete setPtr; *set = NULL; } ___3494 ___4017::___3492(___3502 set, ___3494 ___2402) const { std::set<___3494>* setPtr = reinterpret_cast<std::set<___3494>*>(set);
REQUIRE(VALID_REF(setPtr)); std::set<___3494>::iterator it; if (___2402 == ___4040) { it = setPtr->begin(); } else { it = setPtr->find(___2402); if (it != setPtr->end()) ++it; } if (it == setPtr->end()) return ___4040; else return *it; } ___3494 ___4017::setGetPrevMember(___3502 set, ___3494 ___2402) const { std::set<___3494>* setPtr = reinterpret_cast<std::set<___3494>*>(set); REQUIRE(VALID_REF(setPtr)); std::set<___3494>::reverse_iterator it; if (___2402 == ___4040) { it = setPtr->rbegin(); } else { it = setPtr->rbegin(); while (it != setPtr->rend() && *it != ___2402) ++it; if (it != setPtr->rend()) ++it; } if (it == setPtr->rend()) return ___4040; else return *it; } ___3494 ___4017::setGetMemberCount(___3502 set) const { std::set<___3494>* setPtr = reinterpret_cast<std::set<___3494>*>(set); REQUIRE(VALID_REF(setPtr)); return static_cast<___3494>(setPtr->size()); } ___372 ___4017::___3496(___3502 set, ___3494 ___2402) const { std::set<___3494>* setPtr = reinterpret_cast<std::set<___3494>*>(set); REQUIRE(VALID_REF(setPtr)); return setPtr->find(___2402) != setPtr->end(); } ___372 ___4017::setIsEqual(___3502 ___3478, ___3502 ___3479) const { std::set<___3494>* set1Ptr = reinterpret_cast<std::set<___3494>*>(___3478); std::set<___3494>* set2Ptr = reinterpret_cast<std::set<___3494>*>(___3479); REQUIRE(VALID_REF(set1Ptr) && VALID_REF(set2Ptr)); return *set1Ptr == *set2Ptr; } void ___4017::setRemoveMember(___3502 set, ___3494 ___2402) const { std::set<___3494>* setPtr = reinterpret_cast<std::set<___3494>*>(set); REQUIRE(VALID_REF(setPtr)); setPtr->erase(___2402); } void ___4017::___1555(GeomID_t ___1804, int32_t ___3158, ___2226 ___3142, double* x, double* ___4583) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_LineSegs); REQUIRE(0 < ___3158 && ___3158 <= (int32_t)___1553->___2465.size()); REQUIRE(0 < ___3142 && ___3142 <= (___2226)___1553->___2465[___3158 - 1].size()); *x = ___1553->___2465[___3158 - 1][___3142 - 1].x(); *___4583 = ___1553->___2465[___3158 - 1][___3142 - 1].___4583(); } void ___4017::___1556(GeomID_t ___1804, ___2226 ___3142, double* x, double* ___4583) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_LineSegs); REQUIRE(0 < ___3142 && ___3142 < (___2226)___1553->___2465[0].size()); *x = ___1553->___2465[0][___3142 - 1].x(); *___4583 = ___1553->___2465[0][___3142 - 1].___4583(); } void ___4017::___1558(GeomID_t ___1804, int32_t ___3158, ___2226 ___3142, double* x, double* ___4583, double* z) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_LineSegs && ___1553->___2617 == CoordSys_Grid3D); REQUIRE(0 < ___3158 && ___3158 <= (int32_t)___1553->___2465.size()); REQUIRE(0 < ___3142 && ___3142 <= (___2226)___1553->___2465[___3158 - 1].size());
*x = ___1553->___2465[___3158 - 1][___3142 - 1].x(); *___4583 = ___1553->___2465[___3158 - 1][___3142 - 1].___4583(); *z = ___1553->___2465[___3158 - 1][___3142 - 1].z(); } void ___4017::___1559(GeomID_t ___1804, ___2226 ___3142, double* x, double* ___4583, double* z) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_LineSegs && ___1553->___2617 == CoordSys_Grid3D); REQUIRE(0 < ___3142 && ___3142 < (___2226)___1553->___2465[0].size()); *x = ___1553->___2465[0][___3142 - 1].x(); *___4583 = ___1553->___2465[0][___3142 - 1].___4583(); *z = ___1553->___2465[0][___3142 - 1].z(); } double ___4017::___1562(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2341; } ArrowheadAttachment_e ___4017::___1563(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2342; } double ___4017::___1564(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2343; } ArrowheadStyle_e ___4017::___1565(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2344; } double ___4017::___1568(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_Circle); REQUIRE(___1553->___2465.size() == 1); REQUIRE(___1553->___2465[0].size() == 1); return ___1553->___2465[0][0].x(); } int32_t ___4017::___1574(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_Ellipse || ___1553->___2467 == GeomType_Circle); return static_cast<int32_t>(___1553->___2503); } void ___4017::___1575(GeomID_t ___1804, double* ___1823, double* ___4394) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_Ellipse); REQUIRE(___1553->___2465.size() == 1); REQUIRE(___1553->___2465.size() == 1); *___1823 = ___1553->___2465[0][0].x(); *___4394 = ___1553->___2465[0][0].___4583(); } void ___4017::___1589(GeomID_t ___1804, double* ___4574, double* ___4591, double* ___4715) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); *___4574 = ___1553->___2618[0]; *___4591 = ___1553->___2618[1]; *___4715 = ___1553->___2618[2]; } Clipping_e ___4017::___1591(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2395; } ___514 ___4017::___1592(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2396; } DrawOrder_e ___4017::___1593(GeomID_t  ) const
{ return ___1112; } ___514 ___4017::___1594(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2463; } ___372 ___4017::___1595(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2487; } LinePattern_e ___4017::___1596(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2490; } double ___4017::___1597(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2491; } ___372 ___4017::___1598(GeomID_t ___1804, char** macroFunctionCmd) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); *macroFunctionCmd = copyString(___1553->___2492); return ___4227; } GeomID_t ___4017::___1599(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); size_t nextIndex = std::distance(&m_tecioData.geoms()[0], ___1553) + 1; if (nextIndex == m_tecioData.geoms().size()) return ___4036; return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[nextIndex]); } double ___4017::___1600(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2616; } CoordSys_e ___4017::___1601(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2617; } GeomID_t ___4017::___1602(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); size_t geomIndex = std::distance(&m_tecioData.geoms()[0], ___1553); if (geomIndex == 0) return ___4036; return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[geomIndex - 1]); } Scope_e ___4017::___1603(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2620; } GeomForm_e ___4017::___1604(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2467; } ___4636 ___4017::___1605(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2678; } ___372 ___4017::___1608(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); return ___1553->___2485; } ___2226 ___4017::___1617(GeomID_t ___1804, int32_t ___3158) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_LineSegs); REQUIRE(0 < ___3158 && ___3158 <= (int32_t)___1553->___2465.size()); return (___2226)___1553->___2465[___3158 - 1].size(); } ___2226 ___4017::___1618(GeomID_t ___1804) const
{ ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_LineSegs); return (___2226)___1553->___2465.size(); } ___2226 ___4017::___1624(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_LineSegs); REQUIRE(___1553->___2465.size() == 1); return (___2226)___1553->___2465[0].size(); } void ___4017::___1626(GeomID_t ___1804, double* ___4458, double* ___1825) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_Rectangle); REQUIRE(___1553->___2465.size() == 1); *___4458 = ___1553->___2465[0][0].x(); *___1825 = ___1553->___2465[0][0].___4583(); } double ___4017::___1647(GeomID_t ___1804) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1804); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2467 == GeomType_Square); REQUIRE(___1553->___2465.size() == 1); return ___1553->___2465[0][0].x(); } ___514 ___4017::___4065(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2629; } ___514 ___4017::___4066(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2630; } double ___4017::___4067(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2631; } double ___4017::___4068(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2632; } TextBox_e ___4017::___4069(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2633; } TextAnchor_e ___4017::___4085(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2626; } void ___4017::___4086(TextID_t ___4172, double* ___4574, double* ___4591, double* ___4715) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); REQUIRE(VALID_REF(___4574)); REQUIRE(VALID_REF(___4591)); REQUIRE(VALID_REF(___4715)); *___4574 = ___4043->___2627[0]; *___4591 = ___4043->___2627[1]; *___4715 = ___4043->___2627[2]; } double ___4017::___4087(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2628; } Clipping_e ___4017::___4089(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2634; } ___514 ___4017::___4090(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2635; } double ___4017::___4091(TextID_t ___4172) const
{ Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2636; } double ___4017::___4092(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2638; } ___372 ___4017::___4093(TextID_t ___4172, char** ___2331) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); REQUIRE(VALID_REF(___2331)); if (!___4043->___2639.empty()) { *___2331 = copyString(___4043->___2639); return ___4227; } return ___1303; } TextID_t ___4017::___4094(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); size_t nextIndex = std::distance(&m_tecioData.texts()[0], ___4043) + 1; if (nextIndex == m_tecioData.texts().size()) return ___4036; return reinterpret_cast<TextID_t>(&m_tecioData.texts()[nextIndex]); } CoordSys_e ___4017::___4095(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2640; } TextID_t ___4017::___4096(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); size_t textIndex = std::distance(&m_tecioData.texts()[0], ___4043); if (textIndex == 0) return ___4036; return reinterpret_cast<TextID_t>(&m_tecioData.texts()[textIndex - 1]); } Scope_e ___4017::___4097(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2642; } Units_e ___4017::___4098(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2643; } ___372 ___4017::___4099(TextID_t ___4172, char** ___4127) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); REQUIRE(VALID_REF(___4127)); if (!___4043->___2644.empty()) { *___4127 = copyString(___4043->___2644); return ___4227; } return ___1303; } char* ___4017::___4100(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return copyString(___4043->___2645); } ___372 ___4017::___4101(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2646; } ___372 ___4017::___4102(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2647; } ___4636 ___4017::___4103(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2648; } ___372 ___4017::___4106(TextID_t ___4172) const { Text const* ___4043 = reinterpret_cast<Text*>(___4172); REQUIRE(VALID_REF(___4043)); return ___4043->___2637; } ___372 ___4017::___4305(___1359 ASSERT_ONLY(___1349)) const
{ REQUIRE(VALID_REF(___1349)); return ___4227; } ___372 ___4017::___4310(___2728 ASSERT_ONLY(___2724)) const { REQUIRE(VALID_REF(___2724)); return ___4227; } PlotType_e ___4017::___1511() const { return ___3116; } ___2665 ___4017::___4153() { return new ___2666; } void ___4017::___4154(___2665* mutex) { delete *mutex; *mutex = NULL; } void ___4017::___4155(___2665 mutex) {
 #if defined TECIOMPI
___476(___1303); ___4279(mutex);
 #else
mutex->lock();
 #endif
} void ___4017::___4156(___2665 mutex) {
 #if defined TECIOMPI
___4279(mutex);
 #else
mutex->unlock();
 #endif
} void ___4017::___4157(___4161 ___2117, ___90 ___2122, ___2119 ___2118) {
 #if defined TECIOMPI
___4279(___2118); ___2117(___2122);
 #else
___2118->addJob(___2117, ___2122);
 #endif
} int ___4017::___4158() {
 #if defined TECIOMPI
return 1;
 #else
return ___2121::___2828();
 #endif
} ___2119 ___4017::___4159() { return new ___2121; } void ___4017::___4160(___2119* ___2118) { delete *___2118; *___2118 = NULL; } void ___4017::___4162(___2119 ___2118) {
 #if defined TECIOMPI
___4279(___2118);
 #else
___2118->wait();
 #endif
} int32_t ___4017::datasetGetNumPartitionFiles() const { return 0; } int32_t ___4017::zoneGetOwnerProcess(tecplot::___3934::___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(!zoneIsPartitioned(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); ___476(IMPLICATION(!zonePtr->m_partitionOwners.empty(), zonePtr->m_partitionOwners.size() == 1)); if (zonePtr->m_partitionOwners.empty()) return 0; return zonePtr->m_partitionOwners[0]; } int32_t ___4017::zonePartitionGetOwnerProcess(tecplot::___3934::___4636 ___4658, tecplot::___3934::___4636 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); ___476(IMPLICATION(!zonePtr->m_partitionOwners.empty(), static_cast<size_t>(partitionNum) <= zonePtr->m_partitionOwners.size())); if (zonePtr->m_partitionOwners.empty()) return 0; return zonePtr->m_partitionOwners[partitionNum - 1]; } ___372 ___4017::zoneIsPartitioned(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); if (zonePtr->m_partitionOwners.empty()) return zonePtr->m_partitionMap.empty() ? ___1303 : ___4227; return (zonePtr->m_partitionOwners.size() > 1); } ___4636 ___4017::zoneGetNumPartitions(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); if (zonePtr->m_partitionOwners.empty()) return static_cast<___4636>(zonePtr->m_partitionMap.size()); return static_cast<___4636>(zonePtr->m_partitionOwners.size()); } namespace { Zone_s* getPartitionPtr(Zone_s::ZoneMap const& partitionMap, ___4636 partitionNum) { REQUIRE(partitionNum > 0); Zone_s::ZoneMap::const_iterator it = partitionMap.find(partitionNum - 1); if (it == partitionMap.end()) return NULL; else return it->second.get(); } } ___372 ___4017::zonePartitionGetSectionMetrics( ___4265 ASSERT_ONLY(dataSetID), ___4636 ___4658, ___4636 partitionNum, ___1170 section, FECellShape_e* cellShape, ___1170* gridOrder, FECellBasisFunction_e* basisFn, ___2226* numElements, ___1170* numCornersPerElem, ___1170* numNodesPerElem) const { REQUIRE(dataSetID == 0); REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(___4620(___4658) != ___4704 && ___4620(___4658) != ___4698 && ___4620(___4658) != ___4699); ASSERT_ONLY(___1170 numSections = 0); REQUIRE(zoneGetNumSections(dataSetID, ___4658, &numSections) && section <= numSections); REQUIRE(VALID_REF(cellShape)); REQUIRE(VALID_REF(gridOrder)); REQUIRE(VALID_REF(basisFn)); REQUIRE(VALID_REF(numElements)); Zone_s const* const zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return getSectionMetrics( *partitionPtr, section-1, *cellShape, *gridOrder, *basisFn, *numElements, *numCornersPerElem, *numNodesPerElem);
} void ___4017::zonePartitionGetIJK(___4636 ___4658, ___4636 partitionNum, ___1843& ___1860) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___1860 = partitionPtr->___2683; } void ___4017::zonePartitionGetIJKOffset(tecplot::___3934::___4636 ___4658, tecplot::___3934::___4636 partitionNum, tecplot::___3934::___1843& ___1861) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(___4641(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___476(partitionPtr != NULL); ___1861 = partitionPtr->m_partitionOffset; } ___372 ___4017::dataValueGetMinMaxByZonePartitionVar( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4336, double* minVal, double* maxVal) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4336 && ___4336 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4336); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); partitionPtr->___2497[___4336 - 1]->___1758(*minVal, *maxVal); return ___4227; } ___1359 ___4017::dataValuePartitionGetReadableNLRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); REQUIRE(zonePtr != NULL); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___476(partitionPtr != NULL); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); if (partitionPtr->___2497[___4368 - 1]->___2670 == ___4330) return dataValuePartitionGetReadableNativeRef(___4658, partitionNum, ___4368); else return dataValuePartitionGetReadableDerivedRef(___4658, partitionNum, ___4368); } ___1359 ___4017::dataValuePartitionGetReadableCCRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); if (partitionPtr->___2497[___4368 - 1]->___2670 == ___4328)
return dataValuePartitionGetReadableNativeRef(___4658, partitionNum, ___4368); else return dataValuePartitionGetReadableDerivedRef(___4658, partitionNum, ___4368); } ___1359 ___4017::dataValuePartitionGetReadableNativeRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return toTecUtilFieldData(partitionPtr->___2497[___4368 - 1].get()); } ___1359 ___4017::dataValuePartitionGetReadableDerivedRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); Zone_s* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); try { if (partitionPtr->___2401[___4368 - 1]->storedValueCount() == 0) { Zone_s* connectivityZonePtr = m_tecioData.zonePtrForConnectivity(___4658); Zone_s* connectivityPartitionPtr = getPartitionPtr(connectivityZonePtr->m_partitionMap, partitionNum); if (partitionPtr->___2497[___4368 - 1]->___2670 == ___4328) partitionPtr->___963(___4368, connectivityPartitionPtr->___2498.get()); else partitionPtr->deriveCCValues(___4368, connectivityPartitionPtr->___2498.get()); } } catch (std::exception const&) { } return toTecUtilFieldData(partitionPtr->___2401[___4368 - 1].get()); } ___1359 ___4017::dataValuePartitionGetWritableNativeRef( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); return dataValuePartitionGetReadableNativeRef(___4658, partitionNum, ___4368); } void ___4017::dataValuePartitionGetReadableRawPtr( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368, void** ___878, FieldDataType_e* ___1361) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4658, ___4368); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); *___878 = partitionPtr->___2497[___4368 - 1]->getRawPointer();
*___1361 = partitionPtr->___2497[___4368 - 1]->___2460; } void ___4017::dataValuePartitionGetWritableRawPtr( ___4636 ___4658, ___4636 partitionNum, ___4352 ___4368, void** ___878, FieldDataType_e* ___1361) const { dataValuePartitionGetReadableRawPtr(___4658, partitionNum, ___4368, ___878, ___1361); } ___2728 ___4017::dataNodePartitionGetReadableRef( ___4636 ___4658, ___4636 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return toTecUtilNodeMap(partitionPtr->___2498.get()); } ___2728 ___4017::dataNodePartitionGetWritableRef( ___4636 ___4658, ___4636 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); return dataNodePartitionGetReadableRef(___4658, partitionNum); } ___2743 ___4017::dataNodeToElemMapPartitionGetReadableRef( tecplot::___3934::___4636 ___4658, tecplot::___3934::___4636 partitionNum ) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4658); Zone_s* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); if (!partitionPtr->m_nodeToElemMap) partitionPtr->m_nodeToElemMap.reset(new ___2744(*partitionPtr->___2498, partitionPtr->___2683.___1669())); return toTecUtilNodeToElemMap(partitionPtr->m_nodeToElemMap.get()); } GhostInfo_pa ___4017::zoneGhostNodeInfoGetRef(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return &zonePtr->m_ghostNodeInfo; } GhostInfo_pa ___4017::zoneGhostCellInfoGetRef(___4636 ___4658) const { REQUIRE(m_tecioData.validZoneNum(___4658)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); return &zonePtr->m_ghostCellInfo; } GhostInfo_pa ___4017::zonePartitionGhostNodeInfoGetRef( tecplot::___3934::___4636 ___4658, tecplot::___3934::___4636 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return &partitionPtr->m_ghostNodeInfo; } GhostInfo_pa ___4017::zonePartitionGhostCellInfoGetRef(tecplot::___3934::___4636 ___4658, tecplot::___3934::___4636 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4658)); REQUIRE(zoneIsPartitioned(___4658)); REQUIRE(m_tecioData.validPartitionNum(___4658, partitionNum));
Zone_s const* zonePtr = m_tecioData.zonePtr(___4658); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return &partitionPtr->m_ghostCellInfo; } ___81 ___4017::ghostInfoGetNumItemsByRef( GhostInfo_pa ghostInfo, ___1170   sectionIndex) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(ghostInfo->m_items.empty() || (1 <= sectionIndex && sectionIndex <= checked_numeric_cast<___1170>(ghostInfo->m_baseOffsetPerSection.size()))); if (ghostInfo->m_items.empty()) return static_cast<___81>(0); else return sectionIndex < checked_numeric_cast<___1170>(ghostInfo->m_baseOffsetPerSection.size()) ? static_cast<___81>(ghostInfo->m_baseOffsetPerSection[sectionIndex] - ghostInfo->m_baseOffsetPerSection[sectionIndex-1]) : static_cast<___81>(ghostInfo->m_items.size() - ghostInfo->m_baseOffsetPerSection[sectionIndex-1]); } ___81 ___4017::ghostInfoGetItemByRef( GhostInfo_pa ghostInfo, ___1170   sectionIndex, ___81   itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(1 <= sectionIndex && sectionIndex <= checked_numeric_cast<___1170>(ghostInfo->m_baseOffsetPerSection.size())); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_items.size())); return static_cast<___81>(ghostInfo->m_items[ghostInfo->m_baseOffsetPerSection[sectionIndex-1] + itemNum-1]); } ItemAddress64::___2981 ___4017::ghostInfoGetNeighborByRef( GhostInfo_pa ghostInfo, ___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_neighbors.size())); return ghostInfo->m_neighbors[itemNum - 1]; } ___81 ___4017::ghostInfoGetNeighborItemByRef( GhostInfo_pa ghostInfo, ___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_neighborItems.size())); return static_cast<___81>(ghostInfo->m_neighborItems[itemNum - 1]); } }}
