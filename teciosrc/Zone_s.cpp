#include "Zone_s.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <array>
#include <limits>
#include <sstream>
#include <boost/make_shared.hpp>
#include <boost/scoped_array.hpp>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData_s.h"
 #if !defined TECIOMPI
#include "JobControl_s.h"
 #endif
#include "TecioData.h"
#include "feCellTypeMetrics.h"
#include "zoneUtil.h"
using namespace tecplot::___3934; namespace tecplot { namespace tecioszl { namespace {
 #define MIN_NODES_FOR_MULTITHREAD 100000 
 #define MIN_CELLS_FOR_MULTITHREAD 50000 
void getZoneCounts(int64_t& nodeCount, int64_t& cellCount, ___1843 const& zoneSize, ZoneType_e ___4692) { if (___4692 == ___4704) { nodeCount = (int64_t)zoneSize.i() * zoneSize.___2104() * zoneSize.___2133(); ___81 iMax = zoneSize.i(); ___81 jMax = zoneSize.___2104(); ___81 kMax = zoneSize.___2133(); if (kMax > 1) --kMax; else if (jMax > 1) --jMax; else if (iMax > 1) --iMax; cellCount = (int64_t)iMax * jMax * kMax; } else { nodeCount = (int64_t)zoneSize.i(); cellCount = (int64_t)zoneSize.___2104(); } } } Zone_s::Zone_s( std::string const& ___4690, ZoneType_e ___4692, int64_t iMin, int64_t jMin, int64_t kMin, int64_t ___1908, int64_t ___2115, int64_t ___2160, std::vector<FECellShape_e> const& cellShapes, std::vector<int32_t> const& gridOrders, std::vector<FECellBasisFunction_e> const& basisFns, std::vector<int64_t> const& numElementsPerSection, double ___3641, int32_t ___3786, ___1170 ___2975, int64_t ___2803, FaceNeighborMode_e ___1282, int64_t ___4193, int64_t ___2787, int64_t ___4189, std::vector<FieldDataType_e> const& ___1370, std::vector<int> const& passiveVarVector, std::vector<ValueLocation_e> const& ___4326, std::vector<___1170> const& shareVarFromZoneVector, ___1170 ___3550) : ___2684(___4690) , ___2685(___4692) , m_zoneDimension(-1) , m_partitionOffset((___81)(iMin - 1), (___81)(jMin - 1), (___81)(kMin - 1)) , ___2683((___81)(___1908 - iMin + 1), (___81)(___2115 - jMin + 1), (___81)(___2160 - kMin + 1)) , ___2622(___3641) , ___2623(___3786) , ___2615(___2975) , ___2504(___2803) , ___2459(___1282) , ___2652(___4193) , ___2502(___2787) , ___2651(___4189) , ___2461(___1370) , m_passiveVars(passiveVarVector) , ___2671(___4326) , m_shareVarFromZone(shareVarFromZoneVector) , m_shareConnectivityFromZone(___3550) , ___2398(static_cast<size_t>(-1)) , ___2346(new AuxData_s) { REQUIRE(___4690.size() > 0); REQUIRE(VALID_ENUM(___4692, ZoneType_e)); REQUIRE(iMin > 0); REQUIRE(jMin > 0); REQUIRE(kMin > 0); REQUIRE(0 < ___1908); REQUIRE(0 < ___2115); REQUIRE(IMPLICATION(___4692 == ___4704 || ___4692 == ___4698 || ___4692 == ___4699, 0 < ___2160)); REQUIRE(IMPLICATION(___4692 == ZoneType_FEMixed, cellShapes.size() == gridOrders.size() && cellShapes.size() == basisFns.size() && cellShapes.size() == numElementsPerSection.size() )); REQUIRE("solutionTime can be anything"); REQUIRE(0 <= ___3786); REQUIRE(0 <= ___2975); REQUIRE(0 <= ___2803); REQUIRE(___2671.size() > 0); REQUIRE(VALID_ENUM(___1282, FaceNeighborMode_e) || ___1282 == ___1286);
REQUIRE(IMPLICATION(___4692 == ___4699, 0 <= ___4193)); REQUIRE(IMPLICATION(___4692 == ___4699 || ___4692 == ___4698, 0 <= ___2787)); REQUIRE(IMPLICATION(___4692 == ___4699 || ___4692 == ___4698, 0 <= ___4189)); try { int64_t nodeCount; int64_t cellCount; getZoneCounts(nodeCount, cellCount, ___2683, ___2685); if (___2685 == ___4704) { std::array<int64_t,3> const dims = {___2683.i(), ___2683.___2104(), ___2683.___2133()}; m_zoneDimension = checked_numeric_cast<int32_t>( std::count_if(dims.begin(),dims.end(),[](int64_t dim){return dim > 1;})); if (m_zoneDimension == 0) m_zoneDimension = 1; } else if (___2685 == ZoneType_FEMixed) { m_cellShapes.resize(cellShapes.size()); m_gridOrders.resize(gridOrders.size()); m_basisFns.resize(basisFns.size()); m_numElementsPerSection.resize(numElementsPerSection.size()); for (std::vector<FECellShape_e>::size_type sec=0; sec<cellShapes.size(); ++sec) { m_cellShapes[sec] = cellShapes[sec]; m_gridOrders[sec] = gridOrders[sec]; m_basisFns[sec] = basisFns[sec]; m_numElementsPerSection[sec] = numElementsPerSection[sec]; } m_zoneDimension = feMixedZoneDimension(m_cellShapes[0]); } else { if (___2685 == ___4696) ___2683.___3498(2); else if (___2685 == ___4702) ___2683.___3498(3); else if (___2685 == ___4700 || ___2685 == ___4701) ___2683.___3498(4); else if (___2685 == ___4695) ___2683.___3498(8); else {___476(___2685 == ___4698 || ___2685 == ___4699);} m_zoneDimension = feNonMixedZoneDimension(___2685); } ___2497.resize(___2671.size()); ___2401.resize(___2671.size()); std::set<___3494> zoneSet; ___1170 numVarsShared = 0; for(size_t ___4292 = 0; ___4292 < ___2671.size(); ++___4292) { ___2497[___4292] = TypedFieldDataFactory().make(___2461[___4292]); ___2401[___4292] = TypedFieldDataFactory().make(___2461[___4292]); if (m_passiveVars[___4292] == 0 && m_shareVarFromZone[___4292] == 0) { if (___2398 == static_cast<size_t>(-1)) ___2398 = ___4292; if (___2671[___4292] == ___4330) { ___2497[___4292]->___2670 = ___4330; ___2497[___4292]->___2669 = nodeCount; ___2401[___4292]->___2670 = ___4328; ___2401[___4292]->___2669 = cellCount; } else { ___2497[___4292]->___2670 = ___4328; ___2497[___4292]->___2669 = cellCount; ___2401[___4292]->___2670 = ___4330; ___2401[___4292]->___2669 = nodeCount; } } } m_allVarsAreShared = numVarsShared == static_cast<___1170>(___2671.size()); if (!m_shareConnectivityFromZone && ___2685 != ___4704) { if (___2685 == ZoneType_FEMixed) { std::vector<int32_t> numNodesPerCellPerSection; numNodesPerCellPerSection.resize(cellShapes.size());
for (size_t section=0; section < cellShapes.size(); ++section) { ___1170 numEdges; ___1170 numFacesOrEdges; ___1170 ___2790; ___1170 ___2822; ___1170 numHighOrderNodes; ___1170 numNaturalSubElems; ___1170 const MAX_NUM_FACES_PER_ELEM = 6; std::vector<___1170> numCornersPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numHighOrderNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); tecplot::feCellTypeMetrics( m_cellShapes[section], m_gridOrders[section], FECellBasisFunction_Lagrangian, numEdges, numFacesOrEdges, ___2790, ___2822, numHighOrderNodes, numNaturalSubElems, numCornersPerFaceOrEdge.begin(), numNodesPerFaceOrEdge.begin(), numHighOrderNodesPerFaceOrEdge.begin()); numNodesPerCellPerSection[section] = ___2822; } ___2498 = ___2731::makePtr(___2683.___1669(), m_numElementsPerSection, numNodesPerCellPerSection); } else { ___2498 = ___2731::makePtr( ___2683.___1669(), ___2115, ___2683.___1668()); } } } catch (std::bad_alloc const&) { std::cerr << "Failed to allocate sufficient resources to create zone.\n"; throw; } } Zone_s::Zone_s( Zone_s const* partitionParent, int64_t iMin, int64_t jMin, int64_t kMin, int64_t ___1908, int64_t ___2115, int64_t ___2160) { REQUIRE(VALID_REF(partitionParent)); REQUIRE(iMin > 0); REQUIRE(jMin > 0); REQUIRE(kMin > 0); REQUIRE(___1908      <= partitionParent->___2683.i()); REQUIRE(___2115 <= partitionParent->___2683.___2104()); REQUIRE(___2160    <= partitionParent->___2683.___2133()); REQUIRE(___1908 > iMin); REQUIRE(___2115 > jMin); REQUIRE(___2160 > kMin); *this = Zone_s(partitionParent->___2684, partitionParent->___2685, iMin, jMin, kMin, ___1908, ___2115, ___2160, partitionParent->m_cellShapes, partitionParent->m_gridOrders, partitionParent->m_basisFns, partitionParent->m_numElementsPerSection, partitionParent->___2622, partitionParent->___2623, partitionParent->___2615, 0, partitionParent->___2459, 0, 0, 0, partitionParent->___2461, partitionParent->m_passiveVars, partitionParent->___2671, partitionParent->m_shareVarFromZone, partitionParent->m_shareConnectivityFromZone); } namespace { struct FENodalValueDerivationData { ___2719 begin; ___2719 end; ___1360* nativeFieldData; ___1360* derivedFieldData; ___2744* nodeToElemMap; double minVal; double maxVal; FENodalValueDerivationData(___2719 begin, ___2719 end, ___1360* nativeFieldData, ___1360* derivedFieldData, ___2744* nodeToElemMap) : begin(begin) , end(end) , nativeFieldData(nativeFieldData) , derivedFieldData(derivedFieldData) , nodeToElemMap(nodeToElemMap) , minVal(std::numeric_limits<double>::max()) , maxVal(-std::numeric_limits<double>::max()) {} }; inline double getValueFromTypedRawPtr(void* rawPtr, int64_t index, FieldDataType_e type)
{ REQUIRE(VALID_REF(rawPtr)); REQUIRE(0 <= index); REQUIRE(VALID_ENUM(type, FieldDataType_e)); double value; switch(type) { case FieldDataType_Float: value = checked_numeric_cast<double>(((float*)(rawPtr))[index]); break; case FieldDataType_Double: value = ((double*)(rawPtr))[index]; break; case FieldDataType_Int32: value = checked_numeric_cast<double>(((int32_t*)(rawPtr))[index]); break; case FieldDataType_Int16: value = checked_numeric_cast<double>(((int16_t*)(rawPtr))[index]); break; case FieldDataType_Byte: value = checked_numeric_cast<double>(((uint8_t*)(rawPtr))[index]); break; case ___1363: value = checked_numeric_cast<double>((((uint8_t*)(rawPtr))[index / 8] >> (index % 8)) & 1); break; case ___1366: value = checked_numeric_cast<double>(((int64_t*)(rawPtr))[index]); break; default: ___476(___1303); value = 0.0; break; } return value; } inline void setValueToTypedRawPtr(void* rawPtr, int64_t index, FieldDataType_e type, double value) { REQUIRE(VALID_REF(rawPtr)); REQUIRE(0 <= index); REQUIRE(VALID_ENUM(type, FieldDataType_e)); switch(type) { case FieldDataType_Float: ((float*)(rawPtr))[index] = checked_numeric_cast<float>(value); break; case FieldDataType_Double: ((double*)(rawPtr))[index] = value; break; case FieldDataType_Int32: ((int32_t*)(rawPtr))[index] = checked_numeric_cast<int32_t>(value); break; case FieldDataType_Int16: ((int16_t*)(rawPtr))[index] = checked_numeric_cast<int16_t>(value); break; case FieldDataType_Byte: ((uint8_t*)(rawPtr))[index] = checked_numeric_cast<uint8_t>(value); break; case ___1363: if (value < 1.0) { value = 0.0; ((uint8_t *)(rawPtr))[index / 8] &= ~(checked_numeric_cast<uint8_t>(01) << (index % 8)); } else { value = 1.0; ((uint8_t *)(rawPtr))[index / 8] |= checked_numeric_cast<uint8_t>(01) << (index % 8); } break; case ___1366: ((int64_t*)(rawPtr))[index] = checked_numeric_cast<int64_t>(value); break; default: ___476(___1303); break; } } void deriveRangeOfNodalValues(___90 threadData) { FENodalValueDerivationData* derivationData = reinterpret_cast<FENodalValueDerivationData*>(threadData); REQUIRE(derivationData->derivedFieldData->___2460 == derivationData->nativeFieldData->___2460); void* rawCCPtr = derivationData->nativeFieldData->getRawPointer(); void* rawNodalPtr = derivationData->derivedFieldData->getRawPointer(); FieldDataType_e ___1361 = derivationData->nativeFieldData->___2460; for(___2719 ___2710 = derivationData->begin; ___2710 < derivationData->end; ++___2710) { double value = 0.0; ___463 startingIndex = derivationData->nodeToElemMap->m_elemIndex[___2710]; ___463 howManyCells = derivationData->nodeToElemMap->cellCountForNode(___2710); for(___463 whichCell = 0; whichCell < howManyCells; ++whichCell) { ___463 ___447 = derivationData->nodeToElemMap->m_elem[startingIndex + whichCell]; value += getValueFromTypedRawPtr(rawCCPtr, ___447, ___1361); } value /= howManyCells; setValueToTypedRawPtr(rawNodalPtr, ___2710, ___1361, value);
derivationData->minVal = std::min(derivationData->minVal, value); derivationData->maxVal = std::max(derivationData->maxVal, value); } } } void Zone_s::___963(___4352 ___4368, ___2731* ___2724) { REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(___2497.size())); REQUIRE(___2497[___4368 - 1]->___2670 == ___4328); ___1360::Ptr nativeFieldData = ___2497[___4368 - 1]; ___1360::Ptr derivedFieldData = ___2401[___4368 - 1]; derivedFieldData->assignValues(derivedFieldData->___2669, 0.0); if (___2685 == ___4704) { boost::scoped_array<uint16_t> divisor(new uint16_t[derivedFieldData->___2669]); for(size_t i = 0; i < derivedFieldData->___2669; ++i) divisor[i] = 0; int64_t const ___459 = std::max(int64_t(1), (int64_t)(___2683.i() - 1)); int64_t const ___464 = std::max(int64_t(1), (int64_t)(___2683.___2104() - 1)); int64_t const ___465 = std::max(int64_t(1), (int64_t)(___2683.___2133() - 1)); int64_t const nodeIMax = ___2683.i(); int64_t const nodeJMax = ___2683.___2104(); int64_t const nodeKMax = ___2683.___2133(); std::vector<int64_t> nodes; for (int64_t i = 0; i < ___459; ++i) { for (int64_t ___2104 = 0; ___2104 < ___464; ++___2104) { for (int64_t ___2133 = 0; ___2133 < ___465; ++___2133) { int64_t const index = (___2133 * nodeJMax + ___2104) * nodeIMax + i; nodes.resize(0); nodes.push_back(index); if (nodeIMax > 1) { nodes.push_back(index + 1); } if (nodeJMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax); } } if (nodeKMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax * nodeJMax); } } for(size_t n = 0; n < nodes.size(); ++n) { derivedFieldData->___3505(nodes[n], derivedFieldData->___1779(nodes[n]) + nativeFieldData->___1779(index)); ++divisor[nodes[n]]; } } } } for(size_t n = 0; n < derivedFieldData->storedValueCount(); ++n) derivedFieldData->___3505((___81)n, derivedFieldData->___1779(n) / (double)divisor[n]); } else { ___476(VALID_REF(___2724)); if (!m_nodeToElemMap) m_nodeToElemMap.reset(new ___2744(*___2724, ___2683.___1669()));
 #if !defined TECIOMPI
int numThreads = 1; if (m_nodeToElemMap->m_nodeCount >= MIN_NODES_FOR_MULTITHREAD) numThreads = std::min(___2121::___2828(), checked_numeric_cast<int>((m_nodeToElemMap->m_nodeCount - 1) / MIN_NODES_FOR_MULTITHREAD + 1)); if (numThreads == 1) {
 #endif
FENodalValueDerivationData derivationData(0, ___2683.___1669(), nativeFieldData.get(), derivedFieldData.get(), m_nodeToElemMap.get()); deriveRangeOfNodalValues((___90)&derivationData); derivedFieldData->___3500(derivationData.minVal, derivationData.maxVal);
 #if !defined TECIOMPI
} else { std::vector<boost::shared_ptr<FENodalValueDerivationData> > nodalDerivationData; for(int i = 0; i < numThreads; ++i) { ___2719 const begin = static_cast<___2719>((size_t)m_nodeToElemMap->m_nodeCount * i / numThreads); ___2719 const end = static_cast<___2719>((size_t)m_nodeToElemMap->m_nodeCount * (i + 1) / numThreads); nodalDerivationData.push_back(boost::make_shared<FENodalValueDerivationData>( begin, end, nativeFieldData.get(), derivedFieldData.get(), m_nodeToElemMap.get())); } ___2121 ___2118; for(int i = 0; i < numThreads; ++i) ___2118.addJob(deriveRangeOfNodalValues, reinterpret_cast<___90>(nodalDerivationData[i].get())); ___2118.wait(); double minVal = std::numeric_limits<double>::max(); double maxVal = -std::numeric_limits<double>::max(); for(int i = 0; i < numThreads; ++i) { minVal = std::min(minVal, nodalDerivationData[i]->minVal); maxVal = std::max(maxVal, nodalDerivationData[i]->maxVal); } derivedFieldData->___3500(minVal, maxVal); }
 #endif
} } namespace { struct FECCValueDerivationData { int64_t begin; int64_t end; ___1360* nativeFieldData; ___1360* derivedFieldData; ___2731* ___2724; int32_t section; double minVal; double maxVal; FECCValueDerivationData(int64_t begin, int64_t end, ___1360* nativeFieldData, ___1360* derivedFieldData, ___2731* ___2724, int32_t section) : begin(begin) , end(end) , nativeFieldData(nativeFieldData) , derivedFieldData(derivedFieldData) , ___2724(___2724) , section(section) , minVal(std::numeric_limits<double>::max()) , maxVal(-std::numeric_limits<double>::max()) {} }; void deriveRangeOfCCValues(___90 threadData) { FECCValueDerivationData* derivationData = reinterpret_cast<FECCValueDerivationData*>(threadData); REQUIRE(derivationData->derivedFieldData->___2460 == derivationData->nativeFieldData->___2460); void* rawNodalPtr = derivationData->nativeFieldData->getRawPointer(); void* rawCCPtr = derivationData->derivedFieldData->getRawPointer(); FieldDataType_e ___1361 = derivationData->nativeFieldData->___2460; for(int64_t ___447 = derivationData->begin; ___447 < derivationData->end; ++___447) { double value = 0.0; CellNodeIndex_t ___2822 = checked_numeric_cast<CellNodeIndex_t>(derivationData->___2724->m_numNodesPerCellPerSection[derivationData->section]); for(CellNodeIndex_t ___2710 = 0; ___2710 < ___2822; ++___2710) { int64_t nodeValue = derivationData->___2724->value(derivationData->section, ___447 * ___2822 + ___2710); value += getValueFromTypedRawPtr(rawNodalPtr, nodeValue, ___1361); } value /= ___2822; setValueToTypedRawPtr(rawCCPtr, ___447, ___1361, value); derivationData->minVal = std::min(derivationData->minVal, value); derivationData->maxVal = std::max(derivationData->maxVal, value); } } } void Zone_s::deriveCCValues(___4352 ___4368, ___2731* ___2724) { REQUIRE(0 < ___4368 && ___4368 <= static_cast<___4352>(___2497.size())); REQUIRE(___2497[___4368 - 1]->___2670 == ___4330); ___1360::Ptr nativeFieldData = ___2497[___4368 - 1]; ___1360::Ptr derivedFieldData = ___2401[___4368 - 1]; derivedFieldData->assignValues(derivedFieldData->___2669, 0.0); if (___2685 == ___4704) { int64_t const ___459 = std::max(int64_t(1), (int64_t)(___2683.i() - 1)); int64_t const ___464 = std::max(int64_t(1), (int64_t)(___2683.___2104() - 1)); int64_t const ___465 = std::max(int64_t(1), (int64_t)(___2683.___2133() - 1)); int64_t const nodeIMax = ___2683.i(); int64_t const nodeJMax = ___2683.___2104(); int64_t const nodeKMax = ___2683.___2133(); std::vector<int64_t> nodes; for (int64_t i = 0; i < ___459; ++i) { for (int64_t ___2104 = 0; ___2104 < ___464; ++___2104) { for (int64_t ___2133 = 0; ___2133 < ___465; ++___2133) { int64_t const index = (___2133 * nodeJMax + ___2104) * nodeIMax + i; nodes.resize(0); nodes.push_back(index); if (nodeIMax > 1) { nodes.push_back(index + 1); } if (nodeJMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax);
} } if (nodeKMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax * nodeJMax); } } double value = 0.0; for(size_t n = 0; n < nodes.size(); ++n) value += nativeFieldData->___1779(nodes[n]); derivedFieldData->___3505(index, value / nodes.size()); } } } } else { ___476(VALID_REF(___2724)); double minVal = std::numeric_limits<double>::max(); double maxVal = -std::numeric_limits<double>::max(); for (int32_t section = 0; section < checked_numeric_cast<int32_t>(___2724->m_numCellsPerSection.size()); ++section) { size_t ___2782 = ___2724->m_numCellsPerSection[section];
 #if !defined TECIOMPI
int numThreads = 1; if (___2782 >= MIN_CELLS_FOR_MULTITHREAD) { numThreads = std::min(___2121::___2828(), checked_numeric_cast<int>((___2782 - 1) / MIN_CELLS_FOR_MULTITHREAD + 1)); } if (numThreads == 1) {
 #endif
FECCValueDerivationData derivationData( 0, ___2782, nativeFieldData.get(), derivedFieldData.get(), ___2724, section); deriveRangeOfCCValues((___90)&derivationData); minVal = std::min(minVal, derivationData.minVal); maxVal = std::max(maxVal, derivationData.maxVal);
 #if !defined TECIOMPI
} else { std::vector<boost::shared_ptr<FECCValueDerivationData> > derivationData; for (int i = 0; i < numThreads; ++i) { ___463 const begin = static_cast<___463>((size_t)___2782 * i / numThreads); ___463 const end = static_cast<___463>((size_t)___2782 * (i + 1) / numThreads); derivationData.push_back(boost::make_shared<FECCValueDerivationData>( begin, end, nativeFieldData.get(), derivedFieldData.get(), ___2724, section)); } ___2121 ___2118; for (int i = 0; i < numThreads; ++i) { ___2118.addJob(deriveRangeOfCCValues, reinterpret_cast<___90>(derivationData[i].get())); } ___2118.wait(); for (int i = 0; i < numThreads; ++i) { minVal = std::min(minVal, derivationData[i]->minVal); maxVal = std::max(maxVal, derivationData[i]->maxVal); } }
 #endif
} derivedFieldData->___3500(minVal, maxVal); } } Zone_s::Zone_s() {} void Zone_s::writeToFile(FileWriterInterface& outputFile, bool ___4480) const { ___4544(outputFile, ___2684, ___4480); writeScalar(outputFile, (uint32_t)___2685, ___4480); writeScalar(outputFile, m_partitionOffset.i(), ___4480); writeScalar(outputFile, m_partitionOffset.___2104(), ___4480); writeScalar(outputFile, m_partitionOffset.___2133(), ___4480); writeScalar(outputFile, ___2683.i(), ___4480); writeScalar(outputFile, ___2683.___2104(), ___4480); writeScalar(outputFile, ___2683.___2133(), ___4480); writeScalar(outputFile, ___2622, ___4480); writeScalar(outputFile, ___2623, ___4480); writeScalar(outputFile, ___2615, ___4480); writeScalar(outputFile, ___2504, ___4480); writeScalar(outputFile, (uint32_t)___2459, ___4480); writeScalar(outputFile, ___2652, ___4480); writeScalar(outputFile, ___2502, ___4480); writeScalar(outputFile, ___2651, ___4480); std::vector<uint32_t>tempFieldDataTypes(___2461.begin(), ___2461.end()); writeVector(outputFile, tempFieldDataTypes, ___4480); writeVector(outputFile, m_passiveVars, ___4480); std::vector<uint32_t> tempValueLocations(___2671.begin(), ___2671.end()); writeVector(outputFile, tempValueLocations, ___4480); writeVector(outputFile, m_shareVarFromZone, ___4480); writeScalar(outputFile, m_shareConnectivityFromZone, ___4480); m_ghostNodeInfo.writeToFile(outputFile, ___4480); m_ghostCellInfo.writeToFile(outputFile, ___4480); writeVectorOfPtrs(outputFile, ___2497, ___4480); writeScalar(outputFile, (uint64_t)___2398, ___4480); if (___2685 != ___4704) ___2498->writeToFile(outputFile, ___4480); writeMapOfPairsToObjects(outputFile, ___2458, ___4480); ___2346->writeToFile(outputFile, ___4480); writeMapOfScalarsToPtrs(outputFile, m_partitionMap, ___4480); writeVector(outputFile, m_partitionOwners, ___4480); } uint64_t Zone_s::sizeInFile(bool ___4480) const { uint64_t sizeInFile = 0; sizeInFile += stringSizeInFile(___2684, ___4480); sizeInFile += scalarSizeInFile((uint32_t)___2685, ___4480); sizeInFile += scalarSizeInFile(m_partitionOffset.i(), ___4480); sizeInFile += scalarSizeInFile(m_partitionOffset.___2104(), ___4480); sizeInFile += scalarSizeInFile(m_partitionOffset.___2133(), ___4480); sizeInFile += scalarSizeInFile(___2683.i(), ___4480); sizeInFile += scalarSizeInFile(___2683.___2104(), ___4480); sizeInFile += scalarSizeInFile(___2683.___2133(), ___4480); sizeInFile += scalarSizeInFile(___2622, ___4480); sizeInFile += scalarSizeInFile(___2623, ___4480); sizeInFile += scalarSizeInFile(___2615, ___4480); sizeInFile += scalarSizeInFile(___2504, ___4480); sizeInFile += scalarSizeInFile((uint32_t)___2459, ___4480); sizeInFile += scalarSizeInFile(___2652, ___4480);
sizeInFile += scalarSizeInFile(___2502, ___4480); sizeInFile += scalarSizeInFile(___2651, ___4480); std::vector<uint32_t> tempFieldDataTypes(___2461.size()); sizeInFile += vectorSizeInFile(tempFieldDataTypes, ___4480); sizeInFile += vectorSizeInFile(m_passiveVars, ___4480); std::vector<uint32_t> tempValueLocations(___2671.size()); sizeInFile += vectorSizeInFile(tempValueLocations, ___4480); sizeInFile += vectorSizeInFile(m_shareVarFromZone, ___4480); sizeInFile += scalarSizeInFile(m_shareConnectivityFromZone, ___4480); sizeInFile += m_ghostNodeInfo.sizeInFile(___4480); sizeInFile += m_ghostCellInfo.sizeInFile(___4480); sizeInFile += vectorOfPtrsSizeInFile(___2497, ___4480); sizeInFile += scalarSizeInFile((uint64_t)___2398, ___4480); if (___2685 != ___4704) sizeInFile += ___2498->sizeInFile(___4480); sizeInFile += mapOfPairsToObjectsSizeInFile(___2458, ___4480); sizeInFile += ___2346->sizeInFile(___4480); sizeInFile += mapOfScalarsToPtrsSizeInFile(m_partitionMap, ___4480); sizeInFile += vectorSizeInFile(m_partitionOwners, ___4480); return sizeInFile; } boost::shared_ptr<Zone_s> Zone_s::makePtr(___1397& inputFile, bool readASCII) { Zone_s* newZone = new Zone_s; readString(inputFile, newZone->___2684, readASCII); READ_ENUM(newZone->___2685, ZoneType_e, inputFile, readASCII); ___81 i, ___2104, ___2133; readScalar(inputFile, i, readASCII); readScalar(inputFile, ___2104, readASCII); readScalar(inputFile, ___2133, readASCII); newZone->m_partitionOffset = ___1843(i, ___2104, ___2133); readScalar(inputFile, i, readASCII); readScalar(inputFile, ___2104, readASCII); readScalar(inputFile, ___2133, readASCII); newZone->___2683 = ___1843(i, ___2104, ___2133); readScalar(inputFile, newZone->___2622, readASCII); readScalar(inputFile, newZone->___2623, readASCII); readScalar(inputFile, newZone->___2615, readASCII); readScalar(inputFile, newZone->___2504, readASCII); READ_ENUM(newZone->___2459, FaceNeighborMode_e, inputFile, readASCII); readScalar(inputFile, newZone->___2652, readASCII); readScalar(inputFile, newZone->___2502, readASCII); readScalar(inputFile, newZone->___2651, readASCII); READ_ENUM_VECTOR(newZone->___2461, FieldDataType_e, inputFile, readASCII); readVector(inputFile, newZone->m_passiveVars, readASCII); READ_ENUM_VECTOR(newZone->___2671, ValueLocation_e, inputFile, readASCII); readVector(inputFile, newZone->m_shareVarFromZone, readASCII); readScalar(inputFile, newZone->m_shareConnectivityFromZone, readASCII); newZone->m_ghostNodeInfo = GhostInfo_s(inputFile, readASCII); newZone->m_ghostCellInfo = GhostInfo_s(inputFile, readASCII); readVectorOfPtrs(inputFile, newZone->___2497, readASCII); newZone->___2401.resize(newZone->___2497.size()); readScalar(inputFile, newZone->___2398, readASCII);
if (newZone->___2685 != ___4704) newZone->___2498 = ___2731::makePtr(inputFile, readASCII); readMapOfPairsToObjects(inputFile, newZone->___2458, readASCII); newZone->___2346 = AuxData_s::makePtr(inputFile, readASCII); readMapOfScalarsToPtrs(inputFile, newZone->m_partitionMap, readASCII); readVector(inputFile, newZone->m_partitionOwners, readASCII); int64_t nodeCount; int64_t cellCount; getZoneCounts(nodeCount, cellCount, newZone->___2683, newZone->___2685); for(size_t ___4292 = 0; ___4292 < newZone->___2401.size(); ++___4292) { newZone->___2401[___4292] = TypedFieldDataFactory().make(newZone->___2461[___4292]); if (newZone->___2671[___4292] == ___4330) { newZone->___2401[___4292]->___2670 = ___4328; newZone->___2401[___4292]->___2669 = cellCount; } else { newZone->___2401[___4292]->___2670 = ___4330; newZone->___2401[___4292]->___2669 = nodeCount; } } return boost::shared_ptr<Zone_s>(newZone); } }}
