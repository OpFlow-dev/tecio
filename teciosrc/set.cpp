#include "stdafx.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "CodeContract.h"
#include "ALLOC.h"
#include "SET.h"
 #define SetInitSize          (___2897(1,___3480))
 #define SetExpansionFactor   2
using tecplot::___4218; namespace { void ShiftSetForDelete( ___3503*     ___3477, ___3494 DeletePos); } namespace { ___3484* newSetData(___3494 ___2796) { REQUIRE(___2796 > 0 && ___2796 % ___3480 == 0); { return ___23(___2796 / ___3480, ___3484, "Set data"); } } } namespace { void deleteSetData(___3484* setData) { REQUIRE(VALID_REF(setData)); { ___1528(setData, "Set data"); } } }
 #if defined(_MSC_VER)
 #pragma optimize( "", off )
 #endif
___3503* ___29(___372 ___3575) { ___3503* ___3477 = ALLOC_ITEM(struct ___3503, "Set header"); if (___3477) { ___3477->size = SetInitSize; ___3477->data = newSetData(SetInitSize); if (___3477->data == NULL) ___937(&___3477); else ___491(___3477); } if ((___3477 == NULL) && ___3575) {
 #if defined(TECPLOTKERNEL)
 #if !defined UNITTEST
___1175(___4218("Out of memory for sets"));
 #endif
 #else
 #endif
} return ___3477; }
 #if defined(_MSC_VER)
 #pragma optimize( "", on )
 #endif
void ___937(___3503** ___3477) { if (___3477 && *___3477) { if ((*___3477)->data) deleteSetData((*___3477)->data); ___1529(*___3477, "Set header"); *___3477 = NULL; } } ___372 ___3497( void       *___2097, ___90  ___492) { ___3503** SetRef = (___3503**)___2097; REQUIRE(VALID_REF(SetRef)); REQUIRE(VALID_REF(*SetRef) || *SetRef == NULL); ___4279(___492); if (*SetRef != NULL) ___937(SetRef); ENSURE(*SetRef == NULL); return ___4227; } namespace { void copySetData( ___3484*       targetSetData, ___3484 const* sourceSetData, ___3494       sourceSetSize) { { size_t sourceSetSizeInBytes = sizeof(sourceSetData[0]) * (sourceSetSize / ___3480); memcpy(targetSetData, sourceSetData, sourceSetSizeInBytes); } } } namespace { void initSetData( ___3484* setData, ___3494 startMember, ___3494 numMembers) { { size_t startOffsetInBytes = sizeof(setData[0]) * (startMember / ___3480); size_t numBytesToInit     = sizeof(setData[0]) * (numMembers / ___3480); memset(((char*)setData) + startOffsetInBytes, 0, numBytesToInit); } } } ___372 ___1199( ___3503*     ___3477, ___3494 max_val, ___372  ___3575) { ___3484  *data; ___3494  new_size; REQUIRE(max_val >= 0); if (!___3477) { if (___3575) {
 #if defined(TECPLOTKERNEL)
 #if !defined UNITTEST
___1175(___4218("Null Set expand"));
 #endif
 #else
 #endif
} return ___1303; } if (max_val <= ___3477->size) return ___4227; new_size = ___3477->size; while (new_size < max_val) new_size *= SetExpansionFactor; new_size = ___2897(new_size, ___3480); data = newSetData(new_size); if (!data) { if (___3575) {
 #if defined(TECPLOTKERNEL)
 #if !defined UNITTEST
___1175(___4218("Out of memory for sets"));
 #endif
 #else
 #endif
} return ___1303; } copySetData(data, ___3477->data, ___3477->size); initSetData(data, ___3477->size, (new_size - ___3477->size)); deleteSetData(___3477->data); ___3477->data = data; ___3477->size = new_size; return ___4227; } ___372 ___674( ___3503*       ___1119, ___3503 const* ___3657, ___372    ___3575) { if (___1119 && ___1119->data && ___3657 && ___3657->data && ___1199(___1119, ___3657->size, ___3575)) { copySetData(___1119->data, ___3657->data, ___3657->size); if (___1119->size > ___3657->size) initSetData(___1119->data, ___3657->size, (___1119->size - ___3657->size)); return ___4227; } else return ___1303; } ___372 AllocAndCopySet( ___3503*&      ___1119, ___3503 const* ___3657) { ___372 ___2038 = ___4227; ___1119 = ___29(___1303); ___2038 = ___1119 != NULL && ___674(___1119,___3657,___1303); if (!___2038) ___937(&___1119); ENSURE(IMPLICATION(!___2038,___1119 == NULL)); return ___2038; } ___372 ___83( ___3503*       ___1119, ___3503 const* ___3657, ___372    ___3575) { if (___1119 && ___1119->data && ___3657 && ___3657->data) { ___3494 ___2402; ___1470(___2402, ___3657) { if (!___17(___1119, ___2402, ___3575)) return ___1303; } return ___4227; } else return ___1303; } void ___491(___3503* ___3477) { if (___3477 && ___3477->data) initSetData(___3477->data, 0, ___3477->size); }
 #if defined USE_FUNCTIONS_FOR_SETS
___372 ___17( ___3503*     ___3477, ___3494 ___2402, ___372  ___3575) { REQUIRE(___2402 >= 0); if (___3477 && (___2402 + 1 <= ___3477->size || ___1199(___3477, ___2402 + 1, ___3575))) { ___3494 word = ___2402 / ___3480; ___3481 bit = (___3481)1 << (___2402 % ___3480); ___3477->data[word] |= bit; return ___4227; } else return ___1303; }
 #endif
___372 AddRangeToSet( ___3503*     ___3477, ___3494 memberStart, ___3494 memberEnd) { ___372 ___2038 = ___4227; REQUIRE(memberStart >= 0); REQUIRE(memberEnd >= memberStart); if (___3477 && (memberEnd + 1 <= ___3477->size || ___1199(___3477, memberEnd + 1, ___1303))) { for (___3494 ___2402 = memberStart; ___2038 && ___2402 <= memberEnd; ++___2402) { ___2038 = ___17(___3477,___2402,___1303); } } else { ___2038 = ___1303; } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } void ___3335( ___3503*     ___3477, ___3494 ___2402) { REQUIRE(___2402 >= 0); if (___3477 && (___2402 < ___3477->size) && ___3477->data) { ___3494 word = ___2402 / ___3480; ___3481  bit = (___3481)1 << (___2402 % ___3480); ___3477->data[word] &= (((___3481)(-1)) ^ bit); } } void ___955( ___3503*     ___3477, ___3494 ___2403) { REQUIRE(VALID_REF(___3477)); REQUIRE(___2403 >= 0); ShiftSetForDelete(___3477, ___2403); } ___372 ___1954( ___3503*     ___3477, ___3494 ___2403, ___372  ___3572) { ___372  ___2039 = ___4227; ___3494 OrigLastMember; REQUIRE(VALID_REF(___3477)); OrigLastMember = ___1768(___3477, ___333); if (___2403 <= OrigLastMember) { ___2039 = ___1199(___3477, (OrigLastMember + 1) + 1, ___3572); ___3561(___3477, ___2403, OrigLastMember, 1); } if (___2039) ___2039 = ___17(___3477, ___2403, ___3572); ENSURE(VALID_BOOLEAN(___2039)); return ___2039; }
 #if defined USE_FUNCTIONS_FOR_SETS
___372 ___1955( ___3503 const* ___3477, ___3494   ___2402) { if (___3477 && (0 <= ___2402 && ___2402 < ___3477->size)) { ___3494 word = ___2402 / ___3480; ___3481  bit = (___3481)1 << (___2402 % ___3480); return (___3477->data[word]&bit) != 0; } else return ___1303; }
 #endif
___372 ___2014(___3503 const* ___3477) { if (___3477 && ___3477->data) { ___3494 set_size_in_words = ___3477->size / ___3480; ___3494 word; for (word = 0; word < set_size_in_words; word++) { ___3481 word_val = ___3477->data[word]; if (word_val != 0) return ___1303; } } return ___4227; } ___372 ___1821(___3503 const* ___3477) { ___372  ___3360 = ___1303; ___3494 ContiguousMember = 0; ___3494 ___2403 = 0; REQUIRE(VALID_REF(___3477)); ___1470(___2403, ___3477) { if (___2403 == ContiguousMember) { ContiguousMember++; } else { ___3360 = ___4227; break; } } ENSURE(VALID_BOOLEAN(___3360)); return ___3360; } ___3494 ___2404(___3503 const* ___3477) { ___3494 count = 0; if (___3477 && ___3477->data) { ___3494 set_size_in_words = ___3477->size / ___3480; ___3494 word; for (word = 0; word < set_size_in_words; word++) { ___3481 word_val = ___3477->data[word]; while (word_val) { if (word_val&1) count++; word_val = word_val >> 1; } } } return count; } ___372 ___2032(___3503 const* ___3477) { ___3494 count = 0; if (___3477 && ___3477->data) { ___3494 set_size_in_words = ___3477->size / ___3480; for (___3494 word = 0; word < set_size_in_words; ++word) { ___3481 word_val = ___3477->data[word]; while (word_val) { if (word_val & 1) { if(++count > 1) return ___1303; } word_val = word_val >> 1; } } } return count == 1; }
 #if !defined UNITTEST
___3494 ___1760( ___3503 const* ___3477, ___3494   ___3683) { ___3494 next_member = ___333; if (___3477 && ___3477->data) { ___3494 set_size_in_words = ___3477->size / ___3480; ___3494 word; ___3481 word_val = 0; int bit; if (___3683 == ___333) { word = 0; bit = 0; if (word < set_size_in_words) { word_val = ___3477->data[0]; } } else if (___3683 + 1 < ___3477->size) { word = (___3683 + 1) / ___3480; bit = static_cast<int>((___3683 + 1) % ___3480); if (word < set_size_in_words) { word_val = ___3477->data[word] >> bit; } } else { return ___333; } while ((word < set_size_in_words) && (word_val == 0)) { word++; bit = 0; if (word < set_size_in_words) { word_val = ___3477->data[word]; } } if (word < set_size_in_words) { while (!(word_val&1)) { word_val >>= 1; bit++; } next_member = word * ___3480 + bit; } } return next_member; }
 #endif
___3494 ___1768( ___3503 const* ___3477, ___3494   ___3683) { ___3494 next_member = ___333; if (___3477 && ___3477->data) { ___3494 set_size_in_words = ___3477->size / ___3480; ___3494 word; ___3481 word_val = 0; int bit; if (___3683 == ___333) { word = set_size_in_words - 1; bit = ___3480 - 1; if (word >= 0) { word_val = ___3477->data[word]; } } else if (___3683 > 0) { word = (___3683 - 1) / ___3480; bit = static_cast<int>((___3683 - 1) % ___3480); if (word >= 0) { word_val = ___3477->data[word] << (___3480 - bit - 1); } } else { return ___333; } while ((word >= 0) && (word_val == 0)) { word--; bit = static_cast<int>(___3480 - 1); if (word >= 0) { word_val = ___3477->data[word] << (___3480 - bit - 1); } } if (word >= 0) { while (!(word_val&___3499)) { word_val <<= 1; bit--; } next_member = word * ___3480 + bit; } } return next_member; } ___372 ___1173( ___3503 const* ___3478, ___3503 const* ___3479) { ___3494 set1_size_in_words, set2_size_in_words, min_set_size_in_words, ___1840; if (!___3478 || !___3479) return ___1303; set1_size_in_words = ___3478->size / ___3480; set2_size_in_words = ___3479->size / ___3480; min_set_size_in_words = MIN(set1_size_in_words, set2_size_in_words); for (___1840 = 0; ___1840 < min_set_size_in_words; ___1840++) { { if (___3478->data[___1840] != ___3479->data[___1840]) return ___1303; } } for (___1840 = min_set_size_in_words; ___1840 < set1_size_in_words; ___1840++) { { if (___3478->data[___1840] != 0) return ___1303; } } for (___1840 = min_set_size_in_words; ___1840 < set2_size_in_words; ___1840++) { { if (___3479->data[___1840] != 0) return ___1303; } } return ___4227; } ___3503* intersection( ___3503 const* ___3478, ___3503 const* ___3479) { ___3503* ___3359 = ___29(___1303); ___3494 const largestMember = MAX(___1750(___3478),___1750(___3479)); if (___3359 && !___1199(___3359, largestMember, ___1303)) ___937(&___3359); if (___3359 && !___2014(___3478) && !___2014(___3479)) { ___3494 mOffset1 = ___1745(___3478); ___3494 mOffset2 = ___1745(___3479); for (; mOffset1 != ___333 && mOffset2 != ___333; ) { if (mOffset1 == mOffset2) (void)___17(___3359, mOffset1, ___1303); bool const advance1 = mOffset1 <= mOffset2; bool const advance2 = mOffset2 <= mOffset1; if (advance1) mOffset1 = ___1760(___3478, mOffset1); if (advance2) mOffset2 = ___1760(___3479, mOffset2); } } ENSURE(VALID_REF_OR_NULL(___3359)); return ___3359; } ___372 ___2061( ___3503 const* ___484, ___3503 const* ___2974) { ___3494 s; ___1470(s, ___484) { if (!___1955(___2974, s)) return (___1303); } return (___4227); } ___3494 ___2405( ___3503 const* ___3477, ___3494   ___2403) { ___3494 ___1831; ___3494 ___2867 = -1; if (___1955(___3477, ___2403)) { for (___1831 = 0; ___1831 <= ___2403; ___1831++) { if (___1955(___3477, ___1831)) ___2867++; } } return (___2867); } ___3494 ___2868( ___3503 const* ___3477, ___3494   ___2867) { ___3494 ___1831; ___3494 ___2403 = ___333; for (___1831 = 0; ___1831 <= ___2867; ___1831++) { ___2403 = ___1760(___3477, ___2403); if (___2403 == ___333) break; } return (___2403);
} ___372 ___675( ___3503*       ___1124, ___3494   ___1123, ___3503 const* ___3664, ___3494   ___3663) { if (___1955(___3664, ___3663)) return (___17(___1124, ___1123, ___4227)); else ___3335(___1124, ___1123); return (___4227); } void ___3561( ___3503*     ___3477, ___3494 ___3559, ___3494 ___3560, ___3494 ___3557) { ___3503*     NewSet; ___3494 DPos; ___3494 SPos; if ((___3477 == NULL) || (___2014(___3477))) return; NewSet = ___29(___4227); if (NewSet == NULL) return; if (!___674(NewSet, ___3477, ___4227)) return; if (___3557 < 0) { DPos = ___3560; SPos = ___3559 - 1; while (DPos > ___3560 + ___3557) ___675(NewSet, DPos--, ___3477, SPos--); SPos = ___3560; while (SPos >= ___3559) ___675(NewSet, DPos--, ___3477, SPos--); } else if (___3557 > 0) { DPos       = ___3559; SPos       = ___3560 + 1; while (DPos < ___3559 + ___3557) ___675(NewSet, DPos++, ___3477, SPos++); SPos = ___3559; while (SPos <= ___3560) ___675(NewSet, DPos++, ___3477, SPos++); } ___674(___3477, NewSet, ___4227); ___937(&NewSet); } namespace {
 #if defined DEBUG_SET
void printWord(unsigned long word) { ___3481 ___2345 = 0x00000001; ___3481 shiftedw = word; for (int i = 0; i < ___3480; ++i) { if (___2345 & shiftedw) putchar('1'); else putchar('0'); shiftedw >>= 1; } } void printSet(___3503 const* ___3477) { ___3494 nWords = ___3477->size / ___3480; for (___3494 i = 0; i < nWords; ++i) { printWord(___3477->data[i]); putchar('|'); } putchar('\n'); }
 #endif 
void ShiftSetForDelete(___3503* ___3477, ___3494 DeletePos) { if ((___3477 == NULL) || (___2014(___3477))) return;
 #if defined DEBUG_SET
printf("Deleting member at %8ld in set: ",(long)DeletePos); printSet(___3477);
 #endif
___3494 nWords = ___3477->size / ___3480; ___3494 word_start_shift = DeletePos / ___3480; for (___3494 word = word_start_shift; word < nWords; ++word) { ___3481 word_val = ___3477->data[word]; ___3481 word_val_final = word_val; if (word > word_start_shift) { word_val_final >>= 1; } else { ___3481 mask1 = ((___3481)1 << DeletePos) - 1; ___3481 mask2 = ~mask1; ___3481 word_val_shifted = word_val; word_val_shifted >>= 1; word_val_shifted |= mask1; word_val |= mask2; word_val_final = (word_val & word_val_shifted); } if( word < nWords-1) { ___3481 word_val_next = ___3477->data[word+1]; ___3481 bit = (((___3481)1 & word_val_next) << (___3480-1)); word_val_final |= bit; } ___3477->data[word] = word_val_final; }
 #if defined DEBUG_SET
printf("Resulting set                     : "); printSet(___3477);
 #endif
} }
