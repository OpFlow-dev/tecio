#include "readValueArray.h"
#include "ThirdPartyHeadersBegin.h"
#include <utility>
#include <boost/algorithm/string.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "fileStuff.h"
#include "MinMax.h"
#include "writeValueArray.h"
namespace tecplot { namespace ___3934 { template <typename T, bool ___2024> struct ___198; template <> struct ___198 < char, false >     { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint8_t, false >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < int16_t, false >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint16_t, false > { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < int32_t, false >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint32_t, false > { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint64_t, false > { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < int64_t, false >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < float, false >    { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < double, false >   { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint8_t, true >   { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint16_t, true >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < uint64_t, true >  { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < int64_t, true >   { static char const* ___1472; static char const* typeName; }; template <> struct ___198 < std::pair<uint8_t, uint8_t>, false > { static char const* typeName; }; template <> struct ___198 < std::pair<int16_t, int16_t>, false > { static char const* typeName; }; template <> struct ___198 < std::pair<int32_t, int32_t>, false > { static char const* typeName; }; template <> struct ___198 < std::pair<float, float>, false >     { static char const* typeName; }; template <> struct ___198 < std::pair<double, double>, false >   { static char const* typeName; }; char const* ___198<char, false>::___1472 = "%c"; char const* ___198<uint8_t, false>::___1472 = "%" PRIu32; char const* ___198<int16_t, false>::___1472 = "%" PRId32; char const* ___198<uint16_t, false>::___1472 = "%" PRIu32; char const* ___198<int32_t, false>::___1472 = "%" PRId32; char const* ___198<uint32_t, false>::___1472 = "%" PRIu32; char const* ___198<uint64_t, false>::___1472 = "%" PRIu64; char const* ___198<int64_t, false>::___1472 = "%" PRId64; char const* ___198<float, false>::___1472 = "%f";
char const* ___198<double, false>::___1472 = "%lf"; char const* ___198<uint8_t, true>::___1472 = "%" PRIx32; char const* ___198<uint16_t, true>::___1472 = "%" PRIx32; char const* ___198<uint64_t, true>::___1472 = "%" PRIx64; char const* ___198<int64_t, true>::___1472 = "%" PRIx64; char const* ___198<char, false>::typeName = "single character"; char const* ___198<uint8_t, false>::typeName = "1-byte unsigned integer"; char const* ___198<int16_t, false>::typeName = "2-byte unsigned integer"; char const* ___198<uint16_t, false>::typeName = "2-byte signed integer"; char const* ___198<int32_t, false>::typeName = "4-byte signed integer"; char const* ___198<uint32_t, false>::typeName = "4-byte unsigned integer"; char const* ___198<uint64_t, false>::typeName = "8-byte unsigned integer"; char const* ___198<int64_t, false>::typeName = "8-byte unsigned integer"; char const* ___198<float, false>::typeName = "float"; char const* ___198<double, false>::typeName = "double"; char const* ___198<uint8_t, true>::typeName = "1-byte unsigned integer"; char const* ___198<uint16_t, true>::typeName = "2-byte unsigned integer"; char const* ___198<uint64_t, true>::typeName = "8-byte hexadecimal"; char const* ___198<int64_t, true>::typeName = "8-byte hexadecimal"; char const* ___198<std::pair<uint8_t, uint8_t>, false >::typeName = "MinMax<uint8_t>"; char const* ___198<std::pair<int16_t, int16_t>, false >::typeName = "MinMax<int16_t>"; char const* ___198<std::pair<int32_t, int32_t>, false >::typeName = "MinMax<int32_t>"; char const* ___198<std::pair<float, float>, false >::typeName = "MinMax<float>"; char const* ___198<std::pair<double, double>, false >::typeName = "MinMax<double>"; template <typename T, bool ___2024, int baseValue> ___372 readAsciiValue( ___1397& file, T&                   ___4299) { char const* ___1472 = ___198<T, ___2024>::___1472; ___372 ___2038 = (file.fscanf(___1472, &___4299) == 1); if (___2038 && baseValue) ___4299 -= baseValue; ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #define INSTANTIATE_READ_ASCII_UINT_VALUE(T, ___2024) \
 template <> \
 ___372 readAsciiValue < T, ___2024, 0 >(___1397& file, T& ___4299) \
 { \
 char const* ___1472 = ___198<T, ___2024>::___1472; \
 uint32_t valFromFile; \
 ___372 ___2038 = (file.fscanf(___1472, &valFromFile) == 1); \
 if (___2038) \
 ___2038 = (valFromFile <= T(-1));    \
 if (___2038) \
 ___4299 = static_cast<T>(valFromFile); \
 ENSURE(VALID_BOOLEAN(___2038)); \
 return ___2038; \
 }
INSTANTIATE_READ_ASCII_UINT_VALUE(uint8_t, false) INSTANTIATE_READ_ASCII_UINT_VALUE(uint8_t, true) INSTANTIATE_READ_ASCII_UINT_VALUE(uint16_t, false) INSTANTIATE_READ_ASCII_UINT_VALUE(uint16_t, true) template <> ___372 readAsciiValue < int16_t, false, 0 >( ___1397& file, int16_t&             ___4299) { char const* ___1472 = ___198<int16_t, false>::___1472; int32_t valFromFile; ___372 ___2038 = (file.fscanf(___1472, &valFromFile) == 1); if (___2038) ___2038 = (-std::numeric_limits<int16_t>::max() <= valFromFile && valFromFile <= std::numeric_limits<int16_t>::max()); if (___2038) ___4299 = static_cast<int16_t>(valFromFile); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #define INSTANTIATE_READ_ASCII_VALUE_PAIR(T) \
 template <> \
 ___372 readAsciiValue<std::pair<T, T>, false, 0 >(___1397& file, std::pair<T, T>& minMax) \
 { \
 ___372 ___2038 = (readAsciiValue<T, false, 0>(file, minMax.first) == 1 && \
 readAsciiValue<T, false, 0>(file, minMax.second) == 1); \
 ENSURE(VALID_BOOLEAN(___2038)); \
 return ___2038; \
 }
INSTANTIATE_READ_ASCII_VALUE_PAIR(uint8_t) INSTANTIATE_READ_ASCII_VALUE_PAIR(int16_t) INSTANTIATE_READ_ASCII_VALUE_PAIR(int32_t) INSTANTIATE_READ_ASCII_VALUE_PAIR(float) INSTANTIATE_READ_ASCII_VALUE_PAIR(double) namespace { inline bool isWhitespace(___2719 const ch) { return ch == ' ' || ch == '\n' || ch == '\r'; } } namespace { ___372 consumeWhitespace(___1397& file) { REQUIRE(file.___2040()); while (!file.feof()) { int ch = file.getc(); if (!isWhitespace(ch)) { file.ungetc(ch); break; } } return ___4227; } } namespace { ___372 checkDescription( char const*          stringToCheck, IODescription const& ___970) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___372 const ___2038 = (boost::iequals(stringToCheck, formattedDescription) ? ___4227 : ___1303); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 readAndVerifyDescription( ___1397& file, IODescription const& ___970) { REQUIRE(file.___2040()); char encounteredString[STRING_SIZE]; ___372 ___2038 = (file.fscanf(STRING_FORMAT, encounteredString) == 1); ___2038 = ___2038 && consumeWhitespace(file); if (!___2038) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Cannot read description for %s.", formattedDescription); } else { if (!checkDescription(encounteredString, ___970)) { static TagDescriptionToDescriptionMap altTagDescriptions = ALT_TAG_DESCRIPTIONS_MAP_INITIALIZER; char const* nameToCheck = ___970.___2686(); ___476(VALID_REF(nameToCheck)); while (___2038) { TagDescriptionToDescriptionMap::const_iterator altTagDescIter = altTagDescriptions.find(nameToCheck); if (altTagDescIter == altTagDescriptions.end()) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___2038 = ___1184("Mismatched descriptions: looking for '%s', found '%s' instead.", formattedDescription, encounteredString); } else { nameToCheck = altTagDescIter->second.c_str(); IODescription altDescription(nameToCheck, ___970.___4336(), ___970.zone(), ___970.___2978(), ___970.segment(), ___970.suffix()); if (checkDescription(encounteredString, altDescription)) break; } } } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } template<typename T, bool ___2024  > ___372 readValue( ___1397& file, T&                   ___4299, IODescription const& ___970) { REQUIRE(file.___2040()); REQUIRE(___970.___2066()); ___372 ___2038 = ___4227; if (file.___2001()) { ___2038 = ___2038 && readAndVerifyDescription(file, ___970); ___2038 = ___2038 && readAsciiValue<T, ___2024, 0>(file, ___4299); ___2038 = ___2038 && consumeWhitespace(file); } else { ___2038 = (file.fread(&___4299, sizeof(T), 1) == 1); } if (!___2038) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Cannot read %s value.", formattedDescription); } ENSURE(VALID_BOOLEAN(___2038));
return ___2038; }
 #define INSTANTIATE_READ_VALUE_FOR_TYPE(T, ___2024) \
 template ___372 readValue<T, ___2024>( \
 ___1397& file, \
 T&                   ___4299, \
 IODescription const& ___970);
INSTANTIATE_READ_VALUE_FOR_TYPE(uint8_t,  false) INSTANTIATE_READ_VALUE_FOR_TYPE(uint16_t, false) INSTANTIATE_READ_VALUE_FOR_TYPE(int32_t,  false) INSTANTIATE_READ_VALUE_FOR_TYPE(uint32_t, false) INSTANTIATE_READ_VALUE_FOR_TYPE(uint64_t, true) INSTANTIATE_READ_VALUE_FOR_TYPE(uint64_t, false) INSTANTIATE_READ_VALUE_FOR_TYPE(float,    false) INSTANTIATE_READ_VALUE_FOR_TYPE(double,   false) template<typename T, bool ___2024, int baseValue> ___372 readValues( ___1397& file, size_t               ___2797, T*                   ___4300, IODescription const& ___970) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); REQUIRE(___2797>0); REQUIRE(VALID_REF(___4300)); REQUIRE(___970.___2066()); if (file.___2001()) { if (!___970.isEmpty()) ___2038 = readAndVerifyDescription(file, ___970); for (size_t ___1840 = 0; ___2038 && ___1840 < ___2797; ___1840++) { ___2038 = readAsciiValue<T, ___2024, baseValue>(file, ___4300[___1840]); ___2038 = ___2038 && consumeWhitespace(file); } } else { ___2038 = (file.fread(&___4300[0], sizeof(T), ___2797) == ___2797); } if ( !___2038 && !___970.isEmpty() ) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Error reading %" PRIu64 " %s values for %s data block.", uint64_t(___2797), ___198<T, ___2024>::typeName, formattedDescription); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #define INSTANTIATE_READ_VALUES_FOR_TYPE(T, ___2024, baseValue) \
 template ___372 readValues<T, ___2024, baseValue>( \
 ___1397& file, \
 size_t               ___2797, \
 T*                   ___4300, \
 IODescription const& ___970);
INSTANTIATE_READ_VALUES_FOR_TYPE(char,     false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint8_t,  false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint8_t,  true,  0) INSTANTIATE_READ_VALUES_FOR_TYPE(int16_t,  false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint16_t, false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint16_t, true,  0) INSTANTIATE_READ_VALUES_FOR_TYPE(int32_t,  false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint32_t, false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint32_t, false, 1) INSTANTIATE_READ_VALUES_FOR_TYPE(uint64_t, false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(uint64_t, true,  0) INSTANTIATE_READ_VALUES_FOR_TYPE(int64_t,  false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(int64_t,  true,  0) INSTANTIATE_READ_VALUES_FOR_TYPE(float,    false, 0) INSTANTIATE_READ_VALUES_FOR_TYPE(double,   false, 0) template<typename T, bool ___2024, int baseValue> ___372 readValueArray( ___1397&  file, size_t                ___2866, size_t                ___2796, ___2241<T>& ___4300, IODescription const&  ___970) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); REQUIRE(IMPLICATION(___4300.empty(), ___2866 == 0)); REQUIRE(IMPLICATION(!___4300.empty(), ___2866 + ___2796 <= ___4300.size())); REQUIRE(___2796 > 0); REQUIRE(___970.___2066()); if (___4300.empty()) { ___2038 = ___4300.alloc(___2796); if (!___2038) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Cannot allocate memory for %s data block of %" PRIu64 " %s values.", formattedDescription, uint64_t(___2796), ___198<T, ___2024>::typeName); } } ___2038 = ___2038 && readValues<T, ___2024, baseValue>(file, ___2796, &___4300[___2866], ___970); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #define INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(T, ___2024, baseValue) \
 template ___372 readValueArray<T, ___2024, baseValue>( \
 ___1397&  file, \
 size_t                ___2866, \
 size_t                ___2796, \
 ___2241<T>& ___4300, \
 IODescription const&  ___970);
INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(char,     false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint8_t,  false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint8_t,  true,  0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(int16_t,  false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint16_t, false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint16_t, true,  0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(int32_t,  false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint32_t, false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint32_t, false, 1) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint64_t, false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(uint64_t, true,  0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(int64_t,  false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(int64_t,  true,  0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(float,    false, 0) INSTANTIATE_READ_VALUE_ARRAY_FOR_TYPE(double,   false, 0) template<typename T> ___372 readMinMaxArray( ___1397& file, size_t               ___2866, size_t               ___2796, ___2482&         ___2481, IODescription const& ___970) { REQUIRE(file.___2040()); REQUIRE(___970.___2066()); REQUIRE(___2796>0); REQUIRE(IMPLICATION(___2481.empty(), ___2866 == 0)); REQUIRE(IMPLICATION(!___2481.empty(), ___2866 + ___2796 <= ___2481.size())); ___372 ___2038 = ___4227; char const* typeName = "min-max value"; if (___2481.empty()) { ___2038 = ___2481.alloc(___2796); if (!___2038) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Cannot allocate memory for %s data block (%" PRIu64 " %s values).", formattedDescription, uint64_t(___2796), typeName); } } if (file.___2001() && !___970.isEmpty()) ___2038 = readAndVerifyDescription(file, ___970); IODescription emptyDescription; size_t const maxValsPerChunk = 1024; std::pair<T, T> valsFromFile[maxValsPerChunk]; INVARIANT(sizeof(valsFromFile[0]) == 2 * sizeof(T)); size_t numValsRead = 0; while (___2038 && numValsRead < ___2796) { size_t const numChunkedValsToRead = std::min(maxValsPerChunk, ___2796 - numValsRead); ___2038 = readValues<std::pair<T, T>, false, 0>(file, numChunkedValsToRead, valsFromFile, emptyDescription); if (___2038) { for (size_t ___1840 = 0; ___1840 < numChunkedValsToRead; ++___1840) ___2481[___2866 + numValsRead + ___1840].___3500(static_cast<double>(valsFromFile[___1840].first), static_cast<double>(valsFromFile[___1840].second)); numValsRead += numChunkedValsToRead; } else { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Error reading %" PRIu64 " %s values for %s data block.", uint64_t(___2796), ___198<std::pair<T, T>, false>::typeName, formattedDescription); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #define INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(T) \
 template \
 ___372 readMinMaxArray<T>( \
 ___1397& file, \
 size_t               ___2866, \
 size_t               ___2796, \
 ___2482&         ___2481, \
 IODescription const& ___970);
INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(uint8_t) INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(int16_t) INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(int32_t) INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(float) INSTANTIATE_READ_MINMAX_ARRAY_FOR_TYPE(double) template<typename T, bool ___2024> ___372 readAndVerifyValue( ___1397& file, T const              expectedVal, IODescription const& ___970) { REQUIRE(file.___2040()); REQUIRE(___970.___2066()); T ___4299 = 0; ___372 ___2038 = readValue<T, ___2024>(file, ___4299, ___970); if (___2038 && ___4299 != expectedVal) { ___2038 = ___1303; char expectedValStr[STRING_SIZE]; char valStr[STRING_SIZE]; if (encodeAsciiValue<T, ___2024, 0>(expectedValStr, STRING_SIZE, expectedVal) && encodeAsciiValue<T, ___2024, 0>(valStr, STRING_SIZE, ___4299)) { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Expected value mismatch for %s %s (expecting %s, found %s).", ___198<T, ___2024>::typeName, formattedDescription, expectedValStr, valStr); } else { char formattedDescription[STRING_SIZE]; ___970.getFormattedDescription(formattedDescription, STRING_SIZE); ___1184("Expected value mismatch for %s %s.", ___198<T, ___2024>::typeName, formattedDescription); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template ___372 readAndVerifyValue<unsigned int, false>( ___1397& file, unsigned int const   expectedVal, IODescription const& ___970); ___372 readString( ___1397& file, size_t               length, ___471&           ___4299, IODescription const& ___970) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); REQUIRE(___970.___2066() && !___970.isEmpty()); REQUIRE(length > 0); REQUIRE(___4299.size() == length); if (file.___2001()) ___2038 = ___2038 && readAndVerifyDescription(file, ___970); ___2038 = ___2038 && (file.fread(___4299.data(), 1, length) == length); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readStringArray( ___1397& file, size_t               ___2866, size_t               ___2813, ___3817&         itemNameArray, IODescription const& ___970) { REQUIRE(file.___2040()); REQUIRE(IMPLICATION(itemNameArray.empty(), ___2866 == 0)); REQUIRE(IMPLICATION(!itemNameArray.empty(), ___2866 + ___2813 <= itemNameArray.size())); REQUIRE(___2813 > 0); REQUIRE(___970.___2066() && !___970.isEmpty()); ___372 ___2038 = ___4227; if (itemNameArray.empty()) { if (!itemNameArray.alloc(___2813)) ___2038 = ___1184("Cannot resize string array."); } uint64_t totalStringListSize = 0; IODescription totalSizeDescription(___970.___2686(), ___970.___4336(), ___970.zone(), ___970.___2978(), ___970.segment(), "TotalSize" ); ___2038 = ___2038 && readValue<uint64_t, false>(file, totalStringListSize, totalSizeDescription); ASSERT_ONLY(___1391 startFileLoc = ___2038 ? file.fileLoc() : 0;) if (file.___2001()) ___2038 = ___2038 && readAndVerifyDescription(file, ___970); for (size_t ___2084 = 0; ___2038 && ___2084 < ___2813; ___2084++)
{ char ___2686[500]; for (size_t pos = 0; ___2038 && pos < sizeof(___2686); pos++) { int ch = file.getc(); if (ch == EOF) { ___2038 = ___1184("Unexpected end of file reading string array."); break; } else if (ch == '\r') { ___2686[pos] = '\0'; ___476(strlen(___2686) < sizeof(___2686)); itemNameArray[___2866 + ___2084] = ___2686; break; } else { ___2686[pos] = char(ch); } } if (___2038 && file.___2001()) if (file.getc() != '\n') ___2038 = ___1184("Problem with end of line in ascii string array."); } ASSERT_ONLY(___1391 curFileLoc = ___2038 ? file.fileLoc() : 0;) ___476(IMPLICATION(___2038, curFileLoc - startFileLoc == totalStringListSize)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } }}
