 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <string>
#include <vector>
#include "ThirdPartyHeadersEnd.h"
#include "basicTypes.h"
#include "feCellTypeMetrics.h"
#include "FEZoneInfo.h"
#include "IJK.h"
#include "IJKPartitionTree.h"
#include "IJKZoneInfo.h"
#include "MinMaxTree.h"
#include "NonSzZoneFileLocations.h"
#include "PartitionMetadata.h"
#include "writeValueArray.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3934 { template<typename T> ItemAddress64::SubzoneOffset_t getNumSzFromNumItems(T ___2813) { return static_cast<ItemAddress64::SubzoneOffset_t>((___2813 + 0xFF) >> 8); } namespace { bool isClassicFEZoneType(ZoneType_e ___4692) { return (___4692 == ___4702 || ___4692 == ___4700     || ___4692 == ___4701    || ___4692 == ___4695    || ___4692 == ___4696); } } class ZoneMetadata { private: UNCOPYABLE_CLASS(ZoneMetadata); private: ___4636        ___2678; ZoneType_e         ___2685; int32_t            m_dimension; bool               m_isSZL; ___1843                m_zoneIJK; std::string        ___2496; FaceNeighborMode_e ___2459; double             ___2622; ___1170         ___2623; ___4636        ___2615; ItemAddress64::___2981 m_numPartitions; ___1862 m_partitionTree; public: ___2241<___1880> m_ijkZoneInfos; private: ItemAddress64::SectionOffset_t m_numSections; ___2241<___463> m_secNumElems; ___2241<uint8_t>     m_secCellShape; ___2241<uint8_t>     m_secGridOrder; ___2241<uint8_t>     m_secCellBasisFunc; ___2241<CellNodeIndex_t> m_cornersPerCell; ___2241<CellNodeIndex_t> ___2501; public: ___2241<___2241<___463> > m_secPtnNumCells; ___2241<___2719> m_ptnNumNodes; ___2241<___2241<___463> > m_secPtnFirstCell; ___2241<___2719> m_ptnFirstNode; ___2241<___1843> m_ptnNodeMinIJKs; ___2241<___1843> m_ptnNodeMaxIJKs; ___2241<___2241<ItemAddress64::SubzoneOffset_t> > m_secPtnNumCszs; ___2241<ItemAddress64::SubzoneOffset_t> m_ptnNumNszs; ___2241<ItemAddress64::___2981> m_ptnFileNums; ___2241<___1391>                  m_ptnHeaderFileLocs; ___2241<___1391>                  m_varPtnMinMaxFileLocs; ___2241<MinMaxTree>                 m_varPtnMinMaxTrees; ___2241<PartitionMetadata> m_ptnMetadata; NonSzZoneFileLocations m_nonSzZoneFileLocations; public: ZoneMetadata() : ___2678(-1) , ___2685(___4703) , m_dimension(-1) , m_isSZL(false) , m_zoneIJK() , ___2496() , ___2459(___1288) , ___2622(0.0) , ___2623(___3789) , ___2615(-1) , m_numPartitions(0) , m_numSections(0) { } inline void swap(ZoneMetadata& ___2889) { using std::swap; swap(___2678, ___2889.___2678); swap(___2685, ___2889.___2685); swap(m_dimension, ___2889.m_dimension); swap(m_isSZL, ___2889.m_isSZL); swap(m_zoneIJK, ___2889.m_zoneIJK); swap(___2496, ___2889.___2496); swap(___2459, ___2889.___2459); swap(___2622, ___2889.___2622); swap(___2623, ___2889.___2623); swap(___2615, ___2889.___2615); swap(m_numPartitions, ___2889.m_numPartitions); swap(m_partitionTree, ___2889.m_partitionTree); swap(m_ijkZoneInfos, ___2889.m_ijkZoneInfos);
swap(m_numSections, ___2889.m_numSections); swap(m_secNumElems, ___2889.m_secNumElems); swap(m_secCellShape, ___2889.m_secCellShape); swap(m_secGridOrder, ___2889.m_secGridOrder); swap(m_secCellBasisFunc, ___2889.m_secCellBasisFunc); swap(m_cornersPerCell, ___2889.m_cornersPerCell); swap(___2501, ___2889.___2501); swap(m_secPtnNumCells, ___2889.m_secPtnNumCells); swap(m_ptnNumNodes, ___2889.m_ptnNumNodes); swap(m_secPtnFirstCell, ___2889.m_secPtnFirstCell); swap(m_ptnFirstNode, ___2889.m_ptnFirstNode); swap(m_ptnNodeMinIJKs, ___2889.m_ptnNodeMinIJKs); swap(m_ptnNodeMaxIJKs, ___2889.m_ptnNodeMaxIJKs); swap(m_secPtnNumCszs, ___2889.m_secPtnNumCszs); swap(m_ptnNumNszs, ___2889.m_ptnNumNszs); swap(m_ptnFileNums, ___2889.m_ptnFileNums); swap(m_ptnHeaderFileLocs, ___2889.m_ptnHeaderFileLocs); swap(m_varPtnMinMaxFileLocs, ___2889.m_varPtnMinMaxFileLocs); swap(m_varPtnMinMaxTrees, ___2889.m_varPtnMinMaxTrees); swap(m_ptnMetadata, ___2889.m_ptnMetadata); swap(m_nonSzZoneFileLocations, ___2889.m_nonSzZoneFileLocations); } inline ___4636 zone() const { ENSURE(___2678>=0 && ___2678<MAX_NUM_ZONES); return ___2678; } inline ZoneType_e getZoneType() const { ENSURE(VALID_ENUM(___2685,ZoneType_e)); return ___2685; } inline int32_t getZoneDimension() const { ENSURE(1 <= m_dimension && m_dimension <= 3); return m_dimension; } inline bool isSZL() const { return m_isSZL; } inline ___1843 const& getZoneIJK() const { ENSURE(m_zoneIJK.___2066()); return m_zoneIJK; } inline ___463 ___1765() const { REQUIRE(___2685 != ___4698 && ___2685 != ___4699); if ( ___2685 == ___4704 ) return m_zoneIJK.getNumContiguousCells(); else return m_zoneIJK.___1667(); } inline ___2719 ___1767() const { REQUIRE(___2685 != ___4698 && ___2685 != ___4699); if ( ___2685 == ___4704 ) return m_zoneIJK.___1767(); else return m_zoneIJK.___1669(); } inline CellNodeIndex_t getNumCornersPerCell(ItemAddress64::SectionOffset_t section) const { REQUIRE(___2685 != ___4698 && ___2685 != ___4699); REQUIRE(___2685 == ___4704 || (___2685 != ___4704 && section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_cornersPerCell.size()))); if ( ___2685 == ___4704 ) return 8; else return m_cornersPerCell[section]; } inline CellNodeIndex_t getNumNodesPerCell(ItemAddress64::SectionOffset_t section) const { REQUIRE(___2685 != ___4698 && ___2685 != ___4699); REQUIRE(___2685 == ___4704 || (___2685 != ___4704 && section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(___2501.size()))); if ( ___2685 == ___4704 ) return 8; else return ___2501[section]; } inline std::string getName() const { return ___2496; } inline FaceNeighborMode_e getFaceNeighborMode() const { ENSURE(VALID_ENUM(___2459, FaceNeighborMode_e) || ___2459 == ___1286); return ___2459;
} inline double getSolutionTime() const { return ___2622; } inline ___1170 getStrandID() const { REQUIRE(___2623==___3789 || ___4313(___2623)); return ___2623; } inline ___4636 getParentZone() const { REQUIRE(___2615==-1 || (___2615 >= 0 && ___2615 < MAX_NUM_ZONES)); return ___2615; } void setZone(___4636 zone) { REQUIRE(zone >= 0 && zone < MAX_NUM_ZONES); ___2678 = zone; } void setZoneType(ZoneType_e ___4692) { REQUIRE(___2685 == ___4703); REQUIRE(VALID_ENUM(___4692, ZoneType_e)); ___2685 = ___4692; if (___2685 != ZoneType_FEMixed) m_numSections = 1; if (isClassicFEZoneType(___2685)) { if (!m_secNumElems.alloc(m_numSections)      || !m_secCellShape.alloc(m_numSections)     || !m_secGridOrder.alloc(m_numSections)     || !m_secCellBasisFunc.alloc(m_numSections) || !m_cornersPerCell.alloc(m_numSections)   || !___2501.alloc(m_numSections)) throw std::bad_alloc(); switch (___4692) { case ___4702: m_secCellShape[0] = FECellShape_Triangle; m_cornersPerCell[0] = 3; break; case ___4700: m_secCellShape[0] = FECellShape_Quadrilateral; m_cornersPerCell[0] = 4; break; case ___4701: m_secCellShape[0] = FECellShape_Tetrahedron; m_cornersPerCell[0] = 4; break; case ___4695: m_secCellShape[0] = FECellShape_Hexahedron; m_cornersPerCell[0] = 8; break; case ___4696: m_secCellShape[0] = FECellShape_Bar; m_cornersPerCell[0] = 2; break; default: ___476(___1303); break; } ___2501[0] = m_cornersPerCell[0]; m_secGridOrder[0] = 1; m_secCellBasisFunc[0] = FECellBasisFunction_Lagrangian; } } void setZoneDimension(int32_t ___1087) { REQUIRE(1 <= ___1087 && ___1087 <= 3); m_dimension = ___1087; } inline void setIsSZL(bool isSZL) { m_isSZL = isSZL; } inline void setIJKMax(___1843 const& ijkDim) { REQUIRE(___2685==___4704); m_zoneIJK = ijkDim; } inline void setFEDescription( ___463     ___2782, CellNodeIndex_t ___2790, ___2719     ___2822) { REQUIRE(___2685 != ___4704 && ___2685 != ___4698 && ___2685 != ___4699); REQUIRE(___2782>0 && ___2782 <= MAX_NUM_CELLS); REQUIRE(___2822>0 && ___2822 <= MAX_NUM_NODES); REQUIRE((___2685 == ZoneType_FEMixed && ___2790 == 0) || (isClassicFEZoneType(___2685) && 0 < ___2790 && ___2790 <= MAX_NUM_CELL_CORNERS)); m_zoneIJK = ___1843(___2822, ___2782, ___2790); if (isClassicFEZoneType(___2685)) m_secNumElems[0] = m_zoneIJK.___2104(); } inline void setName(std::string const& ___2686) { ___2496 = ___2686; } inline void setFaceNeighborMode(FaceNeighborMode_e ___1282) { REQUIRE(VALID_ENUM(___1282, FaceNeighborMode_e) || ___1282 == ___1286); ___2459 = ___1282; } inline void setSolutionTime(double ___3641) { ___2622 = ___3641; } inline void setStrandID(___1170 ___3786) { ___2623 = ___3786; } inline void setParentZone(___4636 ___2975)
{ REQUIRE(___2975==-1 || (___2975 >= 0 && ___2975 < MAX_NUM_ZONES)); ___2615 = ___2975; } inline ItemAddress64::___2981 getNumPartitions() const { ENSURE(VALID_ITEM_ADDRESS_PARTITION(m_numPartitions-1)); return m_numPartitions; } inline ItemAddress64::SubzoneOffset_t getNumCszsInPartitionSection( ItemAddress64::___2981     ___2978, ItemAddress64::SectionOffset_t section) const { REQUIRE(m_isSZL); REQUIRE(___2978 < m_numPartitions); REQUIRE(section < m_numSections); ItemAddress64::SubzoneOffset_t const numCszs = m_secPtnNumCszs[section][___2978]; ENSURE(IMPLICATION(___2685==___4704, VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numCszs-1))); ENSURE(IMPLICATION(___2685!=___4704, numCszs == getNumSzFromNumItems(m_secPtnNumCells[section][___2978]))); return numCszs; } inline ItemAddress64::SubzoneOffset_t getNumCszsInPartition(ItemAddress64::___2981 ___2978) const { REQUIRE(m_isSZL); REQUIRE(___2978 < m_numPartitions); ItemAddress64::SubzoneOffset_t numCszs = 0; for (ItemAddress64::SectionOffset_t section = 0; section < m_numSections; ++section) numCszs += getNumCszsInPartitionSection(___2978,section); ENSURE(numCszs > 0); return numCszs; } inline ItemAddress64::SubzoneOffset_t getNumNszsInPartition(ItemAddress64::___2981 ___2978) const { REQUIRE(m_isSZL); REQUIRE(___2978 < m_numPartitions); ItemAddress64::SubzoneOffset_t const numNszs = m_ptnNumNszs[___2978]; ENSURE(IMPLICATION(___2685==___4704, VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numNszs-1))); ENSURE(IMPLICATION(___2685!=___4704, numNszs == getNumSzFromNumItems(m_ptnNumNodes[___2978]))); ENSURE(numNszs > 0); return numNszs; } inline void setNumPartitions(ItemAddress64::___2981 numPartitions) { REQUIRE(numPartitions >= 1 && (m_isSZL ? VALID_ITEM_ADDRESS_PARTITION(numPartitions-1) : numPartitions == 1)); m_numPartitions = numPartitions; ENSURE(VALID_ITEM_ADDRESS_PARTITION(m_numPartitions-1)); } ItemAddress64::SectionOffset_t numSections() const { return static_cast<ItemAddress64::SectionOffset_t>(m_numSections); } int64_t numElems(ItemAddress64::SectionOffset_t section) const { REQUIRE(section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_secNumElems.size())); return m_secNumElems[section]; } FECellShape_e cellShape(ItemAddress64::SectionOffset_t section) const { REQUIRE(section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_secCellShape.size())); return static_cast<FECellShape_e>(m_secCellShape[section]); } FEGridOrder_t gridOrder(ItemAddress64::SectionOffset_t section) const { REQUIRE(section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_secGridOrder.size())); return static_cast<FEGridOrder_t>(m_secGridOrder[section]); } FECellBasisFunction_e cellBasisFunc(ItemAddress64::SectionOffset_t section) const { REQUIRE(section < checked_numeric_cast<ItemAddress64::SectionOffset_t>(m_secCellBasisFunc.size())); return static_cast<FECellBasisFunction_e>(m_secCellBasisFunc[section]); } inline void setSectionMetrics(
ItemAddress64::SectionOffset_t numSections, ___3270<int64_t const> const& secNumElems, ___3270<uint8_t const> const& secCellShape, ___3270<uint8_t const> const& secGridOrder, ___3270<uint8_t const> const& secCellBasisFunc) { REQUIRE(___2685 == ZoneType_FEMixed); REQUIRE(m_secNumElems.empty() && m_secCellShape.empty() && m_secGridOrder.empty() && m_secCellBasisFunc.empty()); REQUIRE(!secNumElems.empty() && !secCellShape.empty() && !secGridOrder.empty() && !secCellBasisFunc.empty()); REQUIRE((secNumElems.size() + secCellShape.size() + secGridOrder.size() + secCellBasisFunc.size()) % 4ul == 0 && (secNumElems.size() + secCellShape.size() + secGridOrder.size() + secCellBasisFunc.size()) == 4ul*static_cast<size_t>(numSections)); m_numSections = numSections; if (!m_secNumElems.alloc(m_numSections)      || !m_secCellShape.alloc(m_numSections)     || !m_secGridOrder.alloc(m_numSections)     || !m_secCellBasisFunc.alloc(m_numSections) || !m_cornersPerCell.alloc(m_numSections)   || !___2501.alloc(m_numSections)) throw std::bad_alloc(); ___1170 numEdges = 0; ___1170 numFacesOrEdges = 0; ___1170 numHighOrderNodes = 0; ___1170 numNaturalSubElems = 0; ___1170 const MAX_NUM_FACES_PER_ELEM = 6; std::vector<___1170> numCornersPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); std::vector<___1170> numHighOrderNodesPerFaceOrEdge(MAX_NUM_FACES_PER_ELEM); for (ItemAddress64::SectionOffset_t section = 0; section < numSections; ++section) { m_secNumElems[section]      = secNumElems[section]; m_secCellShape[section]     = secCellShape[section]; m_secGridOrder[section]     = secGridOrder[section]; m_secCellBasisFunc[section] = secCellBasisFunc[section]; tecplot::feCellTypeMetrics( static_cast<FECellShape_e>(m_secCellShape[section]), static_cast<FEGridOrder_t>(m_secGridOrder[section]), static_cast<FECellBasisFunction_e>(m_secCellBasisFunc[section]), numEdges, numFacesOrEdges, m_cornersPerCell[section], ___2501[section], numHighOrderNodes, numNaturalSubElems, numCornersPerFaceOrEdge.begin(), numNodesPerFaceOrEdge.begin(), numHighOrderNodesPerFaceOrEdge.begin()); } } inline void addPartitionTreeItem(ItemAddress64::___2981 ___2978, ___1843 const& ___2475, ___1843 const& ___2365) { m_partitionTree.___13(___2978, ___2475, ___2365); } inline ItemAddress64::___2981 getPartitionForIJK(___1843 const& ___1842) const { if (m_numPartitions == 1) { return 0; } else { ___1852 ___2479(___1842.i(), ___1842.___2104(), ___1842.___2133()); ___1852 ___2373(___1842.i(), ___1842.___2104(), ___1842.___2133()); std::vector<___1863> ___2098; m_partitionTree.query(boost::geometry::index::intersects(___1854(___2479, ___2373)), std::back_inserter(___2098)); return (___2098.empty() ? ItemAddress64::INVALID_PARTITION : ___2098[0].second); } } inline std::vector<ItemAddress64::___2981> getPartitionsForIJKRange(___1843 const& ijkMin, ___1843 const& ___1860) const { if (m_numPartitions == 1) { return std::vector<ItemAddress64::___2981>(1, 0);
} else { ___1852 ___2479(ijkMin.i(), ijkMin.___2104(), ijkMin.___2133()); ___1852 ___2373(___1860.i(), ___1860.___2104(), ___1860.___2133()); std::vector<___1863> ___2098; m_partitionTree.query(boost::geometry::index::intersects(___1854(___2479, ___2373)), std::back_inserter(___2098)); std::vector<ItemAddress64::___2981> ___3359; ___3359.reserve(___2098.size()); for (std::vector<___1863>::const_iterator it = ___2098.begin(); it != ___2098.end(); ++it) ___3359.push_back(it->second); std::sort(___3359.begin(), ___3359.end()); return ___3359; } } inline std::vector<ItemAddress64::___2981> getPartitionsForIndexPlane(IJKPlanes_e whichPlane, ___2719 planeIndex) const { if (m_numPartitions == 1) { return std::vector<ItemAddress64::___2981>(1, 0); } else { ___1843 planeMin(0, 0, 0); ___1843 planeMax(getZoneIJK() - 1); switch (whichPlane) { case ___1866: planeMin.setI(planeIndex); planeMax.setI(planeIndex); break; case ___1871: planeMin.setJ(planeIndex); planeMax.setJ(planeIndex); break; case ___1873: planeMin.___3498(planeIndex); planeMax.___3498(planeIndex); break; default: ___476(___1303); break; } ___1852 ___2479(planeMin.i(), planeMin.___2104(), planeMin.___2133()); ___1852 ___2373(planeMax.i(), planeMax.___2104(), planeMax.___2133()); std::vector<___1863> ___2098; m_partitionTree.query(boost::geometry::index::intersects(___1854(___2479, ___2373)), std::back_inserter(___2098)); std::vector<ItemAddress64::___2981> ___3359; ___3359.reserve(___2098.size()); for (std::vector<___1863>::const_iterator it = ___2098.begin(); it != ___2098.end(); ++it) ___3359.push_back(it->second); std::sort(___3359.begin(), ___3359.end()); return ___3359; } } inline std::vector<ItemAddress64::___2981> getPartitionsForIndexLine(IJKLines_e whichLine, ___2719 mIndex, ___2719 nIndex) const { if (m_numPartitions == 1) { return std::vector<ItemAddress64::___2981>(1, 0); } else { ___1843 lineMin(0, 0, 0); ___1843 lineMax(getZoneIJK() - 1); switch (whichLine) { case ___1856: lineMin.setJ(mIndex); lineMin.___3498(nIndex); lineMax.setJ(mIndex); lineMax.___3498(nIndex); break; case ___1858: lineMin.setI(mIndex); lineMin.___3498(nIndex); lineMax.setI(mIndex); lineMax.___3498(nIndex); break; case ___1859: lineMin.setI(mIndex); lineMin.setJ(nIndex); lineMax.setI(mIndex); lineMax.setJ(nIndex); break; default: ___476(___1303); break; } ___1852 ___2479(lineMin.i(), lineMin.___2104(), lineMin.___2133()); ___1852 ___2373(lineMax.i(), lineMax.___2104(), lineMax.___2133()); std::vector<___1863> ___2098; m_partitionTree.query(boost::geometry::index::intersects(___1854(___2479, ___2373)), std::back_inserter(___2098)); std::vector<ItemAddress64::___2981> ___3359; ___3359.reserve(___2098.size()); for (std::vector<___1863>::const_iterator it = ___2098.begin(); it != ___2098.end(); ++it) ___3359.push_back(it->second); std::sort(___3359.begin(), ___3359.end()); return ___3359; } } inline bool ijkPartitionMetadataIsLoaded(ItemAddress64::___2981 ___2978) const { return ___2978 < m_ijkZoneInfos.size() && m_ijkZoneInfos[___2978].___2066();
} inline ItemAddress64 cellAddressAtIJKPaddedCellIndex(___463 paddedCellIndex) const { REQUIRE(paddedCellIndex < getZoneIJK().getNumPaddedCells()); ItemAddress64 ___449; if (getNumPartitions() == 1) { ___449 = m_ijkZoneInfos[0].cellAddressAtPaddedCellIndex(paddedCellIndex); } else { ___1843 const ___4632 = getZoneIJK().ijkAtOffset(paddedCellIndex); ItemAddress64::___2981 const ___2978 = getPartitionForIJK(___4632); ___476(ijkPartitionMetadataIsLoaded(___2978)); ___1843 partitionIJK = ___4632 - m_ptnNodeMinIJKs[___2978]; if (partitionIJK.i() == m_ijkZoneInfos[___2978].___2896().i() - 1) partitionIJK.setI(partitionIJK.i() - 1); if (partitionIJK.___2104() == m_ijkZoneInfos[___2978].___2896().___2104() - 1) partitionIJK.setJ(partitionIJK.___2104() - 1); ___449 = m_ijkZoneInfos[___2978].cellAddressAtCellIJK(partitionIJK); ENSURE(___449.___2978() == ___2978); } return ___449; } inline ItemAddress64 nodeAddressAtIJKNodeIndex(___2719 ___2717) const { ItemAddress64 nodeAddress; if (getNumPartitions() == 1) { nodeAddress = m_ijkZoneInfos[0].nodeAddressAtNodeIndex(___2717); } else { ___1843 const ___4632 = getZoneIJK().ijkAtOffset(___2717); ItemAddress64::___2981 const ___2978 = getPartitionForIJK(___4632); ___476(ijkPartitionMetadataIsLoaded(___2978)); ___1843 const partitionIJK = ___4632 - m_ptnNodeMinIJKs[___2978]; nodeAddress = m_ijkZoneInfos[___2978].nodeAddressAtNodeIJK(partitionIJK); ENSURE(nodeAddress.___2978() == ___2978); } return nodeAddress; } ItemAddress64 cellAddressAtFECellIndex(___463 zoneCellIndex) const { REQUIRE(zoneCellIndex < ___1765()); ItemAddress64::___2981 ___2978 = 0; ItemAddress64::SectionOffset_t section = 0; ItemAddress64::___2981 const numPartitions = getNumPartitions(); for (; ___2978 < numPartitions; ++___2978) { bool foundLocation = false; for (section = 0; section < m_numSections; ++section) { ___463 const numSecPtnCells = m_secPtnNumCells[section][___2978]; foundLocation = zoneCellIndex < numSecPtnCells; if (foundLocation) break; zoneCellIndex -= numSecPtnCells; } if (foundLocation) break; } ___476(___2978 < numPartitions && section < m_numSections); ItemAddress64::SubzoneOffset_t  const szOffset = ItemAddress64::SubzoneOffset_t(zoneCellIndex >> ItemAddress64::ItemOffsetBitSize); ItemAddress64::ItemOffset_t const itemOffset = ItemAddress64::ItemOffset_t(zoneCellIndex & ItemAddress64::MAX_ITEM_OFFSET); return ItemAddress64(___2978, section, szOffset, itemOffset); } ItemAddress64 szlCellAddressAtFEUniformCellAddress(ItemAddress64 const& ___449) const { REQUIRE(___449.___2064()); REQUIRE(___449.sectionOffset() < m_numSections); REQUIRE(___449.___4259() < m_secNumElems[___449.sectionOffset()]); ItemAddress64::___2981 ___2978 = 0; ItemAddress64::___2981 const numPartitions = getNumPartitions(); ItemAddress64::___4262 secUniformOffset = ___449.___4259(); for (; ___2978 < numPartitions; ++___2978)
{ bool foundLocation = false; ___463 const numSecPtnCells = m_secPtnNumCells[___449.sectionOffset()][___2978]; foundLocation = secUniformOffset < numSecPtnCells; if (foundLocation) break; secUniformOffset -= numSecPtnCells; if (foundLocation) break; } ___476(___2978 < numPartitions); ItemAddress64::SubzoneOffset_t  const szOffset = ItemAddress64::SubzoneOffset_t(secUniformOffset >> ItemAddress64::ItemOffsetBitSize); ItemAddress64::ItemOffset_t const itemOffset = ItemAddress64::ItemOffset_t(secUniformOffset & ItemAddress64::MAX_ITEM_OFFSET); return ItemAddress64(___2978, ___449.sectionOffset(), szOffset, itemOffset); } ItemAddress64 uniformCellAddressAtFESzlCellAddress(ItemAddress64 const& ___449) const { REQUIRE(___449.isSzlItem()); REQUIRE(VALID_ITEM_ADDRESS(___449)); ___463 ___4259 = (___463(___449.subzoneOffset()) <<ItemAddress64::ItemOffsetBitSize) | ___449.itemOffset(); ItemAddress64::___2981 ___2978 = ___449.___2978(); ItemAddress64::SectionOffset_t const section = ___449.sectionOffset(); while (___2978 > 0) { --___2978; ___4259 += m_secPtnNumCells[section][___2978]; } return ItemAddress64{section, ___4259}; } ItemAddress64 nodeAddressAtFENodeIndex(___2719 zoneNodeIndex) const { REQUIRE(zoneNodeIndex < ___1767()); ItemAddress64::___2981 ___2978 = 0; ItemAddress64::___2981 numPartitions = getNumPartitions(); if ( numPartitions > 1 ) { while (true) { ___2719 const numPtnItems = m_ptnNumNodes[___2978]; if (zoneNodeIndex < numPtnItems) break; zoneNodeIndex -= numPtnItems; ++___2978; ___476(___2978 < numPartitions); } } ItemAddress64::SubzoneOffset_t  const szOffset = ItemAddress64::SubzoneOffset_t(zoneNodeIndex >> ItemAddress64::ItemOffsetBitSize); ItemAddress64::ItemOffset_t const itemOffset = ItemAddress64::ItemOffset_t(zoneNodeIndex & ItemAddress64::MAX_ITEM_OFFSET); return ItemAddress64(___2978, 0/*section*/, szOffset, itemOffset); } ___2719 nodeIndexAtFENodeAddress(ItemAddress64 const& nodeAddress) const { REQUIRE(m_isSZL); REQUIRE(VALID_ITEM_ADDRESS(nodeAddress)); ___2719 ___2717 = (___2719(nodeAddress.subzoneOffset())<<ItemAddress64::ItemOffsetBitSize) | nodeAddress.itemOffset(); ItemAddress64::___2981 ___2978 = nodeAddress.___2978(); while (___2978 > 0) { --___2978; ___2717 += m_ptnNumNodes[___2978]; } return ___2717; } ItemAddress64 paddedUniformCellAddressAtIJKSzlCellAddress(ItemAddress64 const& ___449) const { if (getNumPartitions() == 1) { return ItemAddress64{m_ijkZoneInfos[0].paddedCellIndexAtCellAddress(___449)}; } else { ItemAddress64::___2981 const ___2978 = ___449.___2978(); ___476(ijkPartitionMetadataIsLoaded(___2978)); ___1843 const cellIJK = m_ptnNodeMinIJKs[___2978] + m_ijkZoneInfos[___2978].cellIJKAtCellAddress(___449); return ItemAddress64{getZoneIJK().offsetAtIJK(cellIJK)}; } } ___2719 nodeIndexAtIJKNodeAddress(ItemAddress64 const& nodeAddress) const
{ REQUIRE(getZoneType() == ___4704); ___2719 ___2717; if (getNumPartitions() == 1) { ___2717 = m_ijkZoneInfos[0].nodeIndexAtNodeAddress(nodeAddress); } else { ItemAddress64::___2981 const ___2978 = nodeAddress.___2978(); ___476(ijkPartitionMetadataIsLoaded(___2978)); ___1843 const nodeIJK = m_ptnNodeMinIJKs[___2978] + m_ijkZoneInfos[___2978].nodeIJKAtNodeAddress(nodeAddress); ___2717 = getZoneIJK().offsetAtIJK(nodeIJK); } ENSURE(___2717 < ___1767()); return ___2717; } ___463 getNumIJKFaceNeighbors( ItemAddress64 const& ___449, FaceIndex_t          ___455) const { REQUIRE(m_isSZL); REQUIRE(___455 < NUM_IJK_CELL_FACES); ItemAddress64::___2981 const ___2978 = ___449.___2978(); ___476(ijkPartitionMetadataIsLoaded(___2978)); return m_ijkZoneInfos[___2978].getNumIJKFaceNeighbors(___449, ___455); } void getIJKFaceNeighbor( ItemAddress64 const& ___449, FaceIndex_t          ___455, ___463          neighborOffset, ItemAddress64&       fnCoord, ___4636&         fnZone) const { REQUIRE(___449.isSzlItem()); REQUIRE(m_isSZL); REQUIRE(___455 < NUM_IJK_CELL_FACES); REQUIRE(neighborOffset < getNumIJKFaceNeighbors(___449, ___455)); ItemAddress64::___2981 const ___2978 = ___449.___2978(); ___476(ijkPartitionMetadataIsLoaded(___2978)); m_ijkZoneInfos[___2978].getIJKFaceNeighbor(___449, ___455, neighborOffset, fnCoord, fnZone); if (fnCoord == ItemAddress64(___2750) && getNumPartitions() > 1) { ___1843 neighborCellIJK = m_ijkZoneInfos[___2978].cellIJKAtCellAddress(___449) + m_ptnNodeMinIJKs[___2978] + ___1880::ijkFaceNeighborOffset[___455]; if (0 <= neighborCellIJK && neighborCellIJK < getZoneIJK()) { ItemAddress64::___2981 neighborPartition = getPartitionForIJK(neighborCellIJK); neighborCellIJK -= m_ptnNodeMinIJKs[neighborPartition]; if (neighborCellIJK <= m_ijkZoneInfos[neighborPartition].___2197()) fnCoord = m_ijkZoneInfos[neighborPartition].cellAddressAtCellIJK(neighborCellIJK); } } } void getIJKFaceNeighbors( ItemAddress64 const&     ___449, FaceIndex_t              ___455, ___3270<ItemAddress64>& cellNeighbors, ___3270<___4636>&   zoneNeighbors, bool&                    isFaceCompletelyObscured) const { REQUIRE(VALID_ITEM_ADDRESS(___449)); REQUIRE(___455 < NUM_IJK_CELL_FACES); REQUIRE(cellNeighbors.empty()); REQUIRE(zoneNeighbors.empty()); ItemAddress64 szlCellAddr; bool const isCellAddressUniform = ___449.___2064(); if (isCellAddressUniform) { ___463 const paddedCellIndex = ___463(___449.___4259()); szlCellAddr = cellAddressAtIJKPaddedCellIndex(paddedCellIndex); } else { szlCellAddr = ___449; } ___463 const numNeighbors = getNumIJKFaceNeighbors(szlCellAddr, ___455); ___476(numNeighbors != 0); isFaceCompletelyObscured = true; cellNeighbors.reserve(numNeighbors); cellNeighbors.___3504(numNeighbors); zoneNeighbors.reserve(numNeighbors); zoneNeighbors.___3504(numNeighbors);
for (___463 n = 0; n < numNeighbors; ++n) { ItemAddress64 fnCoord; ___4636 fnZone; getIJKFaceNeighbor(szlCellAddr, ___455, n, fnCoord, fnZone); if (fnCoord.___2064() && fnCoord.___4259() == ___2750) { ___476(fnZone == ___2751); cellNeighbors[n] = ItemAddress64(___2750); zoneNeighbors[n] = ___2751; } else if (isCellAddressUniform) { cellNeighbors[n] = paddedUniformCellAddressAtIJKSzlCellAddress(fnCoord); zoneNeighbors[n] = fnZone; } else { cellNeighbors[n] = fnCoord; zoneNeighbors[n] = fnZone; } } ENSURE(!cellNeighbors.empty()); ENSURE(cellNeighbors.size() == zoneNeighbors.size()); } }; }}
