#include "SZLOrderedZoneWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <sstream>
#include <stdexcept>
#include <boost/assign.hpp>
#include "ThirdPartyHeadersEnd.h"
 #if !defined TECIOMPI
#include "AtomicMinMax.h"
 #endif
#include "checkPercentDone.h"
#include "FieldData.h"
#include "fileStuff.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
#include "writeValueArray.h"
namespace tecplot { namespace ___3934 {
 #if !defined TECIOMPI
namespace { int const MINMAX_MAX_TASKS_PER_CORE = 2; int const MINMAX_MIN_CSZ_TASK_SIZE  = 16; }
 #endif
SZLOrderedZoneWriter::SZLOrderedZoneWriter( uint32_t                                    fileVersion, ItemSetIterator&                            varIter, ___4636                                 zone, ___4636                                 ___341, std::vector<___372> const&               ___4564, ___372                                   ___4499, ___37&                                 ___36, boost::shared_ptr<___1880 const> const& ijkZoneInfo) : ___4709(fileVersion, varIter, zone, ___341, ___4564, ___4499, ___36) , m_headerWriter(fileVersion, varIter, zone, ___341, ___36, *ijkZoneInfo, ___2674) , m_ijkZoneInfo(ijkZoneInfo) , m_zoneNumberLabel(SZPLT_ZONE_NUM_DESCRIPTION) { ___4352 const numVarsToWrite = m_varIter.___2813(); if (!___2674.alloc(numVarsToWrite, ___330)) { std::ostringstream ___2893; ___2893 << "Unable to allocate arrays for outputting zone " << zone; throw std::runtime_error(___2893.str()); } } SZLOrderedZoneWriter::~SZLOrderedZoneWriter() {} void SZLOrderedZoneWriter::setZoneNumberLabel(std::string const& zoneNumberLabel) { REQUIRE(!zoneNumberLabel.empty()); m_zoneNumberLabel = zoneNumberLabel; } namespace { struct CellMinMaxData { ItemAddress64::SubzoneOffset_t cellSubzoneStart; ItemAddress64::SubzoneOffset_t cellSubzoneEnd; ___1880 const& ijkZoneInfo; ___1350 const& nlFieldData; ___1350 const& ccFieldData;
 #if defined TECIOMPI
___2482& cszMinMaxArray; ___2482& ___2763;
 #else
___2241<___225<double> >& cszMinMaxArray; ___2241<___225<double> >& ___2763;
 #endif
CellMinMaxData( ItemAddress64::SubzoneOffset_t cellSubzoneStart, ItemAddress64::SubzoneOffset_t cellSubzoneEnd, ___1880 const& ijkZoneInfo, ___1350 const& nlFieldData, ___1350 const& ccFieldData,
 #if defined TECIOMPI
___2482& cszMinMaxArray, ___2482& ___2763)
 #else
___2241<___225<double> >& cszMinMaxArray, ___2241<___225<double> >& ___2763)
 #endif
: cellSubzoneStart(cellSubzoneStart) , cellSubzoneEnd(cellSubzoneEnd) , ijkZoneInfo(ijkZoneInfo) , nlFieldData(nlFieldData) , ccFieldData(ccFieldData) , cszMinMaxArray(cszMinMaxArray) , ___2763(___2763) {} }; ___1843 calculateStoredNodeIJK(___1880 const& ijkZoneInfo) { ___1843 ___3359 = ijkZoneInfo.___2715(); if (!ijkZoneInfo.includeIMaxNodesInSubzones()) ___3359.setI(___3359.i() + 1); if (!ijkZoneInfo.includeJMaxNodesInSubzones()) ___3359.setJ(___3359.___2104() + 1); if (!ijkZoneInfo.includeKMaxNodesInSubzones()) ___3359.___3498(___3359.___2133() + 1); return ___3359; } void calculateAndApplyCellMinMaxes(___90 ___2122) { CellMinMaxData* cellMinMaxData = reinterpret_cast<CellMinMaxData*>(___2122); REQUIRE(cellMinMaxData->nlFieldData.___2066()); ___1843 outputIJK = cellMinMaxData->ijkZoneInfo.___2715(); ___1843 storedIJK = calculateStoredNodeIJK(cellMinMaxData->ijkZoneInfo); ___81 cellCorners[] = { 0, 1, storedIJK.i(), storedIJK.i() + 1, storedIJK.i() * storedIJK.___2104(), storedIJK.i() * storedIJK.___2104() + 1, storedIJK.i() * storedIJK.___2104() + storedIJK.i(), storedIJK.i() * storedIJK.___2104() + storedIJK.i() + 1 }; ___81 nodes[8]; ___3270<___81> nodeArray(nodes, 8); for (ItemAddress64::SubzoneOffset_t ___467 = cellMinMaxData->cellSubzoneStart; ___467 < cellMinMaxData->cellSubzoneEnd; ++___467) { ___1843 ___1879 = cellMinMaxData->ijkZoneInfo.___688(___467); ___1843 ___1851 = cellMinMaxData->ijkZoneInfo.___687(___467); for (___81 i = ___1879.i(); i <= ___1851.i(); ++i) { for (___81 ___2104 = ___1879.___2104(); ___2104 <= ___1851.___2104(); ++___2104) { for (___81 ___2133 = ___1879.___2133(); ___2133 <= ___1851.___2133(); ++___2133) { ___2480 cellMinMax; ___81 const datasetPt = (___2133 * storedIJK.___2104() + ___2104) * storedIJK.i() + i; for (int n = 0; n < 8; ++n) cellMinMax.include(cellMinMaxData->nlFieldData.___1779(datasetPt + cellCorners[n] + 1)); nodeArray.clear(); nodeArray.push_back((___2133 * outputIJK.___2104() + ___2104) * outputIJK.i() + i); if (i < outputIJK.i() - 1) nodeArray.push_back(nodeArray[0] + 1); if (___2104 < outputIJK.___2104() - 1) { size_t ___2822 = nodeArray.size(); for (size_t n = 0; n < ___2822; ++n) nodeArray.push_back(nodeArray[n] + outputIJK.i()); } if (___2133 < outputIJK.___2133() - 1) { size_t ___2822 = nodeArray.size(); for (size_t n = 0; n < ___2822; ++n) nodeArray.push_back(nodeArray[n] + outputIJK.i() * outputIJK.___2104()); } for (size_t n = 0; n < nodeArray.size(); ++n) { ItemAddress64::SubzoneOffset_t ___2735 = cellMinMaxData->ijkZoneInfo.nodeSubzoneOffsetAtNodeIndex(nodeArray[n]); cellMinMaxData->___2763[___2735].include(cellMinMax); } if (cellMinMaxData->ccFieldData.___2066()) cellMinMax.include(cellMinMaxData->ccFieldData.___1779(datasetPt + 1)); cellMinMaxData->cszMinMaxArray[___467].include(cellMinMax); } } } } delete cellMinMaxData; } ___372 getIJKCellAndNodeSubzoneMinMaxes( ___37& ___36, ___1880 const& ijkZoneInfo, ___4352 fileVar, ___1350 const& nlFieldData, ___1350 const& ccFieldData, ___2482& cszMinMaxArray, ___2482& ___2763)
{ REQUIRE(fileVar >= 0); REQUIRE(nlFieldData.___2066()); REQUIRE("ccFieldData might be invalid if not CC data"); ___372 ___2038 = ___4227; ItemAddress64::SubzoneOffset_t const ___2784 = ijkZoneInfo.getNumCszs();
 #if !defined NO_ASSERTS || !defined TECIOMPI
ItemAddress64::SubzoneOffset_t const ___2824 = ijkZoneInfo.getNumNszs();
 #endif
 #ifndef NO_ASSERTS
for (ItemAddress64::SubzoneOffset_t ___2735 = 0; ___2735 < ___2824; ___2735++) ___476(!___2763[___2735].___2066()); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2784; ___467++) ___476(!cszMinMaxArray[___467].___2066());
 #endif
 #if defined TECIOMPI
___4279(___36); CellMinMaxData* cellMinMaxData = new CellMinMaxData(0, ___2784, ijkZoneInfo, nlFieldData, ccFieldData, cszMinMaxArray, ___2763); calculateAndApplyCellMinMaxes(reinterpret_cast<___90>(cellMinMaxData));
 #else
___2241<___225<double> > atomicCszMinMaxArray; ___2241<___225<double> > atomicNszMinMaxArray; ___2038 = atomicCszMinMaxArray.alloc(___2784) && atomicNszMinMaxArray.alloc(___2824); if (___2038) { size_t const maxNumTasks = static_cast<size_t>(___36.___4158() * MINMAX_MAX_TASKS_PER_CORE); size_t const numCszTasksAtMinJobSize = static_cast<size_t>(___2784 + MINMAX_MIN_CSZ_TASK_SIZE - 1) / MINMAX_MIN_CSZ_TASK_SIZE; size_t const numCszTasks = std::min(numCszTasksAtMinJobSize, maxNumTasks); ___2119 ___2118 = ___36.___4159(); ItemAddress64::SubzoneOffset_t cellSubzoneStart = 0; for (size_t task = 1; task <= numCszTasks; ++task) { ItemAddress64::SubzoneOffset_t const cellSubzoneEnd = static_cast<ItemAddress64::SubzoneOffset_t>(___2784 * task / numCszTasks); ___476(cellSubzoneStart < cellSubzoneEnd); CellMinMaxData* cellMinMaxData = new CellMinMaxData(cellSubzoneStart, cellSubzoneEnd, ijkZoneInfo, nlFieldData, ccFieldData, atomicCszMinMaxArray, atomicNszMinMaxArray); ___36.___4157(calculateAndApplyCellMinMaxes, (___90)cellMinMaxData, ___2118); cellSubzoneStart = cellSubzoneEnd; } ___36.___4162(___2118); ___36.___4160(&___2118); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2784; ++___467) { ENSURE(atomicCszMinMaxArray[___467].___2066()); cszMinMaxArray[___467].include(atomicCszMinMaxArray[___467].minValue()); cszMinMaxArray[___467].include(atomicCszMinMaxArray[___467].maxValue()); } for (ItemAddress64::SubzoneOffset_t ___2735 = 0; ___2038 && ___2735 < ___2824; ++___2735) { ENSURE(atomicNszMinMaxArray[___2735].___2066()); ___2763[___2735].include(atomicNszMinMaxArray[___2735].minValue()); ___2763[___2735].include(atomicNszMinMaxArray[___2735].maxValue()); } atomicCszMinMaxArray.___935(); atomicNszMinMaxArray.___935(); }
 #endif
if (___2038) { ___1880::NszMinMaxMap const& nszMinMaxes = ijkZoneInfo.getNszMinMaxes(); for (___1880::NszMinMaxMap::const_iterator valuePair = nszMinMaxes.begin(); valuePair != nszMinMaxes.end(); ++valuePair) { ___2763[valuePair->first].include(valuePair->second[fileVar]); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 SZLOrderedZoneWriter::calculateVarSubzoneMinMaxes( ___4352   datasetVar, ___2482& ___2763, ___2482& cszMinMaxArray) { REQUIRE(cszMinMaxArray.empty()); REQUIRE(___2763.empty()); REQUIRE(m_writeVariables[datasetVar - m_varIter.baseItem()]); ___372 ___2038 = ___4227; ___2038 = ___2038 && cszMinMaxArray.alloc(m_ijkZoneInfo->getNumCszs(), ___2480()); ___2038 = ___2038 && ___2763.alloc(m_ijkZoneInfo->getNumNszs(), ___2480()); if (___2038) { if (___2338.___908(___2678 + 1, datasetVar + 1) == ___4330) { ___1350 nlFieldData(&___2338, ___2678 + 1, datasetVar + 1, false , false/*___962*/); ___1350 ccFieldData; ___2038 = nlFieldData.___2066() && getIJKCellAndNodeSubzoneMinMaxes(___2338, *m_ijkZoneInfo, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, cszMinMaxArray, ___2763); } else { ___1350 nlFieldData(&___2338, ___2678 + 1, datasetVar + 1, false , true/*___962*/); ___1350 ccFieldData(&___2338, ___2678 + 1, datasetVar + 1, false , false/*___962*/); ___2038 = nlFieldData.___2066() && ccFieldData.___2066() && getIJKCellAndNodeSubzoneMinMaxes(___2338, *m_ijkZoneInfo, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, cszMinMaxArray, ___2763); } } return ___2038; } ___372 SZLOrderedZoneWriter::___4512( FileWriterInterface&           file, ValueLocation_e                ___4326, ___4352                     datasetVar, ItemAddress64::SubzoneOffset_t ___3881) { REQUIRE(file.___2040()); REQUIRE(___4326 == ___4328 || ___4326 == ___4330); ___372 ___2038 = ___4227; if (file.___2001()) { if (___4326 == ___4328) ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, SZPLT_CSZ_FIELD_DATA_MARKER_DESCRIPTION, SZPLT_CSZ_FIELD_DATA_MARKER); else ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, SZPLT_NSZ_FIELD_DATA_MARKER_DESCRIPTION, SZPLT_NSZ_FIELD_DATA_MARKER); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, SZPLT_VARIABLE_NUM_DESCRIPTION, (datasetVar - m_varIter.baseItem()) + 1); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), ___2678 - m_baseZone + 1); ___2038 = ___2038 && writeValue<uint64_t, false, 0>(file, SZPLT_SUBZONE_NUM_DESCRIPTION, ___3881 + 1); ___1843 const ___1879 = (___4326 == ___4328) ? m_ijkZoneInfo->___688(___3881) : m_ijkZoneInfo->___2762(___3881); ___1843 const ___1851 = (___4326 == ___4328) ? m_ijkZoneInfo->___687(___3881) : m_ijkZoneInfo->___2761(___3881); ___2038 = ___2038 && writeValue<uint64_t, false, 0>(file, SZL_ISTART_DESCRIPTION, ___1879.i()+1);
___2038 = ___2038 && writeValue<uint64_t, false, 0>(file, SZL_IEND_DESCRIPTION, ___1851.i()+1); ___2038 = ___2038 && writeValue<uint64_t, false, 0>(file, SZL_JSTART_DESCRIPTION, ___1879.___2104()+1); ___2038 = ___2038 && writeValue<uint64_t, false, 0>(file, SZL_JEND_DESCRIPTION, ___1851.___2104()+1); ___2038 = ___2038 && writeValue<uint64_t, false, 0>(file, SZL_KSTART_DESCRIPTION, ___1879.___2133()+1); ___2038 = ___2038 && writeValue<uint64_t, false, 0>(file, SZL_KEND_DESCRIPTION, ___1851.___2133()+1); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template<typename T, bool isBitArray  > ___372 SZLOrderedZoneWriter::___1778( ___1350 const& ___1349, ___1843 const&       ___1879, ___1843 const&       ___1851, ___1843 const&       ___1860, ___2241<T>& ___4300) { ___372 ___2038 = ___4227; REQUIRE(___1349.___2066()); REQUIRE(___1860.i() >=2 && ___1860.___2104() >= 2); REQUIRE(0<=___1879 && ___1879 <= ___1851 && ___1851 < ___1860); size_t const ___3269 = size_t(___1876(___1879, ___1851)); ___476(___4300.empty()); ___2038 = ___2038 && ___4300.alloc(___3269); T* rawPointer = static_cast<T*>(___1349.getRawPointer()); if (___2038) { ___81 const ijMax = ___1860.i()*___1860.___2104(); ___81 ___4301 = 0; for ( ___81 ___2157 = ___1879.___2133(); ___2157 <= ___1851.___2133(); ___2157++ ) { ___81 const ___2163 = ___2157*ijMax; for ( ___81 ___2112 = ___1879.___2104(); ___2112 <= ___1851.___2104(); ___2112++ ) { ___81 const jkOffset = ___2163 + ___2112*___1860.i(); for ( ___81 ___1840 = ___1879.i(); ___1840 <= ___1851.i(); ___1840++ ) { ___81 const datasetPt = jkOffset + ___1840; if (rawPointer) ___4300[___4301] = rawPointer[datasetPt]; else ___4300[___4301] = static_cast<T>(___1349.___1779(datasetPt + 1)); ___4301++; } } } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template<> ___372 SZLOrderedZoneWriter::___1778<uint8_t, true>( ___1350 const& ___1349, ___1843 const&       ___1879, ___1843 const&       ___1851, ___1843 const&       ___1860, ___2241<uint8_t>& ___4300) { ___372 ___2038 = ___4227; REQUIRE(___1349.___2066()); REQUIRE(___1860>=2); REQUIRE(0<=___1879 && ___1879 <= ___1851 && ___1851 < ___1860); size_t const ___3269 = size_t(numBytesForNumBits(___1876(___1879, ___1851))); ___476(___4300.empty()); ___2038 = ___2038 && ___4300.alloc(___3269); memset(___4300.data(), 0, ___3269); if (___2038) { ___81 const ijMax = ___1860.i()*___1860.___2104(); ___81 ___4301 = 0; for ( ___81 ___2157 = ___1879.___2133(); ___2157 <= ___1851.___2133(); ___2157++ ) { ___81 const ___2163 = ___2157*ijMax; for ( ___81 ___2112 = ___1879.___2104(); ___2112 <= ___1851.___2104(); ___2112++ ) { ___81 const jkOffset = ___2163 + ___2112*___1860.i(); for ( ___81 ___1840 = ___1879.i(); ___1840 <= ___1851.i(); ___1840++ ) { ___81 const datasetPt = jkOffset + ___1840 + 1; double const ___4299 = ___1349.___1779(datasetPt); if (___4299 < 1.0) clearBit(___4300, ___4301); else setBit(___4300, ___4301); ___4301++; } } } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <typename T, bool isBitArray> ___372 SZLOrderedZoneWriter::___4496(
FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SubzoneOffset_t ___467) { ___372 ___2038 = ___4227; REQUIRE(szpltFile.___2040()); REQUIRE(___1349.___2066()); REQUIRE(___1349.___1785() == ___4328); ___2241<T> valueArray; ItemAddress64::ItemOffset_t ___2783 = m_ijkZoneInfo->getNumCellsInCsz(___467); ___1843 const cellIJKStart = m_ijkZoneInfo->___688(___467); ___1843 const cellIJKEnd   = m_ijkZoneInfo->___687(___467); ___2038 = ___2038 && ___1778<T, isBitArray>( ___1349, cellIJKStart, cellIJKEnd, m_ijkZoneInfo->___2896(), valueArray); if (isBitArray) ___2038 = ___2038 && ___4563<T, false, 0>(szpltFile, "cszFieldData", ___2746, numBytesForNumBits(___2783), valueArray.data()); else ___2038 = ___2038 && ___4563<T, false, 0>(szpltFile, "cszFieldData", ___2746, ___2783, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <typename T, bool isBitArray> ___372 SZLOrderedZoneWriter::___4531( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ___1843 const&                     storedIJK, ItemAddress64::SubzoneOffset_t ___2735) { ___372 ___2038 = ___4227; REQUIRE(szpltFile.___2040()); REQUIRE(___1349.___2066()); REQUIRE(___1349.___1785() == ___4330); ___2241<T> valueArray; ItemAddress64::ItemOffset_t ___2823 = m_ijkZoneInfo->getNumNodesInNsz(___2735); ___1843 const nodeIJKStart = m_ijkZoneInfo->___2762(___2735); ___1843 const nodeIJKEnd   = m_ijkZoneInfo->___2761(___2735); ___2038 = ___2038 && ___1778<T, isBitArray>( ___1349, nodeIJKStart, nodeIJKEnd, storedIJK, valueArray); if (isBitArray) ___2038 = ___2038 && ___4563<T, false, 0>(szpltFile, "nszFieldData", ___2746, numBytesForNumBits(___2823), valueArray.data()); else ___2038 = ___2038 && ___4563<T, false, 0>(szpltFile, "nszFieldData", ___2746, ___2823, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <typename T, bool isBitArray> ___372 SZLOrderedZoneWriter::writeVariable( FileWriterInterface&     szpltFile, ___4352 const         datasetVar, ___2482 const&       nszDataMinMax, ___2482 const&       cszDataMinMax) { ItemAddress64::SubzoneOffset_t const ___2784 = m_ijkZoneInfo->getNumCszs(); ItemAddress64::SubzoneOffset_t const ___2824 = m_ijkZoneInfo->getNumNszs(); ___4352 const fileVar = datasetVar - m_varIter.baseItem(); ___372 ___2038 = ___4528<T>(szpltFile, NODE_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar, ___2824, nszDataMinMax.data(), ___944 / 2) && ___4528<T>(szpltFile, CELL_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar, ___2784, cszDataMinMax.data(), ___944 / 2);
___1350 ___1349(&___2338, ___2678 + 1, datasetVar + 1); ___2038 = ___2038 && ___1349.___2066(); ValueLocation_e const ___4326 = ___1349.___1785(); ItemAddress64::SubzoneOffset_t const numDataSubzones = (___4326 == ___4328) ? ___2784 : ___2824; ___1843 storedNodeIJK = calculateStoredNodeIJK(*m_ijkZoneInfo); for (ItemAddress64::SubzoneOffset_t ___3924 = 0; ___2038 && ___3924 < numDataSubzones; ___3924++) { ___2038 = ___4512(szpltFile, ___4326, datasetVar, ___3924); if (___4326 == ___4328) ___2038 = ___2038 && ___4496<T, isBitArray>(szpltFile, ___1349, ___3924); else ___2038 = ___2038 && ___4531<T, isBitArray>(szpltFile, ___1349, storedNodeIJK, ___3924); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 SZLOrderedZoneWriter::writeZoneData(FileWriterInterface& szpltFile) {
 #if defined OUTPUT_TIMES
uint64_t ___3688 = ___715(); uint64_t minMaxTime = 0; uint64_t ___4549 = 0;
 #endif
___372 ___2038 = ___4227; ___2482 ___2763; ___2482 cszMinMaxArray; m_varIter.reset(); ___4352 const baseVar = m_varIter.baseItem(); while (___2038 && m_varIter.hasNext()) { ___4352 const datasetVar = m_varIter.next(); ___4352 const fileVar = datasetVar - baseVar; if (!m_writeVariables[fileVar]) continue; ___2338.___856(); ___2038 = ___483(SzPltWriteOperation_WriteFieldData, ___2338, datasetVar, ___2678); ___2038 = ___2038 && calculateVarSubzoneMinMaxes(datasetVar, ___2763, cszMinMaxArray);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); minMaxTime += (___1165 - ___3688); ___3688 = ___1165;
 #endif
___2674[fileVar] = szpltFile.fileLoc(); if (___2038) { switch (___2338.___921(___2678 + 1, datasetVar + 1)) { case FieldDataType_Float: ___2038 = writeVariable<float, false>(szpltFile, datasetVar, ___2763, cszMinMaxArray); break; case FieldDataType_Double: ___2038 = writeVariable<double, false>(szpltFile, datasetVar, ___2763, cszMinMaxArray); break; case FieldDataType_Int32: ___2038 = writeVariable<int32_t, false>(szpltFile, datasetVar, ___2763, cszMinMaxArray); break; case FieldDataType_Int16: ___2038 = writeVariable<int16_t, false>(szpltFile, datasetVar, ___2763, cszMinMaxArray); break; case FieldDataType_Byte: ___2038 = writeVariable<uint8_t, false>(szpltFile, datasetVar, ___2763, cszMinMaxArray); break; case ___1363: ___2038 = writeVariable<uint8_t, true>(szpltFile, datasetVar, ___2763, cszMinMaxArray); break; default: ___476(___1303); break; } } ___2763.___935(); cszMinMaxArray.___935();
 #if defined OUTPUT_TIMES
___1165 = ___715(); ___4549 += (___1165 - ___3688); ___3688 = ___1165;
 #endif
___2338.___857(); }
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1930(NULL, "%g seconds calculating variable ranges.", (double)(minMaxTime) / 1000.0); ___1930(NULL, "%g seconds writing zone data.", (double)(___4549) / 1000.0);
 #endif
ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } uint64_t SZLOrderedZoneWriter::fieldDataSubzoneHeaderFileSize(bool ___2001) { if (___2001) return 3 * valueSizeInFile<uint32_t, false>(___2001) + 7 * valueSizeInFile<uint64_t, false>(___2001); else return 0; } template <typename T, bool isBitArray> uint64_t SZLOrderedZoneWriter::cellSubzoneFieldDataFileSize(bool ___2001, ItemAddress64::SubzoneOffset_t ___467) const { size_t ___2783 = static_cast<size_t>(m_ijkZoneInfo->getNumCellsInCsz(___467)); return arraySizeInFile<T, false>(___2783, ___2001); } template <> uint64_t SZLOrderedZoneWriter::cellSubzoneFieldDataFileSize<uint8_t, true>(bool ___2001, ItemAddress64::SubzoneOffset_t ___467) const { size_t ___2783 = static_cast<size_t>(m_ijkZoneInfo->getNumCellsInCsz(___467)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2783), ___2001); } template <typename T, bool isBitArray> uint64_t SZLOrderedZoneWriter::nodeSubzoneFieldDataFileSize(bool ___2001, ItemAddress64::SubzoneOffset_t ___2735) const { size_t ___2823 = static_cast<size_t>(m_ijkZoneInfo->getNumNodesInNsz(___2735)); return arraySizeInFile<T, false>(___2823, ___2001); } template <> uint64_t SZLOrderedZoneWriter::nodeSubzoneFieldDataFileSize<uint8_t, true>(bool ___2001, ItemAddress64::SubzoneOffset_t ___2735) const { size_t ___2823 = static_cast<size_t>(m_ijkZoneInfo->getNumNodesInNsz(___2735)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2823), ___2001); } template <typename T, bool isBitArray> uint64_t SZLOrderedZoneWriter::subzoneFieldDataFileSize(bool ___2001, ItemAddress64::SubzoneOffset_t ___3881, ValueLocation_e ___4326) const { if (___4326 == ___4328) return cellSubzoneFieldDataFileSize<T, isBitArray>(___2001, ___3881); else return nodeSubzoneFieldDataFileSize<T, isBitArray>(___2001, ___3881); } template <typename T, bool isBitArray> uint64_t SZLOrderedZoneWriter::variableFileSize(bool ___2001, ValueLocation_e ___4326) { uint64_t ___3359 = 0; ItemAddress64::SubzoneOffset_t const ___2824 = m_ijkZoneInfo->getNumNszs(); ___3359 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2824), ___2001); ItemAddress64::SubzoneOffset_t const ___2784 = m_ijkZoneInfo->getNumCszs(); ___3359 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2784), ___2001); ItemAddress64::SubzoneOffset_t const numDataSubzones = (___4326 == ___4328) ? ___2784 : ___2824; for (ItemAddress64::SubzoneOffset_t ___3924 = 0; ___3924 < numDataSubzones; ___3924++) { ___3359 += fieldDataSubzoneHeaderFileSize(___2001); ___3359 += subzoneFieldDataFileSize<T, isBitArray>(___2001, ___3924, ___4326); } return ___3359; } uint64_t SZLOrderedZoneWriter::zoneDataFileSize(bool ___2001) { uint64_t ___3359 = 0; m_varIter.reset(); ___4352 const firstVarToWrite = m_varIter.baseItem();
while (m_varIter.hasNext()) { ___4352 const datasetVar = m_varIter.next(); ___4352 const fileVar = datasetVar - firstVarToWrite; if (!m_writeVariables[fileVar]) continue; FieldDataType_e const ___1361 = ___2338.___921(___2678 + 1, datasetVar + 1); ValueLocation_e const ___4326 = ___2338.___908(___2678 + 1, datasetVar + 1); switch (___1361) { case FieldDataType_Float: ___3359 += variableFileSize<float, false>(___2001, ___4326); break; case FieldDataType_Double: ___3359 += variableFileSize<double, false>(___2001, ___4326); break; case FieldDataType_Int32: ___3359 += variableFileSize<int32_t, false>(___2001, ___4326); break; case FieldDataType_Int16: ___3359 += variableFileSize<int16_t, false>(___2001, ___4326); break; case FieldDataType_Byte: ___3359 += variableFileSize<uint8_t, false>(___2001, ___4326); break; case ___1363: ___3359 += variableFileSize<uint8_t, true>(___2001, ___4326); break; default: ___476(___1303); break; } } return ___3359; } ___372 SZLOrderedZoneWriter::writeZoneConnectivity(FileWriterInterface&  ) { return ___4227; } uint64_t SZLOrderedZoneWriter::zoneConnectivityFileSize(bool  ) { return 0; } uint64_t SZLOrderedZoneWriter::zoneHeaderFileSize(bool ___2001) { return m_headerWriter.sizeInFile(___2001); } ___372 SZLOrderedZoneWriter::writeZoneHeader(FileWriterInterface& szpltFile) { return m_headerWriter.write(szpltFile); } }}
