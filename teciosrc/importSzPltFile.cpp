#include "importSzPltFile.h"
#include "ThirdPartyHeadersBegin.h"
#include <cctype>
#include <cfloat>
#include <limits>
#include <locale>
#include <string>
#include <boost/assign.hpp>
#include <boost/function.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "BitArray.h"
#include "CszConnectivity.h"
#include "FECellSubzoneCompressor.h"
#include "FEZoneInfo.h"
#include "fileStuff.h"
#include "FileReaderInterface.h"
#include "IJK.h"
#include "IJKPartitionTree.h"
#include "IJKZoneInfo.h"
#include "PartitionMetadata.h"
#include "RawArray.h"
#include "Scanner.h"
#include "readValueArray.h"
#include "xyz.h"
#include "ZoneMetadata.h"
#include "ZoneVarMetadata.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3934 { ___372 readDataFileHeader( ___1397& file, ___1386&     ___1385, uint64_t&            byteOrderIndicator, uint64_t&            dataSetHeaderLocation) { ___372 ___2038 = ___4227; char textOrBinary = '\0'; if (!file.___3461()) ___2038 = ___1184("Can't read SZPLT file."); tecplot::___3442 headerScanner; size_t const headerBufferSize = 128; char headerBuffer[headerBufferSize]; if (___2038 && !(file.fgets(headerBuffer, headerBufferSize) != NULL && headerBuffer[strlen(headerBuffer)-1] == '\n')) ___2038 = ___1184("SZPLT file has incorrect header. Cannot parse file header info."); uint32_t  fileVersion = 0; if (___2038) { headerScanner.reset(headerBuffer); char const* const fileTypeID = "#!" SZPLT_FILE_TYPE; if (___2038 && !(headerScanner.next(strlen(fileTypeID)) == fileTypeID && headerScanner.next(1) == " ")) ___2038 = ___1184("SZPLT file has incorrect header. File type is not correct."); if (___2038 && !headerScanner.hasNextInt64Token("BT")) ___2038 = ___1184("SZPLT file has incorrect header. Version format is not correct."); if (___2038) fileVersion = static_cast<uint32_t>(headerScanner.nextInt64Token("BT")); if (___2038 && fileVersion < SZPLT_MIN_READ_VERSION) ___2038 = ___1184("SZPLT file is an older version %" PRIu32 " that is no longer supported.", fileVersion); if (___2038 && fileVersion > SZPLT_MAX_READ_VERSION ) ___2038 = ___1184("SZPLT file is an newer version %" PRIu32 " that is not supported by the current loader. Try updating your Tecplot.", fileVersion); if (___2038 && !headerScanner.hasNextChar()) ___2038 = ___1184("SZPLT file has incorrect header. Missing text or binary designator."); if (___2038) textOrBinary = headerScanner.nextChar(); if (___2038 && textOrBinary != 'B' && textOrBinary != 'T') ___2038 = ___1184("SZPLT file has incorrect header. Cannot determine binary or text file type."); } ___372 ___2001 = ___1303; DataFileType_e ___842 = ___845; if (___2038) { ___2001 = textOrBinary == 'T'; ___842 = ___843; if (fileVersion >= 105) { char dataFileTypeChar = '\0'; ___2038 = headerScanner.hasNextChar(); if (___2038) dataFileTypeChar = headerScanner.nextChar(); if (___2038) { if (dataFileTypeChar == 'F') ___842 = ___843; else if (dataFileTypeChar == 'G') ___842 = ___844; else if (dataFileTypeChar == 'S') ___842 = ___846; else ___2038 = ___1184("SZPLT file has incorrect header. Expected data file type identifier."); } else { ___2038 = ___1184("SZPLT file has incorrect header. Expected data file type identifier."); } } } uint32_t codeRevision = 0; if (___2038 && headerScanner.hasNextToken() && headerScanner.nextToken() == " $Revision: " && headerScanner.hasNextInt64Token()) codeRevision = static_cast<uint32_t>(headerScanner.nextInt64Token()); else codeRevision = 0; if (___2038) { file.___3495(___2001); file.setDataFileType(___842); ___1385.setFileVersion(fileVersion); ___1385.___3495(___2001);
___1385.setDataFileType(___842); ___1385.setCodeRevision(codeRevision); } byteOrderIndicator = 0; ___2038 = ___2038 && readValue<uint64_t, true>(file, byteOrderIndicator, IODescription(___1384)); ___476(IMPLICATION(___2038, byteOrderIndicator == ___1383)); dataSetHeaderLocation = 0; ___2038 = ___2038 && readValue<uint64_t, true>(file, dataSetHeaderLocation, IODescription(___893)); ___476(IMPLICATION(___2038, dataSetHeaderLocation != 0)); return ___2038; } namespace { ___372 readTagList( ___1397& file, ___3943&   tagDescriptionMap, ___3946&         ___3945) { uint16_t numTags; ___372 ___2038 = readValue<uint16_t, false>(file, numTags, IODescription(___2840)); UInt16Array tagArray; size_t arraySize = static_cast<size_t>(numTags); ___2038 = ___2038 && tagArray.alloc(arraySize); ___2038 = ___2038 && readValueArray<uint16_t, false, 0>(file, 0, arraySize, tagArray, IODescription(___3944)); try { for(size_t i = 0; ___2038 && i < arraySize; ++i) { uint16_t tag = tagArray[i]; ___3943::const_iterator it = tagDescriptionMap.find(tag); if (it == tagDescriptionMap.end()) { ___2038 = ___1930("Unrecognized tag while reading file header: %d. Attempting to continue...", tag); if (___2038) { if (file.___2001()) { int c = file.getc(); while(!file.feof() && c != '\n') c = file.getc(); if (file.feof()) ___2038 = ___1184("End-of-file encountered attempting to skip unrecognized tag."); } else { uint64_t unused; if (file.fread(&unused, sizeof(unused), size_t(1)) != 1) ___2038 = ___1184("Read error while attempting to skip unrecognized tag."); } } } else { ___2038 = ___2038 && readValue<uint64_t, true>(file, ___3945[tag], IODescription(tagDescriptionMap[tag].c_str())); } } } catch(...) { ___2038 = ___1184("Error while reading file tags, possibly out of memory."); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 ensureRequiredHeaderTagValuesArePresent( const char* headerTypeString, ___3946 const& ___3945, ___3943& tagDescriptionMap, std::vector<uint16_t> const& tagList) { for (std::vector<uint16_t>::const_iterator tag = tagList.begin(); tag != tagList.end(); ++tag) { ___3946::const_iterator it = ___3945.find(*tag); if (it == ___3945.end()) return ___1184("Missing required %s header tag %" PRIu64 ", '%s'.", headerTypeString, uint64_t(*tag), tagDescriptionMap[*tag].c_str()); } return ___4227; } } namespace { template <typename T> ___372 retrieveRequiredNonZeroValue(___3946 const& ___3945, uint16_t tag, char const* ___2686, T& value) { ___372 ___2038 = ___4227; ___3946::const_iterator it = ___3945.find(tag); if (it == ___3945.end()) ___2038 = ___1184("Missing value for '%s' while reading file header.", ___2686); else value = static_cast<T>(it->second); if (___2038 && value == static_cast<T>(0)) ___2038 = ___1184("Invalid value (0) for '%s' while reading file header.", ___2686); ENSURE(VALID_BOOLEAN(___2038));
return ___2038; } } ___372 readDataSetHeaderTags( ___1397& file, ___1386&     ___1385, ___3946&         ___3945) { REQUIRE(file.___2040()); ___3943 tagDescriptionMap = DATASET_HEADER_TAG_DESCRIPTIONS_MAP_INITIALIZER; std::vector<uint16_t> tagList; tagList.reserve(tagDescriptionMap.size()); for (___3943::const_iterator it = tagDescriptionMap.begin(); it != tagDescriptionMap.end(); ++it) { bool const addTag = it->first != DATA_SET_TITLE_TAG && it->first != NUM_PARTITION_FILES_TAG && (___1385.getFileVersion() <= 105 && it->first != ZONE_NUM_SECTIONS_FILE_LOC_TAG && it->first != ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG && it->first != ZONE_CELL_SHAPE_PER_SECTION_FILE_LOC_TAG && it->first != ZONE_GRID_ORDER_PER_SECTION_FILE_LOC_TAG && it->first != ZONE_CELL_BASIS_FUNC_PER_SECTION_FILE_LOC_TAG); if (addTag) tagList.push_back(it->first); } ___372 ___2038 = readTagList(file, tagDescriptionMap, ___3945); ___2038 = ___2038 && ensureRequiredHeaderTagValuesArePresent("file", ___3945, tagDescriptionMap, tagList); if (___2038) { ___81 subzoneMaxISize = 0; ___81 subzoneMaxJSize = 0; ___81 subzoneMaxKSize = 0; ItemAddress64::ItemOffset_t subzoneMaxFESize = 0; if (retrieveRequiredNonZeroValue(___3945, SUBZONE_MAX_I_SIZE_TAG, SUBZONE_MAX_I_SIZE_DESCRIPTION, subzoneMaxISize) && retrieveRequiredNonZeroValue(___3945, SUBZONE_MAX_J_SIZE_TAG, SUBZONE_MAX_J_SIZE_DESCRIPTION, subzoneMaxJSize) && retrieveRequiredNonZeroValue(___3945, SUBZONE_MAX_K_SIZE_TAG, SUBZONE_MAX_K_SIZE_DESCRIPTION, subzoneMaxKSize) && retrieveRequiredNonZeroValue(___3945, SUBZONE_MAX_FE_SIZE_TAG, SUBZONE_MAX_FE_SIZE_DESCRIPTION, subzoneMaxFESize)) { ___1385.setMaxIJKSubzoneSize(___1843(subzoneMaxISize, subzoneMaxJSize, subzoneMaxKSize)); ___1385.setMaxFESubzoneSize(subzoneMaxFESize); } else { ___2038 = ___1303; } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } namespace { template <typename T> ___372 retrieveRequiredValue(___3946 const& ___3945, uint16_t tag, char const* ___2686, T& value) { ___372 ___2038 = ___4227; ___3946::const_iterator it = ___3945.find(tag); if (it == ___3945.end()) ___2038 = ___1184("Missing value for '%s' while reading file header.", ___2686); else value = static_cast<T>(it->second); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 applyDataSetHeaderScalarTagValues( ___3946 const& ___3945, ___4352& ___2844, ___4636& ___2847) { ___372 ___2038 = retrieveRequiredValue(___3945, ___2846, NUM_VARS_DESCRIPTION, ___2844); ___2038 = ___2038 && retrieveRequiredValue(___3945, ___2850, NUM_ZONES_DESCRIPTION, ___2847); if (___2844 > MAX_NUM_VARS) ___2038 = ___1184("File exceeds SZL variable limit"); else if (___2847 > MAX_NUM_ZONES) ___2038 = ___1184("File exceeds SZL zone limit"); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readDatasetTitle( ___1397& file, ___3946&         ___3945, std::string&         datasetTitle)
{ REQUIRE(file.___2040()); if (___3945.find(DATA_SET_TITLE_TAG) == ___3945.end()) return ___4227; ___372 ___2038 = file.___3460(___3945[DATA_SET_TITLE_TAG]); uint32_t titleLength = 0; ___2038 = ___2038 && readValue<uint32_t, false>(file, titleLength, IODescription(DATA_SET_TITLE_LENGTH)); if (___2038 && titleLength > 0) { try { ___471 ___4178; ___2038 = ___2038 && ___4178.alloc(titleLength); ___2038 = ___2038 && readString(file, titleLength, ___4178, IODescription(DATA_SET_TITLE_DESCRIPTION)); if ( ___2038 ) datasetTitle = std::string(___4178.data(), titleLength); } catch (std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading dataset title."); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readPerVarFileHeader( ___1397& file, ___3946&         ___3945, ___4352           varOffset, ___3817&         varNameArray) { REQUIRE(file.___2040()); ___372 ___2038 = ___4227; try { size_t ___2844 = static_cast<size_t>(___3945[___2846]); if (___2844 == 0) return ___4227; REQUIRE(IMPLICATION(varNameArray.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!varNameArray.empty(), varOffset+___2844 <= varNameArray.size())); uint64_t varNameLocation = ___3945[___4365]; if (varNameLocation == 0) { ___2038 = ___1184("Missing file header tag %" PRIu64 " '%s'.", uint64_t(___4365), VAR_NAME_FILE_LOC_DESCRIPTION); } else { ___2038 = file.___3460(varNameLocation); ___2038 = ___2038 && readStringArray(file, varOffset, ___2844, varNameArray, IODescription(___4364)); } } catch(std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading file header."); } catch(...) { ___2038 = ___1184("Unrecoverable error while reading file header."); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } namespace { ___372 readZoneHeaderFileLocArray( ___1397& file, ___4636          zoneOffset, ___4636          ___2847, ___1390&        zoneFileLocArray) { REQUIRE(file.___2040()); REQUIRE(___2847>0); REQUIRE(IMPLICATION(zoneFileLocArray.empty(), zoneOffset == 0)); REQUIRE(IMPLICATION(!zoneFileLocArray.empty(), size_t(zoneOffset+___2847) <= zoneFileLocArray.size())); REQUIRE("file is at correct file loc"); ___372 ___2038 = readValueArray<uint64_t, true, 0>(file, zoneOffset, ___2847, zoneFileLocArray, IODescription(___4628)); if ( ___2038 ) { if ( zoneFileLocArray[zoneOffset] == ___1391(0) || zoneFileLocArray[zoneOffset] == ___330 || zoneFileLocArray[zoneOffset + ___2847/2] == ___1391(0) || zoneFileLocArray[zoneOffset + ___2847/2] == ___330 || zoneFileLocArray[zoneOffset + ___2847-1] == ___1391(0) || zoneFileLocArray[zoneOffset + ___2847-1] == ___330 ) { ___2038 = ___1184("This file has invalid zone file locations."); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { template <typename T> ___372 readZoneSecTaggedArray( ___1397&                      file, ___3946&                              ___3945,
uint16_t                                  fileLocTag, char const*                               ___970, ___4636                               ___2847, ___2241<uint8_t> const&         zoneNumSections, ___2241<___2241<T> >& zoneSecArray) { REQUIRE(file.___2040()); REQUIRE(VALID_REF(___970)); REQUIRE(___2847 == checked_numeric_cast<___4636>(zoneNumSections.size())); REQUIRE(zoneSecArray.empty() || zoneNumSections.size() == zoneSecArray.size()); ___372 ___2038 = zoneSecArray.alloc(___2847) && file.___3460(___3945[fileLocTag]); for (___4636 zone = 0; ___2038 && zone < ___2847; ++zone) { if (zoneNumSections[zone] > 0) ___2038 = readValueArray<T, false, 0>( file, 0, zoneNumSections[zone], zoneSecArray[zone], IODescription(___970)); } return ___2038; } } ___372 readDataSetHeader( ___1397& file, ___1386&     ___1385, ___3946&         ___3945, std::string&         datasetTitle, ___4707&     ___4706, ___1390&        ___4629) { REQUIRE(file.___2040()); REQUIRE(!___3945.empty()); REQUIRE(___4629.empty() || ___3945[___2850] <= ___4629.size()); ___372 ___2038 = readDatasetTitle(file, ___3945, datasetTitle); if (___2038) { try { ___4352 const ___2844 = static_cast<___4352>(___3945[___2846]); if (___2844 > 0) { uint64_t varNameLocation = ___3945[___4365]; if (varNameLocation == 0) { ___2038 = ___1184("Missing file header tag %" PRIu64 " '%s'.", uint64_t(___4365), VAR_NAME_FILE_LOC_DESCRIPTION); } else { ___2038 = file.___3460(varNameLocation); ___2038 = ___2038 && readStringArray(file, 0, ___2844, ___4706.m_varNames, IODescription(___4364)); } } ___4636 const ___2847 = static_cast<___4636>(___3945[___2850]); if (___2847 > 0) { ___4706.m_numZones = ___2847; ___4706.m_numVars  = ___2844; if (___2038 && ___3945[___4630] == 0) ___2038 = ___1184("File does not contain zone header file locations."); ___2038 = ___2038 && file.___3460(___3945[___4630]); ___2038 = ___2038 && readZoneHeaderFileLocArray(file, 0, ___4636(___2847), ___4629); ___2038 = ___2038 && ___4706.m_zoneNames.alloc(___2847) && file.___3460(___3945[___4651]) && readStringArray(file, 0, ___2847, ___4706.m_zoneNames, IODescription(___4650)) && ___4706.m_zoneTypes.alloc(___2847) && file.___3460(___3945[ZONE_TYPE_FILE_LOC_TAG]) && readValueArray<char, false, 0>(file, 0, ___2847, ___4706.m_zoneTypes, IODescription(___4694)) && ___4706.m_zoneFaceNeighborModes.alloc(___2847) && file.___3460(___3945[___4610]) && readValueArray<uint8_t, false, 0>(file, 0, ___2847, ___4706.m_zoneFaceNeighborModes, IODescription(___4609)) &&
___4706.m_zoneSolutionTimes.alloc(___2847) && file.___3460(___3945[___4676]) && readValueArray<double, false, 0>(file, 0, ___2847, ___4706.m_zoneSolutionTimes, IODescription(___4675)) && ___4706.m_zoneStrandIDs.alloc(___2847) && file.___3460(___3945[___4686]) && readValueArray<uint32_t, false, 0>(file, 0, ___2847, ___4706.m_zoneStrandIDs, IODescription(___4685)) && ___4706.m_zoneParentZones.alloc(___2847) && file.___3460(___3945[___4670]) && readValueArray<int32_t, false, 0>(file, 0, ___2847, ___4706.m_zoneParentZones, IODescription(___4669)) && ___4706.m_zoneIMaxOrNumNodes.alloc(___2847) && file.___3460(___3945[ZONE_IMAX_OR_NUM_NODES_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2847, ___4706.m_zoneIMaxOrNumNodes, IODescription(ZONE_IMAX_OR_NUM_NODES_ARRAY_DESCRIPTION)) && ___4706.m_zoneJMaxOrNumCells.alloc(___2847) && file.___3460(___3945[ZONE_JMAX_OR_NUM_CELLS_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2847, ___4706.m_zoneJMaxOrNumCells, IODescription(ZONE_JMAX_OR_NUM_CELLS_ARRAY_DESCRIPTION)) && ___4706.m_zoneKMaxOrNumCorners.alloc(___2847) && file.___3460(___3945[ZONE_KMAX_OR_NUM_CORNERS_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2847, ___4706.m_zoneKMaxOrNumCorners, IODescription(ZONE_KMAX_OR_NUM_CORNERS_ARRAY_DESCRIPTION)) && ___4706.m_zoneShareConnectivityWithZone.alloc(___2847) && file.___3460(___3945[___4674]) && readValueArray<int32_t, false, 0>(file, 0, ___2847, ___4706.m_zoneShareConnectivityWithZone, IODescription(___4673)); if (___2038 && ___1385.getFileVersion() > 105) { ___2038 = ___2038 && ___4706.m_zoneNumSections.alloc(___2847) && file.___3460(___3945[ZONE_NUM_SECTIONS_FILE_LOC_TAG]) && readValueArray<uint8_t, false, 0>(file, 0, ___2847, ___4706.m_zoneNumSections, IODescription(ZONE_NUM_SECTIONS_ARRAY_DESCRIPTION)); if (___2038 && ___1385.getFileVersion() < 232) { ___2241<UInt32Array> zoneNumElemsPerSec_uint32; ___2038 = ___2038 && readZoneSecTaggedArray<uint32_t>(file, ___3945, ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG, ZONE_NUM_ELEMS_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, zoneNumElemsPerSec_uint32); ___2038 = ___2038 && ___4706.m_zoneNumElemsPerSec.alloc(___2847); for (___4636 zone = 0; ___2038 && zone < ___2847; ++zone) { ___2038 = ___4706.m_zoneNumElemsPerSec[zone].alloc(___4706.m_zoneNumSections[zone]); for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < ___4706.m_zoneNumSections[zone]; ++section) ___4706.m_zoneNumElemsPerSec[zone][section] = zoneNumElemsPerSec_uint32[zone][section];
} } else { ___2038 = ___2038 && readZoneSecTaggedArray<int64_t>(file, ___3945, ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG, ZONE_NUM_ELEMS_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, ___4706.m_zoneNumElemsPerSec); } ___2038 = ___2038 && readZoneSecTaggedArray<uint8_t>(file, ___3945, ZONE_CELL_SHAPE_PER_SECTION_FILE_LOC_TAG, ZONE_CELL_SHAPE_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, ___4706.m_zoneCellShapePerSec); ___2038 = ___2038 && readZoneSecTaggedArray<uint8_t>(file, ___3945, ZONE_GRID_ORDER_PER_SECTION_FILE_LOC_TAG, ZONE_GRID_ORDER_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, ___4706.m_zoneGridOrderPerSec); ___2038 = ___2038 && readZoneSecTaggedArray<uint8_t>(file, ___3945, ZONE_CELL_BASIS_FUNC_PER_SECTION_FILE_LOC_TAG, ZONE_CELL_BASIS_FUNC_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, ___4706.m_zoneCellBasisFuncPerSec); } else { ___4706.m_zoneNumSections.alloc(___2847, 0); ___4706.m_zoneNumElemsPerSec.alloc(___2847); ___4706.m_zoneCellShapePerSec.alloc(___2847); ___4706.m_zoneGridOrderPerSec.alloc(___2847); ___4706.m_zoneCellBasisFuncPerSec.alloc(___2847); } } if (___2847 > 0 && ___2844 > 0) { ___2038 = ___2038 && ___4706.m_zoneDimension.alloc(___2847); for (___4636 zone = 0; ___2038 && zone < ___2847; ++zone) { ZoneType_e const ___4692 = zoneTypeFromFileChar(___4706.m_zoneTypes[zone]); if (___4692 == ___4704) { ___4706.m_zoneDimension[zone] = ___2884( ___1843(___4706.m_zoneIMaxOrNumNodes[zone], ___4706.m_zoneJMaxOrNumCells[zone], ___4706.m_zoneKMaxOrNumCorners[zone])); } else if (___4692 == ZoneType_FEMixed) { ___476(!___4706.m_zoneCellShapePerSec.empty() && !___4706.m_zoneCellShapePerSec[zone].empty()); ___4706.m_zoneDimension[zone] = feMixedZoneDimension(static_cast<FECellShape_e>(___4706.m_zoneCellShapePerSec[zone][0])); } else { ___4706.m_zoneDimension[zone] = feNonMixedZoneDimension(___4692); } } ___2038 = ___2038 && file.___3460(___3945[___4384]) && ___4706.m_vzFieldDataTypes.alloc(___2844); for (___4352 ___4336 = 0; ___2038 && ___4336 < ___2844; ___4336++) ___2038 = ___2038 && readValueArray<uint8_t, false, 0>(file, 0, ___2847, ___4706.m_vzFieldDataTypes[___4336], IODescription(VAR_ZONE_FIELD_DATA_TYPE_FILE_LOC_DESCRIPTION, ___4336)); ___2038 = ___2038 && file.___3460(___3945[VAR_ZONE_MIN_MAX_FILE_LOC_TAG]) && ___4706.m_vzMinMaxes.alloc(___2844); if (___2038) { bool minMaxesAreDouble = false; for (___4352 ___4336 = 0; !minMaxesAreDouble && ___4336 < ___2844; ++___4336) { for (___4636 zone = 0; !minMaxesAreDouble && zone < ___2847; ++zone) { FieldDataType_e ___1361 = (FieldDataType_e)___4706.m_vzFieldDataTypes[___4336][zone]; if (___1361 == FieldDataType_Double || ___1361 == FieldDataType_Int32)
minMaxesAreDouble = true; } } if (minMaxesAreDouble) { for (___4352 ___4336 = 0; ___2038 && ___4336 < ___2844; ___4336++) ___2038 = ___2038 && readMinMaxArray<double>(file, 0, ___2847, ___4706.m_vzMinMaxes[___4336], IODescription(VAR_ZONE_MIN_MAX_FILE_LOC_DESCRIPTION, ___4336)); } else { for (___4352 ___4336 = 0; ___2038 && ___4336 < ___2844; ___4336++) ___2038 = ___2038 && readMinMaxArray<float>(file, 0, ___2847, ___4706.m_vzMinMaxes[___4336], IODescription(VAR_ZONE_MIN_MAX_FILE_LOC_DESCRIPTION, ___4336)); } } ___2038 = ___2038 && file.___3460(___3945[___4393]) && ___4706.m_vzValueLocations.alloc(___2844); for (___4352 ___4336 = 0; ___2038 && ___4336 < ___2844; ___4336++) ___2038 = ___2038 && readValueArray<uint8_t, false, 0>(file, 0, ___2847, ___4706.m_vzValueLocations[___4336], IODescription(VAR_ZONE_VALUE_LOCATION_FILE_LOC_DESCRIPTION, ___4336)); ___2038 = ___2038 && file.___3460(___3945[___4387]) && ___4706.m_vzIsPassive.alloc(___2844); for (___4352 ___4336 = 0; ___2038 && ___4336 < ___2844; ___4336++) ___2038 = ___2038 && readValueArray<uint8_t, false, 0>(file, 0, ___2847, ___4706.m_vzIsPassive[___4336], IODescription(VAR_ZONE_IS_PASSIVE_FILE_LOC_DESCRIPTION, ___4336)); ___2038 = ___2038 && file.___3460(___3945[___4390]) && ___4706.m_vzShareVarWithZone.alloc(___2844); for (___4352 ___4336 = 0; ___2038 && ___4336 < ___2844; ___4336++) ___2038 = ___2038 && readValueArray<int32_t, false, 0>(file, 0, ___2847, ___4706.m_vzShareVarWithZone[___4336], IODescription(VAR_ZONE_SHARE_FILE_LOC_DESCRIPTION, ___4336)); } } catch (std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading data set header."); } catch (...) { ___2038 = ___1184("Unrecoverable error while reading data set header."); } } return ___2038; } ZoneType_e zoneTypeFromFileChar(char c) { char lowerCaseChar = static_cast<char>(tolower(c)); std::map<char, ZoneType_e> zoneTypeMap = boost::assign::map_list_of<char, ZoneType_e> (___4705, ___4704) (ZONETYPE_FETRIANGLE_CHAR, ___4702) (ZONETYPE_FEQUAD_CHAR, ___4700) (ZONETYPE_FETETRA_CHAR, ___4701) (ZONETYPE_FEBRICK_CHAR, ___4695) (ZONETYPE_FELINESEG_CHAR, ___4696) (ZONETYPE_FEPOLYGON_CHAR, ___4698) (ZONETYPE_FEPOLYHEDRON_CHAR, ___4699) (ZONETYPE_FEMIXED_CHAR, ZoneType_FEMixed); REQUIRE(zoneTypeMap.find(lowerCaseChar) != zoneTypeMap.end()); return zoneTypeMap[lowerCaseChar]; } void storeZoneMetadata( ___4707 const& ___4706, ___4636            zone, ___4636            targetBaseZoneOffset, ZoneMetadata&          zoneMetadata) { zoneMetadata.setZone(zone); ZoneType_e ___4692 = zoneTypeFromFileChar(___4706.m_zoneTypes[zone]); zoneMetadata.setZoneType(___4692); if (___4692 == ___4704) { ___1843 ___1842( static_cast<___81>(___4706.m_zoneIMaxOrNumNodes[zone]), static_cast<___81>(___4706.m_zoneJMaxOrNumCells[zone]), static_cast<___81>(___4706.m_zoneKMaxOrNumCorners[zone]));
zoneMetadata.setIJKMax(___1842); } else { zoneMetadata.setFEDescription( static_cast<___463>(___4706.m_zoneJMaxOrNumCells[zone]), static_cast<CellNodeIndex_t>(___4706.m_zoneKMaxOrNumCorners[zone]), static_cast<___2719>(___4706.m_zoneIMaxOrNumNodes[zone])); } zoneMetadata.setZoneDimension(___4706.m_zoneDimension[zone]); zoneMetadata.setIsSZL(isupper(___4706.m_zoneTypes[zone]) ? true : false); zoneMetadata.setName(___4706.m_zoneNames[zone]); zoneMetadata.setFaceNeighborMode(static_cast<FaceNeighborMode_e>(___4706.m_zoneFaceNeighborModes[zone])); zoneMetadata.setSolutionTime(___4706.m_zoneSolutionTimes[zone]); zoneMetadata.setStrandID(___4706.m_zoneStrandIDs[zone]); zoneMetadata.setParentZone(targetBaseZoneOffset + ___4706.m_zoneParentZones[zone]); if (___4692 == ZoneType_FEMixed) { ItemAddress64::SectionOffset_t const numSections = static_cast<ItemAddress64::SectionOffset_t>(___4706.m_zoneNumSections[zone]); zoneMetadata.setSectionMetrics(numSections, ___3270<int64_t const>(___4706.m_zoneNumElemsPerSec[zone].data(),numSections,numSections), ___3270<uint8_t const>(___4706.m_zoneCellShapePerSec[zone].data(),numSections,numSections), ___3270<uint8_t const>(___4706.m_zoneGridOrderPerSec[zone].data(),numSections,numSections), ___3270<uint8_t const>(___4706.m_zoneCellBasisFuncPerSec[zone].data(),numSections,numSections)); } } namespace { ___372 readAuxDataItem( ___1397& file, ___4352           varOffset, ___4636          zoneOffset, ___230&             auxData) { uint8_t auxDataLocation = 0; uint32_t auxDataEntity = 0; uint32_t auxDataNameLength = 0; ___471 auxDataName; uint8_t auxDataType = 0; uint32_t auxDataValueLength = 0; ___471 auxDataValue; ___372 ___2038 = readValue<uint8_t, false>(file, auxDataLocation, IODescription(___252)); ___2038 = ___2038 && readValue<uint32_t, false>(file, auxDataEntity, IODescription(___239)); ___2038 = ___2038 && readValue<uint32_t, false>(file, auxDataNameLength, IODescription(___262)); ___2038 = ___2038 && (auxDataNameLength > 0); ___2038 = ___2038 && auxDataName.alloc(static_cast<uint64_t>(auxDataNameLength)); ___2038 = ___2038 && readString(file, auxDataNameLength, auxDataName, IODescription(___261)); ___2038 = ___2038 && readValue<uint8_t, false>(file, auxDataType, IODescription(___268)); ___2038 = ___2038 && readValue<uint32_t, false>(file, auxDataValueLength, IODescription(___272)); if (___2038 && auxDataValueLength > 0) { ___2038 = auxDataValue.alloc(static_cast<uint64_t>(auxDataValueLength)); ___2038 = ___2038 && readString(file, auxDataValueLength, auxDataValue, IODescription(___271)); } if (___2038) { try { AuxDataLocation_e location = static_cast<AuxDataLocation_e>(auxDataLocation); ___1170 entity = static_cast<___1170>(auxDataEntity); AuxDataType_e type = static_cast<AuxDataType_e>(auxDataType); ___476(type == ___270); if (location == ___258)
entity += varOffset; else if (location == ___259) entity += zoneOffset; std::string auxDataValueString; if (auxDataValueLength > 0) auxDataValueString = std::string(auxDataValue.data(), auxDataValueLength); auxData = ___230(std::string(auxDataName.data(), auxDataNameLength), auxDataValueString, location, entity, type); } catch (std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading auxiliary data."); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 readAuxDataCount( ___1397& file, ___3946&         ___3945, uint32_t&            auxDataCount) { REQUIRE(file.___2040()); REQUIRE(___3945.find(___241) != ___3945.end()); ___372 ___2038 = file.___3460(___3945[___241]); if (file.___2001()) ___2038 = ___2038 && readAndVerifyValue<uint32_t, false>(file, SZPLT_AUX_DATA_MARKER, IODescription(SZPLT_AUX_DATA_MARKER_DESCRIPTION)); ___2038 = ___2038 && readValue<uint32_t, false>(file, auxDataCount, IODescription(___233)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readAuxData( ___1397& file, ___3946&         ___3945, ___4352           varOffset, ___4636          zoneOffset, uint32_t             auxDataOffset, AuxDataArray&        auxDataArray) { REQUIRE(file.___2040()); uint32_t  auxDataCount = 0; ___372 ___2038 = readAuxDataCount(file, ___3945, auxDataCount); for(uint32_t i = 0; ___2038 && i < auxDataCount; ++i) ___2038 = readAuxDataItem(file, varOffset, zoneOffset, auxDataArray[auxDataOffset + i]); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } namespace { ___372 readGeomLineSegData( ___1397& file, ___1554&                ___1553) { REQUIRE(file.___2040()); REQUIRE(___1553.___2467 == GeomType_LineSegs); uint32_t ___2836; bool is3D = (___1553.___2617 == CoordSys_Grid3D);
 #if 0
std::vector<std::vector<class ___4580> > ___2465;
 #endif
___372 ___2038 = readValue<uint32_t, false>(file, ___2836, IODescription(___1621)); if (___2038) { try { ___1553.___2465.resize(static_cast<size_t>(___2836)); } catch(...) { ___2038 = ___1184("Out of memory while reading geometry data."); } } for(uint32_t segment = 0; ___2038 && segment < ___2836; ++segment) { uint32_t numPts = 0; ___1103 xPts; ___1103 yPts; ___1103 zPts; ___2038 = ___2038 && readValue<uint32_t, false>(file, numPts, IODescription(___1620)) && xPts.alloc(static_cast<uint64_t>(numPts)) && yPts.alloc(static_cast<uint64_t>(numPts)); if (is3D) ___2038 = ___2038 && zPts.alloc(static_cast<uint64_t>(numPts)); ___2038 = ___2038 && readValueArray<double, false, 0>(file, 0, static_cast<size_t>(numPts), xPts, IODescription(___1653)) && readValueArray<double, false, 0>(file, 0, static_cast<size_t>(numPts), yPts, IODescription(___1655)); if (is3D) ___2038 && readValueArray<double, false, 0>(file, 0, static_cast<size_t>(numPts), zPts, IODescription(___1658)); for(uint32_t i = 0; ___2038 && i < numPts; ++i) { try { if (is3D) ___1553.___2465[segment].push_back(___4580(xPts[i], yPts[i], zPts[i])); else ___1553.___2465[segment].push_back(___4580(xPts[i], yPts[i], 0.0)); } catch(...) { ___2038 = ___1184("Out of memory while reading geometry data."); } } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 readGeometry( ___1397& file, ___1554&                ___1553) { REQUIRE(file.___2040()); ___372 ___2038 = readValue<double, false>(file, ___1553.___2618[0], IODescription(___1652)) && readValue<double, false>(file, ___1553.___2618[1], IODescription(___1654)) && readValue<double, false>(file, ___1553.___2618[2], IODescription(___1657)); uint8_t ___3160 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___3160, IODescription(___1625)); ___1553.___2617 = static_cast<CoordSys_e>(___3160); uint8_t ___2003 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___2003, IODescription(___1609)); ___1553.___2485 = static_cast<___372>(___2003); int32_t zone = 0; ___2038 = ___2038 && readValue<int32_t, false>(file, zone, IODescription(___1656)); ___1553.___2678 = static_cast<___1170>(zone); uint16_t color = 0; ___2038 = ___2038 && readValue<uint16_t, false>(file, color, IODescription(___1569)); ___1553.___2396 = static_cast<___514>(color); uint16_t ___1409 = 0; ___2038 = ___2038 && readValue<uint16_t, false>(file, ___1409, IODescription(___1580)); ___1553.___2463 = static_cast<___514>(___1409); uint8_t ___2021 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___2021, IODescription(___1610)); ___1553.___2487 = static_cast<___372>(___2021); uint8_t ___1650 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___1650, IODescription(GEOM_GEOM_TYPE)); ___1553.___2467 = static_cast<GeomType_e>(___1650); uint8_t ___2264 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___2264, IODescription(___1611));
___1553.___2490 = static_cast<LinePattern_e>(___2264); ___2038 = ___2038 && readValue<double, false>(file, ___1553.___2616, IODescription(___1623)); ___2038 = ___2038 && readValue<double, false>(file, ___1553.___2491, IODescription(___1612)); ___2038 = ___2038 && readValue<uint16_t, false>(file, ___1553.___2503, IODescription(___1619)); uint8_t arrowheadStyle = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, arrowheadStyle, IODescription(___1567)); ___1553.___2344 = static_cast<ArrowheadStyle_e>(arrowheadStyle); uint8_t arrowheadAttachment = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, arrowheadAttachment, IODescription(___1561)); ___1553.___2342 = static_cast<ArrowheadAttachment_e>(arrowheadAttachment); ___2038 = ___2038 && readValue<double, false>(file, ___1553.___2343, IODescription(___1566)); ___2038 = ___2038 && readValue<double, false>(file, ___1553.___2341, IODescription(___1560)); uint8_t geomScope = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, geomScope, IODescription(___1631)); ___1553.___2620 = static_cast<Scope_e>(geomScope); uint8_t geomClipping = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, geomClipping, IODescription(GEOM_CLIPPING)); ___1553.___2395 = static_cast<Clipping_e>(geomClipping); uint32_t macroFunctionCommandLength = 0; ___2038 = ___2038 && readValue<uint32_t, false>(file, macroFunctionCommandLength, IODescription(___1614)); if (___2038 && macroFunctionCommandLength > 0) { try { ___471 ___2331; ___2038 = ___2038 && ___2331.alloc(static_cast<uint64_t>(macroFunctionCommandLength)) && readString(file, static_cast<size_t>(macroFunctionCommandLength), ___2331, IODescription(___1613)); if (___2038) ___1553.___2492 = std::string(___2331.data(), static_cast<size_t>(macroFunctionCommandLength)); } catch (std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading geometries."); } } ___4580 basicGeomData; ___476(!basicGeomData.___2066()); switch (___1553.___2467) { case GeomType_LineSegs: { ___2038 = ___2038 && readGeomLineSegData(file, ___1553); } break; case GeomType_Rectangle: { double ___4458 = 0.0; double ___1825 = 0.0; ___2038 = ___2038 && readValue<double, false>(file, ___4458, IODescription(___1628)) && readValue<double, false>(file, ___1825, IODescription(___1627)); if (___2038) basicGeomData = ___4580(___4458, ___1825, 0.0); } break; case GeomType_Square: { double squareSize = 0.0; ___2038 = ___2038 && readValue<double, false>(file, squareSize, IODescription(___1648)); if (___2038) basicGeomData = ___4580(squareSize, 0.0, 0.0); } break; case GeomType_Circle: { double radius = 0.0; ___2038 = ___2038 && readValue<double, false>(file, radius, IODescription(___1606)); if (___2038) basicGeomData = ___4580(radius, 0.0, 0.0); } break; case GeomType_Ellipse: { double horizontalAxis = 0.0; double verticalAxis = 0.0;
___2038 = ___2038 && readValue<double, false>(file, horizontalAxis, IODescription(___1576)) && readValue<double, false>(file, verticalAxis, IODescription(___1577)); if (___2038) basicGeomData = ___4580(horizontalAxis, verticalAxis, 0.0); } break; default: ___476(___1303); break; } if (___2038 && basicGeomData.___2066()) { try { ___1553.___2465.resize(1); ___1553.___2465[0].push_back(basicGeomData); } catch(...) { ___2038 = ___1184("Out of memory reading square geometry."); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 readGeometriesCount( ___1397& file, ___3946&         ___3945, uint32_t&            geomCount) { REQUIRE(file.___2040()); REQUIRE(___3945.find(___1579) != ___3945.end()); ___372 ___2038 = file.___3460(___3945[___1579]); if (file.___2001()) ___2038 = ___2038 && readAndVerifyValue<uint32_t, false>(file, SZPLT_GEOMETRY_MARKER, IODescription(SZPLT_GEOMETRY_MARKER_DESCRIPTION)); ___2038 = ___2038 && readValue<uint32_t, false>(file, geomCount, IODescription(NUM_GEOMS_DESCRIPTION)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readGeometries( ___1397& file, ___3946&         ___3945, uint32_t             geomOffset, GeomArray&           geomArray) { REQUIRE(file.___2040()); uint32_t geomCount = 0; ___372 ___2038 = readGeometriesCount(file, ___3945, geomCount); for(uint32_t i = 0; ___2038 && i < geomCount; ++i) ___2038 = readGeometry(file, geomArray[geomOffset + i]); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } namespace { ___372 readText( ___1397& file, Text&                ___4043) { REQUIRE(file.___2040()); ___372 ___2038 = readValue<double, false>(file, ___4043.___2627[0], IODescription(___1652)) && readValue<double, false>(file, ___4043.___2627[1], IODescription(___1654)) && readValue<double, false>(file, ___4043.___2627[2], IODescription(___1657)); uint16_t ___4081 = 0; ___2038 = ___2038 && readValue<uint16_t, false>(file, ___4081, IODescription(___4083)); ___4043.___2635 = static_cast<___514>(___4081); uint16_t ___4060 = 0; ___2038 = ___2038 && readValue<uint16_t, false>(file, ___4060, IODescription(___4061)); ___4043.___2629 = static_cast<___514>(___4060); uint16_t ___4062 = 0; ___2038 = ___2038 && readValue<uint16_t, false>(file, ___4062, IODescription(___4063)); ___4043.___2630 = static_cast<___514>(___4062); ___2038 = ___2038 && readValue<double, false>(file, ___4043.___2631, IODescription(___4073)); ___2038 = ___2038 && readValue<double, false>(file, ___4043.___2632, IODescription(___4075)); uint8_t ___4079 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___4079, IODescription(TEXT_BOX_TYPE)); ___4043.___2633 = static_cast<TextBox_e>(___4079); uint8_t ___4044 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___4044, IODescription(___4045));
___4043.___2626 = static_cast<TextAnchor_e>(___4044); ___2038 = ___2038 && readValue<double, false>(file, ___4043.___2628, IODescription(___4058)); uint8_t ___4080 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___4080, IODescription(TEXT_CLIPPING)); ___4043.___2634 = static_cast<Clipping_e>(___4080); ___2038 = ___2038 && readValue<double, false>(file, ___4043.___2636, IODescription(TEXT_HEIGHT)); ___2038 = ___2038 && readValue<double, false>(file, ___4043.___2638, IODescription(___4109)); uint8_t ___4116 = 0; ___2038 = ___2038 &&  readValue<uint8_t, false>(file, ___4116, IODescription(___4117)); ___4043.___2640 = static_cast<CoordSys_e>(___4116); uint8_t ___4120 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___4120, IODescription(___4121)); ___4043.___2642 = static_cast<Scope_e>(___4120); uint8_t ___4125 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___4125, IODescription(___4126)); ___4043.___2643 = static_cast<Units_e>(___4125); uint32_t textStringLength = 0; ___2038 = ___2038 && readValue<uint32_t, false>(file, textStringLength, IODescription(___4129)); try { if (textStringLength > 0) { ___471 ___4127; ___2038 = ___2038 && ___4127.alloc(static_cast<size_t>(textStringLength)) && readString(file, static_cast<size_t>(textStringLength), ___4127, IODescription(___4128)); if (___2038) ___4043.___2644 = std::string(___4127.data(), static_cast<size_t>(textStringLength)); } uint32_t textTypefaceFamilyLength = 0; ___2038 = ___2038 && readValue<uint32_t, false>(file, textTypefaceFamilyLength, IODescription(___4132)); if (___2038 && textTypefaceFamilyLength > 0) { ___471 ___4130; ___2038 = ___2038 && ___4130.alloc(static_cast<size_t>(textTypefaceFamilyLength)) && readString(file, static_cast<size_t>(textTypefaceFamilyLength), ___4130, IODescription(___4131)); if (___2038) ___4043.___2645 = std::string(___4130.data(), static_cast<size_t>(textTypefaceFamilyLength)); } uint8_t ___4133 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___4133, IODescription(___4134)); ___4043.___2646 = static_cast<___372>(___4133); uint8_t ___4135 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___4135, IODescription(___4136)); ___4043.___2647 = static_cast<___372>(___4135); int32_t ___4139 = 0; ___2038 = ___2038 && readValue<int32_t, false>(file, ___4139, IODescription(___4140)); ___4043.___2648 = static_cast<___1170>(___4139); uint8_t ___4106 = 0; ___2038 = ___2038 && readValue<uint8_t, false>(file, ___4106, IODescription(___4107)); ___4043.___2637 = static_cast<___372>(___4106); uint32_t textMacroFunctionCmdLength = 0; ___2038 = ___2038 && readValue<uint32_t, false>(file, textMacroFunctionCmdLength, IODescription(___4112));
if (___2038 && textMacroFunctionCmdLength > 0) { ___471 ___4110; ___2038 = ___2038 && ___4110.alloc(static_cast<size_t>(textMacroFunctionCmdLength)) && readString(file, static_cast<size_t>(textMacroFunctionCmdLength), ___4110, IODescription(___4111)); if (___2038) ___4043.___2639 = std::string(___4110.data(), static_cast<size_t>(textMacroFunctionCmdLength)); } } catch (std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading text."); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 readTextsCount( ___1397& file, ___3946&         ___3945, uint32_t&            textCount) { REQUIRE(file.___2040()); REQUIRE(___3945.find(___4084) != ___3945.end()); ___372 ___2038 = file.___3460(___3945[___4084]); if (file.___2001()) ___2038 = ___2038 && readAndVerifyValue<uint32_t, false>(file, SZPLT_TEXT_MARKER, IODescription(SZPLT_TEXT_MARKER_DESCRIPTION)); ___2038 = ___2038 && readValue<uint32_t, false>(file, textCount, IODescription(NUM_TEXTS_DESCRIPTION)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readTexts( ___1397& file, ___3946&         ___3945, uint32_t             textOffset, TextArray&           textArray) { REQUIRE(file.___2040()); uint32_t textCount = 0; ___372 ___2038 = readTextsCount(file, ___3945, textCount); for(uint32_t i = 0; ___2038 && i < textCount; ++i) ___2038 = readText(file, textArray[textOffset + i]); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } namespace { ___372 readCustomLabelSet( ___1397& file, CustomLabelSet&      customLabelSet) { REQUIRE(file.___2040()); ___372 ___2038 = readValue<uint32_t, false>(file, customLabelSet.m_numLabels, IODescription(___2821)) && readStringArray(file, 0, size_t(customLabelSet.m_numLabels), customLabelSet.m_labels, IODescription(___792)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 readCustomLabelsCount( ___1397& file, ___3946&         ___3945, uint32_t&            customLabelsCount) { REQUIRE(file.___2040()); REQUIRE(___3945.find(___793) != ___3945.end()); ___372 ___2038 = ___4227; ___2038 = file.___3460(___3945[___793]); if (file.___2001()) ___2038 = ___2038 && readAndVerifyValue<uint32_t, false>(file, SZPLT_CUSTOM_LABELS_MARKER, IODescription(SZPLT_CUSTOM_LABELS_MARKER_DESCRIPTION)); ___2038 = ___2038 && readValue<uint32_t, false>(file, customLabelsCount, IODescription(___791)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readCustomLabels( ___1397& file, ___3946&         ___3945, uint32_t&            customLabelsOffset, CustomLabelsArray&   customLabelsArray) { REQUIRE(file.___2040()); uint32_t  customLabelsCount = 0; ___372 ___2038 = readCustomLabelsCount(file, ___3945, customLabelsCount); for(uint32_t i = 0; ___2038 && i < customLabelsCount; ++i) ___2038 = readCustomLabelSet(file, customLabelsArray[customLabelsOffset + i]);
ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readZoneHeaderTags( ___1397& file, ___4636          expectedZone, ___3946&         ___3945) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); REQUIRE(expectedZone>=0); if ( file.___2001() ) { ___2038 = ___2038 && readAndVerifyValue<uint32_t, false>(file, SZPLT_ZONE_MARKER, IODescription(SZPLT_ZONE_MARKER_DESCRIPTION)); ___2038 = ___2038 && readAndVerifyValue<uint32_t, false>(file, uint32_t(expectedZone + 1), IODescription(SZPLT_ZONE_NUM_DESCRIPTION)); } ___3943 tagDescriptionMap = ___4689; ___2038 = ___2038 && readTagList(file, tagDescriptionMap, ___3945); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } namespace { ___372 checkArrayHeaderTag( uint16_t             tag, ___3946 const&   ___3945, IODescription const& ___970) { REQUIRE(!___970.isEmpty() && ___970.zone()!=IODescription::NO_ZONE); ___372 ___2038 = ___4227; ___3946::const_iterator iter = ___3945.find(tag); if ( iter == ___3945.end() ) { if ( ___970.___2978() == IODescription::NO_PARTITION ) ___2038 = ___1184("Missing zone header tag '%s' for zone %" PRIu64 ".", ___970.___2686(), uint64_t(___970.zone()+1)); else ___2038 = ___1184("Missing partition header tag '%s' for partition %" PRIu64 " of zone %" PRIu64 ".", ___970.___2686(), uint64_t(___970.___2978()+1), uint64_t(___970.zone()+1)); } else if ( iter->second == 0 || iter->second == ___330 ) { if ( ___970.___2978() == IODescription::NO_PARTITION ) ___2038 = ___1184("Invalid value for zone header tag '%s' for zone %" PRIu64, ___970.___2686(), uint64_t(___970.zone()+1)); else ___2038 = ___1184("Invalid value for partition header tag '%s' for partition %" PRIu64 " of zone %" PRIu64 ".", ___970.___2686(), uint64_t(___970.___2978()+1), uint64_t(___970.zone()+1)); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 applyZoneHeaderScalarTagValues( ___3946&  ___3945, ZoneMetadata& zoneMetadata) { ___372 ___2038 = ___4227; try { zoneMetadata.m_nonSzZoneFileLocations.___2499 = (___3945[___2726] ? ___3945[___2726] : ___330); zoneMetadata.m_nonSzZoneFileLocations.___2664 = (___3945[USER_FACE_NBR_FILE_LOC_TAG] ? ___3945[USER_FACE_NBR_FILE_LOC_TAG] : ___330); ItemAddress64::___2981 const numPartitions = ItemAddress64::___2981(___3945[NUM_PARTITIONS_TAG]); zoneMetadata.setNumPartitions(numPartitions > 0 ? numPartitions : 1); } catch(std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while retrieving file tags."); } catch(...) { ___2038 = ___1184("Unrecoverable error while retrieving file tags."); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { template<typename T> ___372 readHeaderTagArray( ___1397&  file, ___3946&          ___3945, uint16_t              tagValue, size_t                ___2866,
size_t                numValues, ___2241<T>& valueArray, ___372           (*readValueArrayFunc)(___1397& file, size_t ___2866, size_t ___2796, ___2241<T>& valueArray, IODescription const& ___970), IODescription const&  ___970) { ___372 ___2038 = checkArrayHeaderTag(tagValue, ___3945, ___970); if ( ___2038 ) { ___1391 const fileLoc = ___3945[tagValue]; ___476(fileLoc != ___330 && fileLoc != 0); ___2038 = file.___3460(fileLoc) && readValueArrayFunc(file, ___2866, numValues, valueArray, ___970); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 readNonSZLZoneHeaderArrays( ___1397& file, ___3946&         ___3945, ___4352           numVarsInFile, ZoneMetadata&        zoneMetadata) { ___372 ___2038 = ___4227; REQUIRE(!zoneMetadata.isSZL()); ___4636 zone = zoneMetadata.zone(); try { ___2038 = ___2038 && readHeaderTagArray<uint64_t>( file, ___3945, ___4342, 0, numVarsInFile, zoneMetadata.m_nonSzZoneFileLocations.___2674, readValueArray<uint64_t, true, 0>, IODescription(VAR_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone)); } catch (std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading zone %" PRIu64 " header.", uint64_t(zone + 1)); } catch (...) { ___2038 = ___1184("Unrecoverable error while reading zone %" PRIu64 " header.", uint64_t(zone + 1)); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { inline uint64_t minMaxBlockSize(FieldDataType_e ___1361, ItemAddress64::SubzoneOffset_t numSubzones, bool ___2001) { REQUIRE(VALID_ENUM(___1361, FieldDataType_e)); switch (___1361) { case FieldDataType_Float: return arraySizeInFile<std::pair<float, float>, false >(numSubzones, ___2001); case FieldDataType_Double: return arraySizeInFile<std::pair<double, double>, false >(numSubzones, ___2001); case FieldDataType_Int32: return arraySizeInFile<std::pair<int32_t, int32_t>, false >(numSubzones, ___2001); case FieldDataType_Int16: return arraySizeInFile<std::pair<int16_t, int16_t>, false >(numSubzones, ___2001); case FieldDataType_Byte: case ___1363: return arraySizeInFile<std::pair<uint8_t, uint8_t>, false >(numSubzones, ___2001); default: ___476(___1303); return 0; } } } namespace { template<typename T> ___372 readSecHeaderTagArrays( ___1397&                           file, ___3946&                                   ___3945, uint16_t                                       tagValue, size_t                                         ___2866, size_t                                         ___2796, uint32_t                                       numSections, ___2241<___2241<T> >&      secValueArray, boost::function<___372( ___1397&  file, size_t                ___2866, size_t                ___2796, ___2241<T>& valueArray, IODescription const&  ___970)> const& readValueArrayFunc, IODescription const&                           ___970)
{ REQUIRE(readValueArrayFunc); REQUIRE(secValueArray.empty() || numSections == checked_numeric_cast<uint32_t>(secValueArray.size())); ___372 ___2038 = checkArrayHeaderTag(tagValue, ___3945, ___970); if (___2038 && secValueArray.empty()) ___2038 = secValueArray.alloc(numSections); if (___2038) { ___1391 const fileLoc = ___3945[tagValue]; ___476(fileLoc != ___330 && fileLoc != 0); ___2038 = file.___3460(fileLoc); for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < numSections; ++section) ___2038 = readValueArrayFunc(file, ___2866, ___2796, secValueArray[section], ___970); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { template<typename T> ___372 readSecPtnHeaderTagArrays( ___1397&                                   file, ___3946&                                           ___3945, uint16_t                                               tagValue, size_t                                                 ___2866, ItemAddress64::___2981                             ___2978, uint32_t                                               numSections, ___2241<___2241<uint32_t> > const& secPtnNumCszs, boost::function<size_t(size_t count)> const&           numEntriesToReadFunc, ___2241<___2241<T> >&              secValueArray, boost::function<___372( ___1397&  file, size_t                ___2866, size_t                ___2796, ___2241<T>& valueArray, IODescription const&  ___970)> const&         readValueArrayFunc, IODescription const&                                   ___970) { REQUIRE(readValueArrayFunc); ___372 ___2038 = checkArrayHeaderTag(tagValue, ___3945, ___970); if (___2038 && secValueArray.empty()) ___2038 = secValueArray.alloc(numSections); if (___2038) { ___1391 const fileLoc = ___3945[tagValue]; ___476(fileLoc != ___330 && fileLoc != 0); ___2038 = file.___3460(fileLoc); for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < numSections; ++section) { size_t const ___2797 = numEntriesToReadFunc ? numEntriesToReadFunc(secPtnNumCszs[section][___2978]) : checked_numeric_cast<size_t>(secPtnNumCszs[section][___2978]); if (___2797 > 0) ___2038 = readValueArrayFunc(file, ___2866, ___2797, secValueArray[section], ___970); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 readVarLocations( ___1397&             file, ___1386 const&           ___1385, ___3946&                     ___3945, ___4352                       varOffset, ___4352                       ___2844, ZoneMetadata const&              zoneMetadata, PartitionMetadata&               partitionMetadata, ___4636                      zone, ItemAddress64::___2981       ___2978, ___4382 const& vzFieldDataTypes) { ___372 ___2038 = readHeaderTagArray<uint64_t>( file, ___3945, ___4342, 0, ___2844, partitionMetadata.m_nszMinMaxFileLocs, readValueArray<uint64_t, true, 0>,
IODescription(VAR_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone, zoneMetadata.getNumPartitions() == 1 ? IODescription::NO_PARTITION : ___2978)); ___2038 = ___2038 && partitionMetadata.m_cszMinMaxFileLocs.alloc(___2844); ___2038 = ___2038 && partitionMetadata.m_szDataStartFileLocs.alloc(___2844); if (___2038) { ItemAddress64::SectionOffset_t const numSections = zoneMetadata.getZoneType() == ZoneType_FEMixed ? zoneMetadata.numSections() : 1; for (___4352 ___4336 = 0; ___4336 < ___2844; ++___4336) { if (partitionMetadata.m_nszMinMaxFileLocs[___4336] != ___330) { size_t const nszMinMaxBlockSize = minMaxBlockSize( (FieldDataType_e)vzFieldDataTypes[varOffset + ___4336][zone], zoneMetadata.getNumNszsInPartition(___2978), ___1385.___2001() ? true : false); size_t cszMinMaxBlockSize = 0; for (ItemAddress64::SectionOffset_t section = 0; section < numSections; ++section) cszMinMaxBlockSize += minMaxBlockSize( (FieldDataType_e)vzFieldDataTypes[varOffset + ___4336][zone], zoneMetadata.getNumCszsInPartitionSection(___2978,section), ___1385.___2001() ? true : false); partitionMetadata.m_cszMinMaxFileLocs[___4336]   = partitionMetadata.m_nszMinMaxFileLocs[___4336] + nszMinMaxBlockSize; partitionMetadata.m_szDataStartFileLocs[___4336] = partitionMetadata.m_cszMinMaxFileLocs[___4336] + cszMinMaxBlockSize; } else { partitionMetadata.m_cszMinMaxFileLocs[___4336]   = ___330; partitionMetadata.m_szDataStartFileLocs[___4336] = ___330; } } } return ___2038; } } namespace { ___372 readSZLNonPartitionedZoneHeaderArrays( ___1397&      file, ___1386 const&    ___1385, ___3946&              ___3945, ___4636               zoneOffset, ___4352                varOffset, ___4352                numVarsInFile, VarZoneMinMaxArray const& vzMinMax, ___4382 const& vzFieldDataTypes, ZoneMetadata&             zoneMetadata) { REQUIRE(file.___2040()); REQUIRE(numVarsInFile>0); REQUIRE(IMPLICATION(vzMinMax.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!vzMinMax.empty(), size_t(varOffset+numVarsInFile) <= vzMinMax.size())); REQUIRE(zoneMetadata.isSZL()); REQUIRE(zoneMetadata.getNumPartitions()==1); ___4636 const zone = zoneMetadata.zone(); ___476(zoneMetadata.m_ptnFileNums.empty()); ___476(zoneMetadata.m_ptnHeaderFileLocs.empty()); ___372 ___2038 = ___4227; try { ___2038 = ___2038 && zoneMetadata.m_ptnNumNodes.alloc(1); ___2038 = ___2038 && zoneMetadata.m_ptnFirstNode.alloc(1); if ( zoneMetadata.getZoneType() == ___4704 ) { ___2038 = ___2038 && zoneMetadata.m_ptnNodeMinIJKs.alloc(1); ___2038 = ___2038 && zoneMetadata.m_ptnNodeMaxIJKs.alloc(1); } ___2038 = ___2038 && zoneMetadata.m_ptnNumNszs.alloc(1); ItemAddress64::SectionOffset_t const numSections = zoneMetadata.numSections(); ___476(numSections >= 1); ___2038 = ___2038 && zoneMetadata.m_secPtnNumCells.alloc(numSections); ___2038 = ___2038 && zoneMetadata.m_secPtnFirstCell.alloc(numSections); ___2038 = ___2038 && zoneMetadata.m_secPtnNumCszs.alloc(numSections); for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < numSections; ++section)
{ ___2038 = ___2038 && zoneMetadata.m_secPtnNumCells[section].alloc(1); ___2038 = ___2038 && zoneMetadata.m_secPtnFirstCell[section].alloc(1); ___2038 = ___2038 && zoneMetadata.m_secPtnNumCszs[section].alloc(1); } if ( ___2038 ) { ___2719 const ___2822 = zoneMetadata.___1767(); zoneMetadata.m_ptnNumNodes[0] = ___2822; zoneMetadata.m_ptnFirstNode[0] = 0; if ( zoneMetadata.getZoneType() == ___4704 ) { ___2038 = ___2038 && zoneMetadata.m_ijkZoneInfos.alloc(1); if (___2038) { ___476(numSections == 1); ___463 const ___2782 = zoneMetadata.___1765(); zoneMetadata.m_secPtnNumCells[0][0] = ___2782; zoneMetadata.m_secPtnFirstCell[0][0] = 0; zoneMetadata.m_ijkZoneInfos[0] = ___1880(zoneMetadata.getZoneIJK(), ___1385.___1756()); zoneMetadata.m_ptnNodeMinIJKs[0] = ___1843(0,0,0); zoneMetadata.m_ptnNodeMaxIJKs[0] = zoneMetadata.getZoneIJK()-1; zoneMetadata.m_secPtnNumCszs[0][0] = zoneMetadata.m_ijkZoneInfos[0].getNumCszs(); zoneMetadata.m_ptnNumNszs[0] = zoneMetadata.m_ijkZoneInfos[0].getNumNszs(); } } else { if (___1385.getFileVersion() > 105 && zoneMetadata.getZoneType() == ZoneType_FEMixed) { for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < numSections; ++section) zoneMetadata.m_secPtnNumCells[section][0] = zoneMetadata.numElems(section); } else { ___476(numSections == 1); ___463 const ___2782 = zoneMetadata.___1765(); zoneMetadata.m_secPtnNumCells[0][0] = ___2782; } for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < numSections; ++section) { zoneMetadata.m_secPtnNumCszs[section][0] = getNumSzFromNumItems(zoneMetadata.m_secPtnNumCells[section][0]); if (section == 0) zoneMetadata.m_secPtnFirstCell[section][0] = 0; else zoneMetadata.m_secPtnFirstCell[section][0] = checked_numeric_cast<___463>( zoneMetadata.m_secPtnFirstCell[section-1][0] + zoneMetadata.m_secPtnNumCells[section][0]); } zoneMetadata.m_ptnNumNszs[0] = getNumSzFromNumItems(___2822); } } ___2038 = ___2038 && zoneMetadata.m_varPtnMinMaxTrees.alloc(numVarsInFile); for ( ___4352 ___4336 = 0; ___2038 && ___4336 < numVarsInFile; ++___4336 ) zoneMetadata.m_varPtnMinMaxTrees[___4336].populateTreeFromMinMax(vzMinMax[varOffset + ___4336][zoneOffset + zone]); ___2038 = ___2038 && zoneMetadata.m_ptnMetadata.alloc(1); if ( ___2038 ) { PartitionMetadata& partitionMetadata = zoneMetadata.m_ptnMetadata[0]; ___2038 = readVarLocations( file, ___1385, ___3945, varOffset, numVarsInFile, zoneMetadata, partitionMetadata, zoneOffset+zone, 0 , vzFieldDataTypes); if ( ___2038 ) { if (___3895(zoneMetadata.getZoneType(), zoneMetadata.getZoneDimension()) && ___1385.___842() != ___846) { if (___3945.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3945.end() && ___3945.find(NSZ_CONNECT_FILE_LOC_TAG)->second != ___330) { ___2038 = ___2038 && readSecPtnHeaderTagArrays<uint64_t>( file, ___3945, CSZ_CONNECT_FILE_LOC_TAG, 0, 0 , zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, NULL/*numEntriesToReadFunc*/, partitionMetadata.m_secCszConnectivityFileLocs, readValueArray<uint64_t, true, 0>,
IODescription(CSZ_CONNECT_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); ___2038 = ___2038 && readHeaderTagArray<uint64_t>( file, ___3945, NSZ_CONNECT_FILE_LOC_TAG, 0, zoneMetadata.m_ptnNumNszs[0], partitionMetadata.m_nszConnectivityFileLocs, readValueArray<uint64_t, true, 0>, IODescription(NSZ_CONNECT_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); if (___1385.getFileVersion() > 104) { ___2038 = ___2038 && readSecPtnHeaderTagArrays<uint16_t>( file, ___3945, NUM_REF_NODE_SUBZONES_TAG, 0, 0 , zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, NULL/*numEntriesToReadFunc*/, partitionMetadata.m_secCszNumRefNszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_NODE_SUBZONES_DESCRIPTION,IODescription::NO_VAR,zone)); ___2038 = ___2038 && readHeaderTagArray<uint16_t>( file, ___3945, NUM_REF_CELL_SUBZONES_TAG, 0, zoneMetadata.m_ptnNumNszs[0], partitionMetadata.m_nszNumRefCszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_CELL_SUBZONES_DESCRIPTION,IODescription::NO_VAR,zone)); } } else { ___2038 = ((___3945.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3945.end() && ___3945.find(NSZ_CONNECT_FILE_LOC_TAG)->second == ___330) && (___3945.find(CSZ_CONNECT_FILE_LOC_TAG) != ___3945.end() && ___3945.find(CSZ_CONNECT_FILE_LOC_TAG)->second == ___330) && IMPLICATION(___1385.getFileVersion() > 105 && zoneMetadata.getZoneType() == ZoneType_FEMixed, (___3945.find(PARTITION_NUM_CELLS_TAG) != ___3945.end() && ___3945.find(PARTITION_NUM_CELLS_TAG)->second == ___330)) && IMPLICATION(___1385.getFileVersion() > 104, (___3945.find(NUM_REF_NODE_SUBZONES_TAG) != ___3945.end() && ___3945.find(NUM_REF_NODE_SUBZONES_TAG)->second == ___330) && (___3945.find(NUM_REF_CELL_SUBZONES_TAG) != ___3945.end() && ___3945.find(NUM_REF_CELL_SUBZONES_TAG)->second == ___330))); if (!___2038) ___1184("Connectivity integrity error while reading SZL zone %" PRIu64 " header.", uint64_t(zone+1)); } } } else { throw std::bad_alloc(); } } } catch(std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading SZL zone %" PRIu64 " header.", uint64_t(zone+1)); } catch(...) { ___2038 = ___1184("Unrecoverable error while reading SZL zone %" PRIu64 " header.", uint64_t(zone+1)); } if ( !___2038 ) { zoneMetadata.m_secPtnNumCells.___935(); zoneMetadata.m_ptnNumNodes.___935(); zoneMetadata.m_secPtnFirstCell.___935(); zoneMetadata.m_ptnFirstNode.___935(); zoneMetadata.m_secPtnNumCszs.___935(); zoneMetadata.m_ptnNumNszs.___935(); zoneMetadata.m_varPtnMinMaxTrees.___935(); zoneMetadata.m_ptnMetadata.___935(); } ENSURE(zoneMetadata.m_ptnFileNums.empty()); ENSURE(zoneMetadata.m_ptnHeaderFileLocs.empty()); ENSURE(zoneMetadata.m_varPtnMinMaxFileLocs.empty()); ENSURE(IMPLICATION(___2038, !zoneMetadata.m_secPtnNumCells.empty() && zoneMetadata.m_secPtnNumCells[0].size()==1)); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_secPtnNumCells.empty())); ENSURE(IMPLICATION(___2038, zoneMetadata.m_ptnNumNodes.size()==1));
ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnNumNodes.empty())); ENSURE(IMPLICATION(___2038, !zoneMetadata.m_secPtnFirstCell.empty() && zoneMetadata.m_secPtnFirstCell[0].size()==1)); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_secPtnFirstCell.empty())); ENSURE(IMPLICATION(___2038, zoneMetadata.m_ptnFirstNode.size() == 1)); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnFirstNode.empty())); ENSURE(IMPLICATION(___2038, !zoneMetadata.m_secPtnNumCszs.empty() && zoneMetadata.m_secPtnNumCszs[0].size()==1)); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_secPtnNumCszs.empty())); ENSURE(IMPLICATION(___2038, zoneMetadata.m_ptnNumNszs.size()==1)); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnNumNszs.empty())); ENSURE(IMPLICATION(___2038, zoneMetadata.m_varPtnMinMaxTrees.size()==size_t(numVarsInFile))); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_varPtnMinMaxTrees.empty())); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 readSZLPartitionedZoneHeaderArrays( ___1397&      file, ___1386 const&    ___1385, ___3946&              ___3945, ___4636               zoneOffset, ___4352                varOffset, ___4352                ___2844, VarZoneMinMaxArray const& ASSERT_ONLY(vzMinMax), ___4382 const& vzFieldDataTypes, ZoneMetadata&             zoneMetadata) { REQUIRE(file.___2040()); REQUIRE(___2844>0); REQUIRE(IMPLICATION(vzMinMax.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!vzMinMax.empty(), size_t(varOffset+___2844) <= vzMinMax.size())); REQUIRE(zoneMetadata.isSZL()); REQUIRE(zoneMetadata.getNumPartitions()>1); ___372 ___2038 = ___4227; ___4636 const zone = zoneMetadata.zone(); ItemAddress64::___2981 const numPartitions = zoneMetadata.getNumPartitions(); try { ___2038 = ___2038 && zoneMetadata.m_ptnMetadata.alloc(numPartitions); ___2038 = ___2038 && zoneMetadata.m_ptnNumNszs.alloc(numPartitions); ___2038 = ___2038 && zoneMetadata.m_ptnFirstNode.alloc(numPartitions); ___2038 = ___2038 && readHeaderTagArray<uint32_t>( file, ___3945, PARTITION_FILE_NUM_TAG, 0, numPartitions, zoneMetadata.m_ptnFileNums, readValueArray<uint32_t, false, 0>, IODescription(PARTITION_FILE_NUM_DESCRIPTION,IODescription::NO_VAR,zone)); ___2038 = ___2038 && readHeaderTagArray<uint64_t>( file, ___3945, PARTITION_FILE_LOC_TAG, 0, numPartitions, zoneMetadata.m_ptnHeaderFileLocs, readValueArray<uint64_t, true, 0>, IODescription(PARTITION_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); if (___3895(zoneMetadata.getZoneType(), zoneMetadata.getZoneDimension())) { ItemAddress64::SectionOffset_t const numSections = zoneMetadata.getZoneType() == ZoneType_FEMixed ? zoneMetadata.numSections() : 1; ___476(IMPLICATION(numSections > 1, ___1385.getFileVersion() > 105)); ___2038 = ___2038 && zoneMetadata.m_secPtnNumCells.alloc(numSections); ___2038 = ___2038 && zoneMetadata.m_secPtnFirstCell.alloc(numSections); ___2038 = ___2038 && zoneMetadata.m_secPtnNumCszs.alloc(numSections); if (___1385.getFileVersion() < 232) { ___2241<___2241<uint32_t>> secPtnNumCells_uint32;
___2038 = ___2038 && readSecHeaderTagArrays<uint32_t>( file, ___3945, PARTITION_NUM_CELLS_TAG, 0, numPartitions, numSections, secPtnNumCells_uint32, readValueArray<uint32_t, false, 0>, IODescription(PARTITION_NUM_CELLS_DESCRIPTION, IODescription::NO_VAR, zone)); for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < numSections; ++section) { ___2038 = zoneMetadata.m_secPtnNumCells[section].alloc(numPartitions); for (ItemAddress64::___2981 ptn = 0; ___2038 && ptn < numPartitions; ++ptn) zoneMetadata.m_secPtnNumCells[section][ptn] = secPtnNumCells_uint32[section][ptn]; } } else { ___2038 = ___2038 && readSecHeaderTagArrays<int64_t>( file, ___3945, PARTITION_NUM_CELLS_TAG, 0, numPartitions, numSections, zoneMetadata.m_secPtnNumCells, readValueArray<int64_t, false, 0>, IODescription(PARTITION_NUM_CELLS_DESCRIPTION, IODescription::NO_VAR, zone)); } ___463 totalNumCells = 0; for (ItemAddress64::___2981 ___2978 = 0; ___2038 && ___2978 < numPartitions; ++___2978) { for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < numSections; ++section) { if (___2978 == 0) { ___2038 = ___2038 && zoneMetadata.m_secPtnFirstCell[section].alloc(numPartitions); ___2038 = ___2038 && zoneMetadata.m_secPtnNumCszs[section].alloc(numPartitions); } if (___2038) { zoneMetadata.m_secPtnNumCszs[section][___2978] = getNumSzFromNumItems(zoneMetadata.m_secPtnNumCells[section][___2978]); zoneMetadata.m_secPtnFirstCell[section][___2978] = totalNumCells; totalNumCells += zoneMetadata.m_secPtnNumCells[section][___2978]; } } } ___2038 = ___2038 && zoneMetadata.m_ptnNumNodes.alloc(numPartitions); if (___1385.getFileVersion() < 232) { ___2241<uint32_t> ptnNumNodes_uint32; ___2038 = ___2038 && readHeaderTagArray<uint32_t>( file, ___3945, PARTITION_NUM_NODES_TAG, 0, numPartitions, ptnNumNodes_uint32, readValueArray<uint32_t, false, 0>, IODescription(PARTITION_NUM_NODES_DESCRIPTION, IODescription::NO_VAR, zone)); for (ItemAddress64::___2981 ptn = 0; ___2038 && ptn < numPartitions; ++ptn) zoneMetadata.m_ptnNumNodes[ptn] = ptnNumNodes_uint32[ptn]; } else { ___2038 = ___2038 && readHeaderTagArray<int64_t>( file, ___3945, PARTITION_NUM_NODES_TAG, 0, numPartitions, zoneMetadata.m_ptnNumNodes, readValueArray<int64_t, false, 0>, IODescription(PARTITION_NUM_NODES_DESCRIPTION, IODescription::NO_VAR, zone)); } if ( ___2038 ) { ___2719 totalNumNodes = 0; for (ItemAddress64::___2981 ___2978 = 0; ___2978 < numPartitions; ++___2978) { ___2719 const ___2822 = zoneMetadata.m_ptnNumNodes[___2978]; zoneMetadata.m_ptnNumNszs[___2978] = getNumSzFromNumItems(___2822); zoneMetadata.m_ptnFirstNode[___2978] = totalNumNodes; totalNumNodes += ___2822; } if ( totalNumNodes != zoneMetadata.___1767() ) ___2038 = ___1184("Mismatch of number of nodes between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone+1)); } } else { ___476(supportedOrderedVolumeZoneType(zoneMetadata.getZoneType(), zoneMetadata.getZoneDimension())); ___476(zoneMetadata.m_ptnNumNodes.empty());
___2038 = ___2038 && zoneMetadata.m_secPtnNumCells.alloc(1); ___2038 = ___2038 && zoneMetadata.m_secPtnFirstCell.alloc(1); ___2038 = ___2038 && zoneMetadata.m_secPtnNumCszs.alloc(1); ___2038 = ___2038 && zoneMetadata.m_secPtnNumCells[0].alloc(numPartitions); ___2038 = ___2038 && zoneMetadata.m_secPtnFirstCell[0].alloc(numPartitions); ___2038 = ___2038 && zoneMetadata.m_secPtnNumCszs[0].alloc(numPartitions); ___2038 = ___2038 && zoneMetadata.m_ptnNumNodes.alloc(numPartitions); ___2241<uint64_t> ptnMinNodeNumbers; ___2241<uint64_t> ptnMaxNodeNumbers; ___2038 = ___2038 && readHeaderTagArray<uint64_t>( file, ___3945, PARTITION_MIN_NODE_NUMBERS_TAG, 0, numPartitions, ptnMinNodeNumbers, readValueArray<uint64_t, false, 0>, IODescription(PARTITION_MIN_NODE_NUMBERS_DESCRIPTION, IODescription::NO_VAR, zone)); ___2038 = ___2038 && readHeaderTagArray<uint64_t>( file, ___3945, PARTITION_MAX_NODE_NUMBERS_TAG, 0, numPartitions, ptnMaxNodeNumbers, readValueArray<uint64_t, false, 0>, IODescription(PARTITION_MAX_NODE_NUMBERS_DESCRIPTION, IODescription::NO_VAR, zone)); ___2038 = ___2038 && zoneMetadata.m_ijkZoneInfos.alloc(numPartitions); ___2038 = ___2038 && zoneMetadata.m_ptnNodeMinIJKs.alloc(numPartitions); ___2038 = ___2038 && zoneMetadata.m_ptnNodeMaxIJKs.alloc(numPartitions); if (___2038) { ___463 totalNumCells = 0; ___2719 totalNumNodes = 0; for (ItemAddress64::___2981 ___2978 = 0; ___2978 < numPartitions; ___2978++) { zoneMetadata.m_ptnNodeMinIJKs[___2978] = zoneMetadata.getZoneIJK().ijkAtOffset(static_cast<___81>(ptnMinNodeNumbers[___2978])); zoneMetadata.m_ptnNodeMaxIJKs[___2978] = zoneMetadata.getZoneIJK().ijkAtOffset(static_cast<___81>(ptnMaxNodeNumbers[___2978])); ___1843 nodeDimensionIJK = zoneMetadata.m_ptnNodeMaxIJKs[___2978] - zoneMetadata.m_ptnNodeMinIJKs[___2978] + 1; IJKSubzoneInfo nodeSubzoneInfo(nodeDimensionIJK, ___1385.___1756(), ___2978, true  ); ___1843 cellDimensionIJK = nodeDimensionIJK; if (zoneMetadata.m_ptnNodeMaxIJKs[___2978].i() == zoneMetadata.getZoneIJK().i() - 1) cellDimensionIJK.setI(nodeDimensionIJK.i() - 1); if (zoneMetadata.m_ptnNodeMaxIJKs[___2978].___2104() == zoneMetadata.getZoneIJK().___2104() - 1) cellDimensionIJK.setJ(nodeDimensionIJK.___2104() - 1); if (zoneMetadata.m_ptnNodeMaxIJKs[___2978].___2133() == zoneMetadata.getZoneIJK().___2133() - 1) cellDimensionIJK.___3498(nodeDimensionIJK.___2133() - 1); IJKSubzoneInfo cellSubzoneInfo(cellDimensionIJK, ___1385.___1756(), ___2978, true); zoneMetadata.m_ijkZoneInfos[___2978] = ___1880(___2978, nodeSubzoneInfo, cellSubzoneInfo); zoneMetadata.m_secPtnNumCells[0][___2978] = zoneMetadata.m_ijkZoneInfos[___2978].___1765(); zoneMetadata.m_secPtnFirstCell[0][___2978] = totalNumCells; totalNumCells += zoneMetadata.m_secPtnNumCells[0][___2978]; zoneMetadata.m_secPtnNumCszs[0][___2978] = zoneMetadata.m_ijkZoneInfos[___2978].getNumCszs(); zoneMetadata.m_ptnNumNodes[___2978] = zoneMetadata.m_ijkZoneInfos[___2978].___1767(); zoneMetadata.m_ptnFirstNode[___2978] = totalNumNodes;
totalNumNodes += zoneMetadata.m_ptnNumNodes[___2978]; zoneMetadata.m_ptnNumNszs[___2978] = zoneMetadata.m_ijkZoneInfos[___2978].getNumNszs(); zoneMetadata.addPartitionTreeItem(___2978, zoneMetadata.m_ptnNodeMinIJKs[___2978], zoneMetadata.m_ptnNodeMaxIJKs[___2978]); } if (totalNumCells != zoneMetadata.___1765()) ___2038 = ___1184("Mismatched of number of cells between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone + 1)); else if (totalNumNodes != zoneMetadata.___1767()) ___2038 = ___1184("Mismatched of number of nodes between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone + 1)); } ptnMinNodeNumbers.___935(); ptnMaxNodeNumbers.___935(); } ___2038 = ___2038 && checkArrayHeaderTag(VAR_PARTITION_MIN_MAX_TAG, ___3945, IODescription(VAR_PARTITION_MIN_MAX_DESCRIPTION,IODescription::NO_VAR,zone)); ___2038 = ___2038 && zoneMetadata.m_varPtnMinMaxFileLocs.alloc(___2844, ___330); ___2038 = ___2038 && zoneMetadata.m_varPtnMinMaxTrees.alloc(___2844); if ( ___2038 ) { size_t const headerSize = file.___2001() ? ___206 + ASCII_SPACING_LEN : 0 ; ___1391 fileLoc = ___3945[VAR_PARTITION_MIN_MAX_TAG]; zoneMetadata.m_varPtnMinMaxFileLocs[0] = fileLoc; for ( ___4352 ___4336 = 1; ___4336 < ___2844; ++___4336 ) { size_t sizePerMinMax; switch ((FieldDataType_e)vzFieldDataTypes[varOffset + ___4336][zoneOffset + zone]) { case FieldDataType_Float: sizePerMinMax = file.___2001() ? ASCII_FLOAT_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(float); break; case FieldDataType_Double: sizePerMinMax = file.___2001() ? ASCII_DOUBLE_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(double); break; case FieldDataType_Int32: sizePerMinMax = file.___2001() ? ASCII_INT32_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(int32_t); break; case FieldDataType_Int16: sizePerMinMax = file.___2001() ? ASCII_INT16_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(int16_t); break; case FieldDataType_Byte: case ___1363: sizePerMinMax = file.___2001() ? ASCII_UINT8_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(uint8_t); break; default: ___476(___1303); sizePerMinMax = 0; break; } fileLoc += headerSize + numPartitions * sizePerMinMax; zoneMetadata.m_varPtnMinMaxFileLocs[___4336] = fileLoc; } } } catch(std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading partitioned zone %" PRIu64 " header.", uint64_t(zone+1)); } catch(...) { ___2038 = ___1184("Unrecoverable error while reading partitioned zone %" PRIu64 " header.", uint64_t(zone+1)); } if ( !___2038 ) { zoneMetadata.m_ptnFileNums.___935(); zoneMetadata.m_ptnHeaderFileLocs.___935(); zoneMetadata.m_secPtnNumCells.___935(); zoneMetadata.m_ptnNumNodes.___935(); zoneMetadata.m_secPtnFirstCell.___935(); zoneMetadata.m_ptnFirstNode.___935(); zoneMetadata.m_secPtnNumCszs.___935(); zoneMetadata.m_ptnNumNszs.___935(); zoneMetadata.m_ptnNodeMinIJKs.___935(); zoneMetadata.m_ptnNodeMaxIJKs.___935(); zoneMetadata.m_varPtnMinMaxFileLocs.___935(); zoneMetadata.m_varPtnMinMaxTrees.___935();
} ENSURE(VALID_BOOLEAN(___2038)); ENSURE(IMPLICATION(___2038, zoneMetadata.m_ptnFileNums.size()==size_t(numPartitions))); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnFileNums.empty())); ENSURE(IMPLICATION(___2038, zoneMetadata.m_ptnHeaderFileLocs.size()==size_t(numPartitions) && zoneMetadata.m_ptnHeaderFileLocs[0] != ___330 && zoneMetadata.m_ptnHeaderFileLocs[numPartitions/2] != ___330 && zoneMetadata.m_ptnHeaderFileLocs[numPartitions-1] != ___330)); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnHeaderFileLocs.empty())); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_secPtnNumCells.empty())); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnNumNodes.empty())); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_secPtnFirstCell.empty())); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnFirstNode.empty())); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnNodeMinIJKs.empty())); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnNodeMaxIJKs.empty())); if (___3895(zoneMetadata.getZoneType(), zoneMetadata.getZoneDimension())) { ENSURE(IMPLICATION(___2038, zoneMetadata.m_secPtnNumCells[0].size() == size_t(numPartitions))); ENSURE(IMPLICATION(___2038, zoneMetadata.m_ptnNumNodes.size() == size_t(numPartitions))); } else { ENSURE(IMPLICATION(___2038, zoneMetadata.m_ptnNodeMaxIJKs.size() == size_t(numPartitions))); ENSURE(IMPLICATION(___2038, zoneMetadata.m_ptnNodeMaxIJKs.size() == size_t(numPartitions) && zoneMetadata.m_ptnNodeMaxIJKs[0].blockSize() > 0 && zoneMetadata.m_ptnNodeMaxIJKs[numPartitions / 2].blockSize() > 0 && zoneMetadata.m_ptnNodeMaxIJKs[numPartitions - 1].blockSize() > 0)); } ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnNumNszs.empty())); ENSURE(IMPLICATION(___2038, zoneMetadata.m_secPtnNumCszs[0].size() == size_t(numPartitions))); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_secPtnNumCszs.empty())); ENSURE(IMPLICATION(___2038, zoneMetadata.m_ptnNumNszs.size()==size_t(numPartitions) && zoneMetadata.m_ptnNumNszs[0] > 0 && zoneMetadata.m_ptnNumNszs[numPartitions/2] > 0 && zoneMetadata.m_ptnNumNszs[numPartitions-1] > 0)); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_ptnNumNszs.empty())); ENSURE(IMPLICATION(___2038, zoneMetadata.m_varPtnMinMaxFileLocs.size() == size_t(___2844) && zoneMetadata.m_varPtnMinMaxFileLocs[0] != ___330 && zoneMetadata.m_varPtnMinMaxFileLocs[___2844/2] != ___330 && zoneMetadata.m_varPtnMinMaxFileLocs[___2844-1] != ___330)); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_varPtnMinMaxFileLocs.empty())); ENSURE(IMPLICATION(___2038, zoneMetadata.m_varPtnMinMaxTrees.size()==size_t(___2844))); ENSURE(IMPLICATION(!___2038, zoneMetadata.m_varPtnMinMaxTrees.empty())); return ___2038; } } ___372 readZoneHeaders( ___1397&             file, ___1386 const&           ___1385, ___4636                      zoneOffset, ___4636                      expectedZone, ___4352                       varOffset, ___4352                       numFileVars, VarZoneMinMaxArray const&        vzMinMax, ___4382 const& vzFieldDataType,
ZoneMetadata&                    zoneMetadata) { ___3946 ___3945; ___372 ___2038 = readZoneHeaderTags(file, expectedZone, ___3945); ___2038 = ___2038 && applyZoneHeaderScalarTagValues(___3945, zoneMetadata); if (zoneMetadata.isSZL()) { if (___2038) { if (zoneMetadata.getNumPartitions() == 1) { ___2038 = ___2038 && readSZLNonPartitionedZoneHeaderArrays( file, ___1385, ___3945, zoneOffset, varOffset, numFileVars, vzMinMax, vzFieldDataType, zoneMetadata); } else { ___2038 = ___2038 && readSZLPartitionedZoneHeaderArrays( file, ___1385, ___3945, zoneOffset, varOffset, numFileVars, vzMinMax, vzFieldDataType, zoneMetadata); } } ___476(IMPLICATION(___2038 && zoneMetadata.getZoneType() == ___4704, !zoneMetadata.m_ijkZoneInfos.empty())); } else { ___2038 = ___2038 && readNonSZLZoneHeaderArrays( file, ___3945, numFileVars, zoneMetadata); } return ___2038; } namespace { ___372 readUserFaceNeighborHeader( ___1397& file, ___4636          expectedZone) { REQUIRE(expectedZone >= 0); REQUIRE(file.___2001()); ___372 ___2038 = (readAndVerifyValue<uint32_t, false>( file, SZPLT_USER_FACE_NEIGHBOR_MARKER, IODescription(SZPLT_USER_FACE_NEIGHBOR_MARKER_DESCRIPTION)) && readAndVerifyValue<uint32_t, false>( file, expectedZone + 1, IODescription(SZPLT_ZONE_NUM_DESCRIPTION))); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 readFaceNeighbors( ___1397& file, ___4636          expectedZone, uint64_t&            numValues, ___1964&          ___4300) { ___372 ___2038 = ___4227; if (file.___2001()) ___2038 = readUserFaceNeighborHeader(file, expectedZone); ___2038 = ___2038 && readValue<uint64_t, false>(file, numValues, IODescription(SZPLT_USER_FACE_NEIGHBORS_COUNT_DESCRIPTION)); if (numValues) ___2038 = ___2038 && readValueArray<int32_t, false, 0>(file, 0, numValues, ___4300, IODescription(SZPLT_USER_FACE_NEIGHBORS_DESCRIPTION)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } namespace { ___372 readPartitionHeaderTags( ___1397&       file, ___4636                expectedZone, ItemAddress64::___2981 expectedPartition, ___3946&               ___3945) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); REQUIRE(expectedZone>=0); if ( file.___2001() ) { ___2038 = ___2038 && readAndVerifyValue<uint32_t, false>(file, SZPLT_PARTITION_MARKER, IODescription(SZPLT_PARTITION_MARKER_DESCRIPTION)); ___2038 = ___2038 && readAndVerifyValue<uint32_t, false>(file, uint32_t(expectedPartition + 1), IODescription(SZPLT_PARTITION_NUM_DESCRIPTION, IODescription::NO_VAR, expectedZone)); } static ___3943 tagDescriptionMap = PARTITION_TAG_DESCRIPTIONS_MAP_INITIALIZER; ___2038 = ___2038 && readTagList(file, tagDescriptionMap, ___3945); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 applyPartitionHeaderScalarTagValues( ___3946&       ___3945, PartitionMetadata& partitionMetadata) { ___372 ___2038 = ___4227; if ( ___2038 ) { try { partitionMetadata.m_numRefPartitions = ItemAddress64::___2981(___3945[NUM_REF_PARTITIONS_TAG]);
} catch(std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while retrieving partition tags."); } catch(...) { ___2038 = ___1184("Unrecoverable error while retrieving partition tags."); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readOrderedPartitionHeaderArrays( ___1397&             file, ___1386 const&           ___1385, ___3946&                     ___3945, ___4352                       varOffset, ___4352                       ___2844, ZoneMetadata const&              zoneMetadata, PartitionMetadata&               partitionMetadata, ___4636                      zone, ItemAddress64::___2981       ___2978, ___4382 const& vzFieldDataTypes) { REQUIRE(file.___2040()); REQUIRE(___2844>0); REQUIRE(zone >= 0); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2978)); ___372 ___2038 = readVarLocations( file, ___1385, ___3945, varOffset, ___2844, zoneMetadata, partitionMetadata, zone, ___2978, vzFieldDataTypes); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readFEPartitionHeaderArrays( ___1397&             file, ___1386 const&           ___1385, ___3946&                     ___3945, ___4352                       varOffset, ___4352                       ___2844, ZoneMetadata const&              zoneMetadata, PartitionMetadata&               partitionMetadata, ___4636                      zone, ItemAddress64::___2981       ___2978, ___4382 const& vzFieldDataTypes) { REQUIRE(file.___2040()); REQUIRE(___1385.getFileVersion() > 104); REQUIRE(___2844>0); REQUIRE(zone>=0); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2978)); ___372 ___2038 = ___4227; try { if (___1385.___842() != ___846) { if (___3945.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3945.end() && ___3945.find(NSZ_CONNECT_FILE_LOC_TAG)->second != ___330) { ___2038 = ___2038 && readSecPtnHeaderTagArrays<uint64_t>( file, ___3945, CSZ_CONNECT_FILE_LOC_TAG, 0, ___2978, zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, NULL , partitionMetadata.m_secCszConnectivityFileLocs, readValueArray<uint64_t, true, 0>, IODescription(CSZ_CONNECT_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone, ___2978)); ___2038 = ___2038 && readHeaderTagArray<uint64_t>( file, ___3945, NSZ_CONNECT_FILE_LOC_TAG, 0, zoneMetadata.m_ptnNumNszs[___2978], partitionMetadata.m_nszConnectivityFileLocs, readValueArray<uint64_t, true, 0>, IODescription(NSZ_CONNECT_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone, ___2978)); } else { ___476(___3945.find(CSZ_CONNECT_FILE_LOC_TAG) != ___3945.end() && ___3945.find(CSZ_CONNECT_FILE_LOC_TAG)->second == ___330); ___476(___3945.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3945.end() && ___3945.find(NSZ_CONNECT_FILE_LOC_TAG)->second == ___330); } } ___2038 = ___2038 && readVarLocations( file, ___1385, ___3945, varOffset, ___2844, zoneMetadata, partitionMetadata, zone, ___2978, vzFieldDataTypes);
if (___3945[NUM_REF_PARTITIONS_TAG] > 0) ___2038 = ___2038 && readHeaderTagArray<uint32_t>( file, ___3945, REF_PARTITIONS_TAG, 0, partitionMetadata.m_numRefPartitions, partitionMetadata.m_refPartitions, readValueArray<uint32_t, false, 0>, IODescription(REF_PARTITIONS_DESCRIPTION, IODescription::NO_VAR, zone, ___2978)); if (___1385.___842() != ___846) { if (___3945.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3945.end() && ___3945.find(NSZ_CONNECT_FILE_LOC_TAG)->second != ___330) { if (___2038 && partitionMetadata.m_secCszNumRefNszs.empty()) ___2038 = partitionMetadata.m_secCszNumRefNszs.alloc(zoneMetadata.numSections()); ___2038 = ___2038 && readSecPtnHeaderTagArrays<uint16_t>( file, ___3945, NUM_REF_NODE_SUBZONES_TAG, 0, ___2978, zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, NULL , partitionMetadata.m_secCszNumRefNszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_NODE_SUBZONES_DESCRIPTION, IODescription::NO_VAR, zone, ___2978)); ___2038 = ___2038 && readHeaderTagArray<uint16_t>( file, ___3945, NUM_REF_CELL_SUBZONES_TAG, 0, zoneMetadata.m_ptnNumNszs[___2978], partitionMetadata.m_nszNumRefCszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_CELL_SUBZONES_DESCRIPTION, IODescription::NO_VAR, zone, ___2978)); if (___2038 && partitionMetadata.m_secCszIncludesPtn.empty()) ___2038 = partitionMetadata.m_secCszIncludesPtn.alloc(zoneMetadata.numSections()); ___2038 = ___2038 && readSecPtnHeaderTagArrays<uint8_t>( file, ___3945, CELL_SUBZONE_INCLUDES_PARTITIONS_TAG, 0, ___2978, zoneMetadata.numSections(), zoneMetadata.m_secPtnNumCszs, numBytesForNumBits, partitionMetadata.m_secCszIncludesPtn, readValueArray<uint8_t, true, 0>, IODescription(CELL_SUBZONE_INCLUDES_PARTITIONS_DESCRIPTION, IODescription::NO_VAR, zone, ___2978)); ___2038 = ___2038 && readHeaderTagArray<uint8_t>( file, ___3945, NODE_SUBZONE_INCLUDES_PARTITIONS_TAG, 0, numBytesForNumBits(zoneMetadata.m_ptnNumNszs[___2978]), partitionMetadata.m_nszIncludesPtn, readValueArray<uint8_t, true, 0>, IODescription(NODE_SUBZONE_INCLUDES_PARTITIONS_DESCRIPTION, IODescription::NO_VAR, zone, ___2978)); } else { ___476(___3945.find(NUM_REF_NODE_SUBZONES_TAG) != ___3945.end() && ___3945.find(NUM_REF_NODE_SUBZONES_TAG)->second == ___330); ___476(___3945.find(NUM_REF_CELL_SUBZONES_TAG) != ___3945.end() && ___3945.find(NUM_REF_CELL_SUBZONES_TAG)->second == ___330); ___476(___3945.find(CELL_SUBZONE_INCLUDES_PARTITIONS_TAG) != ___3945.end() && ___3945.find(CELL_SUBZONE_INCLUDES_PARTITIONS_TAG)->second == ___330); ___476(___3945.find(NODE_SUBZONE_INCLUDES_PARTITIONS_TAG) != ___3945.end() && ___3945.find(NODE_SUBZONE_INCLUDES_PARTITIONS_TAG)->second == ___330); } } } catch(std::bad_alloc const&) { ___2038 = ___1184("Out-of-memory error while reading partition %" PRIu64 " header of zone %" PRIu64 ".", uint64_t(___2978+1), uint64_t(zone+1)); } catch(...) { ___2038 = ___1184("Unrecoverable error while reading partition %" PRIu64 " header of zone %" PRIu64 ".", uint64_t(___2978+1), uint64_t(zone+1));
} if ( !___2038 ) { partitionMetadata.m_nszConnectivityFileLocs.___935(); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 readPartitionHeader( ___1397&             file, ___1386 const&           ___1385, ___4352                       numFileVars, ___4352                       targetBaseVarOffset, ___4636                      fileInfoZoneOffset, ItemAddress64::___2981       ___2978, ZoneMetadata const&              zoneMetadata, ___4382 const& vzFieldDataType, PartitionMetadata&               partitionMetadata) { ___3946 ___3945; ___372 ___2038 = readPartitionHeaderTags(file, fileInfoZoneOffset, ___2978, ___3945); ___2038 = ___2038 && applyPartitionHeaderScalarTagValues(___3945, partitionMetadata); if (zoneMetadata.getZoneType() == ___4704) ___2038 = ___2038 && readOrderedPartitionHeaderArrays( file, ___1385, ___3945, targetBaseVarOffset, numFileVars, zoneMetadata, partitionMetadata, fileInfoZoneOffset, ___2978, vzFieldDataType); else ___2038 = ___2038 && readFEPartitionHeaderArrays( file, ___1385, ___3945, targetBaseVarOffset, numFileVars, zoneMetadata, partitionMetadata, fileInfoZoneOffset, ___2978, vzFieldDataType); return ___2038; } namespace { template <typename ARRAY_TYPE> ___372 readCompressedRefSzAddresses( ___1397&           fileWrapper, uint32_t                       fileVersion, ZoneType_e                     ___4692, ItemAddress64::___2981     numRefPtns, ItemAddress64::___2981     curPartition, PartitionArray const&          refPartitions, ARRAY_TYPE&                    refPtnOffsets, RefSubzoneOffset_t             numRefSzs, bool                           areRefCellSzs, ItemAddress64::SubzoneAddress* refSubzoneAddresses, IODescription const&           szConnectRefIODescription) { REQUIRE(fileWrapper.___2040()); REQUIRE(numRefPtns != 1); REQUIRE(refPartitions.size() == numRefPtns); REQUIRE(VALID_REF(refSubzoneAddresses) && "refSubzoneAddresses size is numRefSzs"); REQUIRE(szConnectRefIODescription.___2066()); ___372 ___2038 = ___4227; ___476(sizeof(ItemAddress64::SubzoneAddress) == sizeof(uint64_t)); ___476(sizeof(ItemAddress64::SubzoneOffset_t) == sizeof(uint32_t)); ItemAddress64::SubzoneOffset_t* const szOffsetArray = reinterpret_cast<ItemAddress64::SubzoneOffset_t*>(refSubzoneAddresses); ___2038 = ___2038 && readValues<uint32_t, false, 1>(fileWrapper, numRefSzs, szOffsetArray, szConnectRefIODescription); if (___2038) { BitArray<ItemAddress64::SectionOffset_t,4> refCszSec4BitOffsets(numRefSzs, 0); if (areRefCellSzs && fileVersion > 105 && ___4692 == ZoneType_FEMixed) { ___2038 = readValues<uint8_t, false, 0>(fileWrapper, refCszSec4BitOffsets.byteSize(), refCszSec4BitOffsets.data(), szConnectRefIODescription); } if ( ___2038 ) { for (RefSubzoneOffset_t ___2866 = 0; ___2866 < numRefSzs; ++___2866) { RefSubzoneOffset_t const refSzOffset = numRefSzs-___2866-1; ___476(refSzOffset < numRefSzs); ItemAddress64::___2981 const ___2978 = numRefPtns == 0
? curPartition : refPartitions[refPtnOffsets[refSzOffset]]; refSubzoneAddresses[refSzOffset] = ItemAddress64::SubzoneAddress( ___2978, refCszSec4BitOffsets[refSzOffset], szOffsetArray[refSzOffset]); } } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { template <size_t COMPRESSED_OFFSET_BIT_SIZE> ___372 readCompressedRefSzAddressesForBitSize( ___1397&           fileWrapper, uint32_t                       fileVersion, ZoneType_e                     ___4692, ItemAddress64::___2981     numRefPtns, ItemAddress64::___2981     curPartition, PartitionArray const&          refPartitions, RefSubzoneOffset_t             numRefSzs, bool                           areRefCellSzs, ItemAddress64::SubzoneAddress* refSubzoneAddresses, IODescription const&           szConnectRefIODescription, IODescription const&           szConnectRefPtnIODescription) { REQUIRE(COMPRESSED_OFFSET_BIT_SIZE == 2 || COMPRESSED_OFFSET_BIT_SIZE == 4 || COMPRESSED_OFFSET_BIT_SIZE == 8); size_t numBytesForRefPtnOffsets = BitArray<uint16_t,COMPRESSED_OFFSET_BIT_SIZE>::byteArraySize(numRefSzs); static size_t const MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS = 1024; uint8_t  stackRefPtnOffsets[MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS]; uint8_t* refPtnOffsetsByteArray = numBytesForRefPtnOffsets > MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS ? (uint8_t*)malloc(numBytesForRefPtnOffsets) : stackRefPtnOffsets; ___372 ___2038 = ___4227; BitArray<uint16_t,COMPRESSED_OFFSET_BIT_SIZE> refPtnOffsets(refPtnOffsetsByteArray,numRefSzs); if (numRefPtns > 0) ___2038 = ___2038 && readValues<uint8_t, true, 0>( fileWrapper, refPtnOffsets.byteSize(), refPtnOffsets.data(), szConnectRefPtnIODescription); ___2038 = ___2038 && readCompressedRefSzAddresses(fileWrapper, fileVersion, ___4692, numRefPtns, curPartition, refPartitions, refPtnOffsets, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription); if (numBytesForRefPtnOffsets > MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS) free(refPtnOffsetsByteArray); return ___2038; } } namespace { ___372 readCompressedRefSzAddresses( ___1397&           fileWrapper, uint32_t                       fileVersion, ZoneType_e                     ___4692, ItemAddress64::___2981     numRefPtns, ItemAddress64::___2981     curPartition, PartitionArray const&          refPartitions, RefSubzoneOffset_t             numRefSzs, bool                           areRefCellSzs, ItemAddress64::SubzoneAddress* refSubzoneAddresses, IODescription const&           szConnectRefIODescription) { REQUIRE(fileWrapper.___2040()); REQUIRE(numRefPtns != 1); REQUIRE(refPartitions.size() == numRefPtns); REQUIRE(VALID_REF(refSubzoneAddresses) && "refSubzoneAddresses size is numRefSzs"); REQUIRE(szConnectRefIODescription.___2066()); ___372 ___2038 = ___4227; if (numRefPtns <= MAX_ENTRIES_FOR_2_BIT_COMPRESSION) { ___2038 = readCompressedRefSzAddressesForBitSize<2>(fileWrapper, fileVersion, ___4692, numRefPtns, curPartition, refPartitions, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription,
IODescription(SZ_CONNECT_REF_PTN_OFFSET_2BIT_ARRAY_DESCRIPTION)); } else if (numRefPtns <= MAX_ENTRIES_FOR_4_BIT_COMPRESSION) { ___2038 = readCompressedRefSzAddressesForBitSize<4>(fileWrapper, fileVersion, ___4692, numRefPtns, curPartition, refPartitions, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription, IODescription(SZ_CONNECT_REF_PTN_OFFSET_4BIT_ARRAY_DESCRIPTION)); } else if (numRefPtns <= MAX_ENTRIES_FOR_8_BIT_COMPRESSION) { ___2038 = readCompressedRefSzAddressesForBitSize<8>(fileWrapper, fileVersion, ___4692, numRefPtns, curPartition, refPartitions, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription, IODescription(SZ_CONNECT_REF_PTN_OFFSET_8BIT_ARRAY_DESCRIPTION)); } else { size_t const numRefPtnOffsets = numRefPtns > 0 ? numRefSzs : 0; static size_t const MAX_OFFSETS_FOR_STACK_REF_PTN_OFFSETS = 1024; uint16_t stackRefPtnOffsets[MAX_OFFSETS_FOR_STACK_REF_PTN_OFFSETS]; uint16_t* refPtnOffsetsArray = numRefPtnOffsets > MAX_OFFSETS_FOR_STACK_REF_PTN_OFFSETS ? (uint16_t*)malloc(numRefPtnOffsets*sizeof(uint16_t)) : stackRefPtnOffsets; if (refPtnOffsetsArray != NULL) { ___3270<uint16_t> refPtnOffsets(refPtnOffsetsArray, numRefSzs, numRefSzs); if (numRefPtns > 0) ___2038 = ___2038 && readValues<uint16_t, true, 0>( fileWrapper, numRefSzs, refPtnOffsets.data(), IODescription(SZ_CONNECT_REF_PTN_OFFSET_16BIT_ARRAY_DESCRIPTION)); ___2038 = ___2038 && readCompressedRefSzAddresses(fileWrapper, fileVersion, ___4692, numRefPtns, curPartition, refPartitions, refPtnOffsets, numRefSzs, areRefCellSzs, refSubzoneAddresses, szConnectRefIODescription); if (numRefPtnOffsets > MAX_OFFSETS_FOR_STACK_REF_PTN_OFFSETS) free(refPtnOffsetsArray); } else { ___2038 = ___1184("Cannot allocate memory for reading referenced subzone addresses"); } } return ___2038; } } namespace { template <size_t COMPRESSED_OFFSET_BIT_SIZE> ___372 readCompressedConnectivity( ___1397&         fileWrapper, ___1386 const&       ___1385, uint32_t                     ___2796, IODescription const&         ___970, CszConnectivity&             cszConnectivity) { ___372 ___2038 = ___4227; BitArray<uint16_t,COMPRESSED_OFFSET_BIT_SIZE> rszOffsetsBitArray(___2796); if (COMPRESSED_OFFSET_BIT_SIZE > 2 && ___1385.getFileVersion() == 104 ) ___2038 = readValues<uint8_t, false, 0>(fileWrapper, rszOffsetsBitArray.byteSize(), rszOffsetsBitArray.data(), ___970); else ___2038 = readValues<uint8_t, true, 0>(fileWrapper, rszOffsetsBitArray.byteSize(), rszOffsetsBitArray.data(), ___970); uint16_t* const rszOffsetArray = cszConnectivity.getRszOffsetArray(); for (size_t ___2866 = 0; ___2038 && ___2866 < rszOffsetsBitArray.size(); ++___2866) rszOffsetArray[___2866] = rszOffsetsBitArray[___2866]; return ___2038; } } ___372 readCszConnectivity( ___1397&           fileWrapper, ___1386 const&         ___1385, ZoneMetadata const&            zoneMetadata, ItemAddress64::___2981     ___2978, ItemAddress64::SectionOffset_t section,
ItemAddress64::SubzoneOffset_t cszOffset, CszConnectivity&               cszConnectivity) { REQUIRE(fileWrapper.___2040()); REQUIRE(cszConnectivity.empty()); RefSubzoneOffset_t numRefNszs; if (___1385.getFileVersion() == 104) numRefNszs = 0; else numRefNszs = zoneMetadata.m_ptnMetadata[___2978].m_secCszNumRefNszs[section][cszOffset]; ItemAddress64::___2981 numRefPtns; if (zoneMetadata.m_ptnMetadata[___2978].m_secCszIncludesPtn.empty() || zoneMetadata.m_ptnMetadata[___2978].m_secCszIncludesPtn[section].empty()) { ___476(zoneMetadata.getNumPartitions() == 1); ___476(___2978 == 0); numRefPtns = 0; } else { ___476(___1385.getFileVersion() > 104); if (bitValue(zoneMetadata.m_ptnMetadata[___2978].m_secCszIncludesPtn[section], cszOffset)) numRefPtns = zoneMetadata.m_ptnMetadata[___2978].m_numRefPartitions; else numRefPtns = 0; } PartitionArray emptyPartitionList; PartitionArray const& refPartitions = (numRefPtns == 0) ? emptyPartitionList : zoneMetadata.m_ptnMetadata[___2978].m_refPartitions; ___476(refPartitions.size() == size_t(numRefPtns)); ItemAddress64::ItemOffset_t ___2782; if (cszOffset + 1 == zoneMetadata.getNumCszsInPartitionSection(___2978, section)) ___2782 = ItemAddress64::ItemOffset_t(((zoneMetadata.m_secPtnNumCells[section][___2978] - 1)&ItemAddress64::MAX_ITEM_OFFSET) + 1); else ___2782 = ItemAddress64::MAX_ITEM_OFFSET + 1; uint32_t const numNodesPerCell = uint32_t(zoneMetadata.getNumNodesPerCell(section)); uint32_t const ___2796 = uint32_t(___2782) * numNodesPerCell; ___372 ___2038 = ___4227; if ( ___1385.getFileVersion() == 104 ) ___2038 = readValue<uint16_t, false>(fileWrapper, numRefNszs, IODescription(CSZ_CONNECT_NUM_REF_NSZ)); if ( ___2038 && ( numRefNszs == 0 || numRefNszs > ___2796 ) ) ___2038 = ___1184("Bad value for %s.", CSZ_CONNECT_NUM_REF_NSZ); if ( ___2038 && !cszConnectivity.alloc(___2782, numNodesPerCell, numRefNszs) ) ___2038 = ___1184("Cannot allocate memory for cell connectivity (%" PRIu64 " entries, %" PRIu64 " ref subzones).", uint64_t(___2796), uint64_t(numRefNszs)); ___2038 = ___2038 && readCompressedRefSzAddresses( fileWrapper, ___1385.getFileVersion(), zoneMetadata.getZoneType(), numRefPtns, ___2978, refPartitions, numRefNszs, false , cszConnectivity.getRefNszArray(), IODescription(CSZ_CONNECT_REF_NSZ_ARRAY_DESCRIPTION)); if ( ___2038 ) { if ( numRefNszs <= MAX_ENTRIES_FOR_2_BIT_COMPRESSION && ___1385.getFileVersion() > 104 ) { ___2038 = readCompressedConnectivity<2>(fileWrapper, ___1385, ___2796, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_2BIT_ARRAY_DESCRIPTION), cszConnectivity); } else if ( numRefNszs <= MAX_ENTRIES_FOR_4_BIT_COMPRESSION ) { ___2038 = readCompressedConnectivity<4>(fileWrapper, ___1385, ___2796, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_4BIT_ARRAY_DESCRIPTION), cszConnectivity); } else if ( numRefNszs <= MAX_ENTRIES_FOR_8_BIT_COMPRESSION ) { ___2038 = readCompressedConnectivity<8>(fileWrapper, ___1385, ___2796, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_8BIT_ARRAY_DESCRIPTION), cszConnectivity);
} else { uint16_t* const rszOffsetArray = cszConnectivity.getRszOffsetArray(); if ( ___1385.getFileVersion() == 104 ) ___2038 = readValues<uint16_t, false, 0>(fileWrapper, ___2796, rszOffsetArray, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_16BIT_ARRAY_DESCRIPTION)); else ___2038 = readValues<uint16_t, true, 0>(fileWrapper, ___2796, rszOffsetArray, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_16BIT_ARRAY_DESCRIPTION)); } } if ( ___2038 ) { uint8_t* offsetArray = cszConnectivity.getItemOffsetArray(); ___2038 = readValues<uint8_t, false, 0>(fileWrapper, ___2796, offsetArray, IODescription(CSZ_CONNECT_NSZ_OFFSET_ARRAY_DESCRIPTION)); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 readNszConnectivity( ___1397&       fileWrapper, ___1386 const&     ___1385, ZoneMetadata const&        zoneMetadata, ItemAddress64::___2981 numRefPtns, ItemAddress64::___2981 ___2978, PartitionArray const&      refPartitions, RefSubzoneOffset_t         numRefCszs, NszConnectivity&           nszConnectivity) { REQUIRE(fileWrapper.___2040()); REQUIRE(IMPLICATION(___1385.getFileVersion() == 104, numRefPtns == 0)); REQUIRE(refPartitions.size() == numRefPtns); REQUIRE(IMPLICATION(___1385.getFileVersion() == 104, numRefCszs == 0)); REQUIRE(nszConnectivity.empty()); ___372 ___2038 = ___4227; if ( ___1385.getFileVersion() == 104 ) ___2038 = readValue<uint16_t, false>(fileWrapper, numRefCszs, IODescription(NSZ_CONNECT_NUM_REF_CSZ)); if ( ___2038 && !nszConnectivity.setNumRszs(numRefCszs) ) ___2038 = ___1184("Cannot allocate memory for node connectivity referenced cell subzones (%" PRIu64 " subzones).", uint64_t(numRefCszs)); if ( ___2038 && numRefCszs > 0 ) ___2038 = ___2038 && readCompressedRefSzAddresses( fileWrapper, ___1385.getFileVersion(), zoneMetadata.getZoneType(), numRefPtns, ___2978, refPartitions, numRefCszs, true , &nszConnectivity.m_refCszs[0], IODescription(NSZ_CONNECT_REF_CSZS)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } }}
