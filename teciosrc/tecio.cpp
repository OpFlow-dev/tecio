#include "MASTER.h"
#include "GLOBAL.h"
 #if defined _MSC_VER && _MSC_VER <= 1800
 #define FUNCTION_NAME __FUNCTION__
 #else
 #define FUNCTION_NAME __func__
 #endif
#include "ThirdPartyHeadersBegin.h"
#include <boost/assign.hpp>
#include <boost/unordered_map.hpp>
#include <iostream>
#include <memory>
#include <numeric>
#include "ThirdPartyHeadersEnd.h"
#include "CodeContract.h"
#include "TECIO.h"
#include "CHARTYPE.h"
 #if !defined TECIOMPI
#include "TecioPLT.h"
 #endif
#include "TecioSZL.h"
using namespace tecplot::tecioszl;
 #define ___2883 0
 #define ___1338 1
 #define ___1346 2
 #define ___1341 3
 #define ___1345 4
 #define FEBRICK 5
 #define ___1339 6
 #define ___1340 7
 #define FEMIXED 8
 #define ___1533 0
 #define ___1810 1
 #define ___3639 2
 #if defined MSWIN && defined _DEBUG
 #define ___3185(s) do { OutputDebugStringA(s); printf(s); } while (0)
 #define ___3186(s,a1) do { char ___416[512]; sprintf(___416,s,a1); OutputDebugStringA(___416); printf(___416); } while (0)
 #define ___3187(s,a1,a2) do { char ___416[512]; sprintf(___416,s,a1,a2); OutputDebugStringA(___416); printf(___416); } while (0)
 #else
 #define ___3185(s) printf(s)
 #define ___3186(s,a1) printf(s,a1)
 #define ___3187(s,a1,a2) printf(s,a1,a2)
 #endif
 #define ___23(n, T, s) (new T[n])
 #define ___1528(a, s) (delete[] a);
 #define ___2381 10
 #if !defined _WIN32
 #   define ___1232
 #endif
namespace { int32_t ___689 = -1; std::vector<int32_t> ___1389(___2381, 0); std::vector<int32_t> ___2041(___2381, 0); boost::unordered_map<void*, int32_t> fileFormatForHandle; int firstOpenFile() { ___476(___1389.size() == ___2381); ___476(___2041.size() == ___2381); for (int ___1831 = 0; ___1831 < ___2381; ++___1831) { if (!___2041[___1831]) return ___1831; } return -1; } struct FileInfo { int32_t m_fileFormat; void* m_typeSpecificData; explicit FileInfo(int32_t ___1388) : m_fileFormat(___1388) , m_typeSpecificData(NULL) {} }; } int32_t tecFileWriterOpen( char const* ___1392, char const* dataSetTitle, char const* variableList, int32_t     ___1388, int32_t     ___1405, int32_t     defaultVarType, void*       gridFileHandle, void**      fileHandle) { void* gridFileTypeSpecificData = NULL; if (___1405 == ___3639) { if (gridFileHandle) { gridFileTypeSpecificData = ((FileInfo*)gridFileHandle)->m_typeSpecificData; } else { ___3185("Err: (tecFileWriterOpen) invalid parameter gridFileHandle.\n"); return -1; } } try {
 #if !defined TECIOMPI
if (___1388 == FILEFORMAT_PLT) { ___3185("Err: (tecFileWriterOpen) .plt format not yet supported\n"); return -1; } else if (___1388 == FILEFORMAT_SZL) {
 #endif
FileInfo* fileInfo = new FileInfo(___1388); if (tecFileWriterOpen_SZL(___1392, dataSetTitle, variableList, ___1405, defaultVarType, gridFileTypeSpecificData, &fileInfo->m_typeSpecificData) == 0) { *fileHandle = fileInfo; } else { delete fileInfo; return -1; }
 #if !defined TECIOMPI
} else { ___3186("Err: (tecFileWriterOpen) invalid value for fileFormat: %d\n", ___1388); return -1; }
 #endif
} catch (std::exception const& e) { ___3186("tecFileWriterOpen: %s\n", e.what()); return -1; } return 0; } int32_t tecFileSetDiagnosticsLevel(void* fileHandle, int32_t level) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecFileSetDiagnosticsLevel) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecFileSetDiagnosticsLevel) .plt format not yet supported\n"); else if (fileInfo->m_fileFormat == FILEFORMAT_SZL)
 #else
else
 #endif
return tecFileSetDiagnosticsLevel_SZL(fileInfo->m_typeSpecificData, level); return -1; }
 #if defined TECIOMPI
int32_t tecMPIInitialize(void* fileHandle, MPI_Comm communicator, int32_t mainRank) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecMPIInitialize) invalid fileHandle parameter\n"); else return tecMPIInitialize_SZL(fileInfo->m_typeSpecificData, communicator, mainRank); return -1; } EXTERNC tecio_API int32_t tecMPIInitializef(void*fileHandle, int32_t communicator, int32_t mainRank) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecMPIInitialize) invalid fileHandle parameter\n"); else if (!MPI_Comm_f2c(communicator)) ___3185("Err: (tecMPIInitialize) invalid communicator parameter\n"); else return tecMPIInitialize_SZL(fileInfo->m_typeSpecificData, MPI_Comm_f2c(communicator), mainRank); return -1; } int32_t tecMPIFileSetInfo(void* fileHandle, MPI_Info info) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecMPIFileSetInfo) invalid fileHandle parameter\n"); else return tecMPIFileSetInfo_SZL(fileInfo->m_typeSpecificData, info); return -1; } EXTERNC tecio_API int32_t tecMPIFileSetInfof(void*fileHandle, int32_t info) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecMPIFileSetInfo) invalid fileHandle parameter\n"); else if (!MPI_Info_f2c(info)) ___3185("Err: (tecMPIFileSetInfo) invalid info parameter\n"); else return tecMPIFileSetInfo_SZL(fileInfo->m_typeSpecificData, MPI_Info_f2c(info)); return -1; }
 #endif
int32_t tecZoneCreateIJK( void*          fileHandle, char const*    ___4690, int64_t        imax, int64_t        jmax, int64_t        kmax, int32_t const* varTypes, int32_t const* ___3552, int32_t const* valueLocations, int32_t const* ___2983, int32_t        shareFaceNeighborsFromZone, int64_t        ___2803, int32_t        ___1282, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneCreateIJK) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneCreateIJK) .plt format not yet supported\n");
 #endif
else return tecZoneCreateIJK_SZL( fileInfo->m_typeSpecificData, ___4690, imax, jmax, kmax, varTypes, ___3552, valueLocations, ___2983, shareFaceNeighborsFromZone, ___2803, ___1282, zone); return -1; } int32_t tecZoneCreateFE( void*          fileHandle, char const*    ___4690, int32_t        ___4692, int64_t        ___2822, int64_t        ___2782, int32_t const* varTypes, int32_t const* ___3552, int32_t const* valueLocations, int32_t const* ___2983, int32_t        ___3550, int64_t        ___2803, int32_t        ___1282, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneCreateFE) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneCreateFE) .plt format not yet supported\n");
 #endif
else return tecZoneCreateFE_SZL( fileInfo->m_typeSpecificData, ___4690, ___4692, ___2822, ___2782, varTypes, ___3552, valueLocations, ___2983, ___3550, ___2803, ___1282, zone); return -1; } int32_t tecZoneCreateFEMixed( void*          fileHandle, char const*    ___4690, int64_t        ___2822, int32_t        numSections, int32_t const* cellShapePerSection, int32_t const* gridOrderPerSection, int32_t const* basisFnPerSection, int64_t const* numElementsPerSection, int32_t const* varTypes, int32_t const* ___3552, int32_t const* valueLocations, int32_t const* ___2983, int32_t        ___3550, int64_t        ___2803, int32_t        ___1282, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneCreateFEMixed) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneCreateFEMixed) .plt format not yet supported\n");
 #endif
else return tecZoneCreateFEMixed_SZL( fileInfo->m_typeSpecificData, ___4690, ___2822, numSections, cellShapePerSection, gridOrderPerSection, basisFnPerSection, numElementsPerSection, varTypes, ___3552, valueLocations, ___2983, ___3550, ___2803, ___1282, zone); return -1; } int32_t tecZoneCreatePoly( void*          fileHandle, char const*    ___4690, int32_t        ___4692, int64_t        ___2822, int64_t        numFaces, int64_t        ___2782, int64_t        ___4193, int32_t const* varTypes, int32_t const* ___3552, int32_t const* valueLocations, int32_t const* ___2983, int32_t        ___3550, int64_t        ___2787, int64_t        ___4189, int32_t*       zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneCreatePoly) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneCreatePoly) .plt format not yet supported\n");
 #endif
else return tecZoneCreatePoly_SZL( fileInfo->m_typeSpecificData, ___4690, ___4692, ___2822, numFaces, ___2782, ___4193, varTypes, ___3552, valueLocations, ___2983, ___3550, ___2787, ___4189, zone); return -1; } int32_t tecZoneSetUnsteadyOptions( void*   fileHandle, int32_t zone, double  ___3641, int32_t ___3786) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneSetUnsteadyOptions) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneSetUnsteadyOptions) .plt format not yet supported\n");
 #endif
else return tecZoneSetUnsteadyOptions_SZL(fileInfo->m_typeSpecificData, zone, ___3641, ___3786); return -1; } int32_t tecZoneSetParentZone( void*   fileHandle, int32_t zone, int32_t  ) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneSetParentZone) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneSetParentZone) .plt format not yet supported\n");
 #endif
else return tecZoneSetParentZone_SZL(fileInfo->m_typeSpecificData, zone, 0); return -1; } int32_t tecZoneMapPartitionsToMPIRanks( void*          fileHandle, int32_t&       zone, int32_t        numPartitions, int32_t const* mpiRanksForPartitions) {
 #if defined TECIOMPI
___4279(zone); FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneMapPartitionsToMPIRanks) invalid fileHandle parameter\n"); else if (zone < 0) ___3186("Err: (tecZoneMapPartitionsToMPIRanks) Bad value for parameter zone: %d.\n", zone); else if (numPartitions < 1) ___3186("Err: (tecZoneMapPartitionsToMPIRanks) Bad value for parameter numPartitions: %d.\n", numPartitions); else if (!mpiRanksForPartitions) ___3185("Err: (tecZoneMapPartitionsToMPIRanks) Bad value <NULL> for parameter mpiRanksForPartitions.\n"); else return tecZoneMapPartitionsToMPIRanks_SZL(fileInfo->m_typeSpecificData, numPartitions, mpiRanksForPartitions); return -1;
 #else
___4279(fileHandle); ___4279(zone); ___4279(numPartitions); ___4279(mpiRanksForPartitions); ___3185("Err: (mpiRanksForPartitions) To use the TECIO MPI symbols you must link your application " "with the teciompi library instead of the non-MPI version, tecio.\n"); return -1;
 #endif
} int32_t tecFEPartitionCreate32( void*          fileHandle, int32_t        zone, int32_t        ___2978, int64_t        ___2822, int64_t        ___2782, int64_t        numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t        numGhostCells, int32_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecFEPartitionCreate32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecFEPartitionCreate32) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate32_SZL( fileInfo->m_typeSpecificData, zone, ___2978, ___2822, &___2782, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, &numGhostCells, ghostCells); return -1; } int32_t tecFEPartitionCreate64( void*          fileHandle, int32_t        zone, int32_t        ___2978, int64_t        ___2822, int64_t        ___2782, int64_t        numGhostNodes, int64_t const* ghostNodes, int32_t const* neighborPartitions, int64_t const* neighborPartitionNodes, int64_t        numGhostCells, int64_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecFEPartitionCreate64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecFEPartitionCreate64) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate64_SZL( fileInfo->m_typeSpecificData, zone, ___2978, ___2822, &___2782, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, &numGhostCells, ghostCells); return -1; } int32_t tecFEMixedPartitionCreate32( void*          fileHandle, int32_t        zone, int32_t        ___2978, int64_t        ___2822, int64_t const* numCellsPerSection, int64_t        numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int32_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecFEPartitionCreate32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecFEPartitionCreate32) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate32_SZL( fileInfo->m_typeSpecificData, zone, ___2978, ___2822, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); return -1; } int32_t tecFEMixedPartitionCreate64( void*          fileHandle, int32_t        zone, int32_t        ___2978, int64_t        ___2822, int64_t const* numCellsPerSection, int64_t        numGhostNodes, int64_t const* ghostNodes, int32_t const* neighborPartitions, int64_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int64_t const* ghostCells) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecFEPartitionCreate64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecFEPartitionCreate64) .plt format does not support partitions\n");
 #endif
else return tecFEPartitionCreate64_SZL( fileInfo->m_typeSpecificData, zone, ___2978, ___2822, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); return -1; } int32_t tecIJKPartitionCreate( void*   fileHandle, int32_t zone, int32_t ___2978, int64_t imin, int64_t jmin, int64_t kmin, int64_t imax, int64_t jmax, int64_t kmax) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecIJKPartitionCreate) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecIJKPartitionCreate) .plt format does not support partitions\n");
 #endif
else return tecIJKPartitionCreate_SZL( fileInfo->m_typeSpecificData, zone, ___2978, imin, jmin, kmin, imax, jmax, kmax); return -1; } int32_t tecZoneVarWriteDoubleValues( void*         fileHandle, int32_t       zone, int32_t       ___4336, int32_t       ___2978, int64_t       count, double const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneVarWriteDoubleValues) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneVarWriteDoubleValues) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteDoubleValues_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2978, count, values); return -1; } int32_t tecZoneVarWriteFloatValues( void*        fileHandle, int32_t      zone, int32_t      ___4336, int32_t      ___2978, int64_t      count, float const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneVarWriteFloatValues) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneVarWriteFloatValues) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteFloatValues_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2978, count, values); return -1; } int32_t tecZoneVarWriteInt32Values( void*          fileHandle, int32_t        zone, int32_t        ___4336, int32_t        ___2978, int64_t        count, int32_t const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneVarWriteInt32Values) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneVarWriteInt32Values) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteInt32Values_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2978, count, values); return -1; } int32_t tecZoneVarWriteInt16Values( void*          fileHandle, int32_t        zone, int32_t        ___4336, int32_t        ___2978, int64_t        count, int16_t const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneVarWriteInt16Values) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneVarWriteInt16Values) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteInt16Values_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2978, count, values); return -1; } int32_t tecZoneVarWriteUInt8Values( void*          fileHandle, int32_t        zone, int32_t        ___4336, int32_t        ___2978, int64_t        count, uint8_t const* values) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneVarWriteUInt8Values) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneVarWriteUInt8Values) .plt format not yet supported\n");
 #endif
else return tecZoneVarWriteUInt8Values_SZL(fileInfo->m_typeSpecificData, zone, ___4336, ___2978, count, values); return -1; } int32_t tecZoneNodeMapWrite32( void*          fileHandle, int32_t        zone, int32_t        ___2978, int32_t        nodesAreOneBased, int64_t        count, int32_t const* nodes) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneNodeMapWrite32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneNodeMapWrite32) .plt format not yet supported\n");
 #endif
else return tecZoneNodeMapWrite32_SZL(fileInfo->m_typeSpecificData, zone, ___2978, nodesAreOneBased, count, nodes); return -1; } int32_t tecZoneNodeMapWrite64( void*          fileHandle, int32_t        zone, int32_t        ___2978, int32_t        nodesAreOneBased, int64_t        count, int64_t const* nodes) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneNodeMapWrite64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneNodeMapWrite64) .plt format not yet supported\n");
 #endif
else return tecZoneNodeMapWrite64_SZL(fileInfo->m_typeSpecificData, zone, ___2978, nodesAreOneBased, count, nodes); return -1; } int32_t tecZoneFaceNbrWriteConnections32( void*          fileHandle, int32_t        zone, int32_t const* faceNeighbors) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneFaceNbrWriteConnections32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneFaceNbrWriteConnections32) .plt format not yet supported\n");
 #endif
else return tecZoneFaceNbrWriteConnections32_SZL(fileInfo->m_typeSpecificData, zone, faceNeighbors); return -1; } EXTERNC tecio_API int32_t tecZoneFaceNbrWriteConnections64( void*          fileHandle, int32_t        zone, int64_t const* faceNeighbors) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneFaceNbrWriteConnections64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneFaceNbrWriteConnections64) .plt format not yet supported\n");
 #endif
else return tecZoneFaceNbrWriteConnections64_SZL(fileInfo->m_typeSpecificData, zone, faceNeighbors); return -1; } int32_t tecZoneWritePolyFaces32( void*          fileHandle, int32_t        zone, int32_t        ___2978, int32_t        numFaces, int32_t const* faceNodeCounts, int32_t const* ___1294, int32_t const* faceLeftElems, int32_t const* faceRightElems, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneWritePolyFaces32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneWritePolyFaces32) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyFaces32_SZL( fileInfo->m_typeSpecificData, zone, ___2978, numFaces, faceNodeCounts, ___1294, faceLeftElems, faceRightElems, isOneBased); return -1; } int32_t tecZoneWritePolyFaces64( void*          fileHandle, int32_t        zone, int32_t        ___2978, int64_t        numFaces, int32_t const* faceNodeCounts, int64_t const* ___1294, int64_t const* faceLeftElems, int64_t const* faceRightElems, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneWritePolyFaces64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneWritePolyFaces64) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyFaces64_SZL( fileInfo->m_typeSpecificData, zone, ___2978, numFaces, faceNodeCounts, ___1294, faceLeftElems, faceRightElems, isOneBased); return -1; } int32_t tecZoneWritePolyBoundaryConnections32( void*          fileHandle, int32_t        zone, int32_t        ___2978, int32_t        numBoundaryFaces, int32_t const* faceBoundaryConnectionCounts, int32_t const* faceBoundaryConnectionElems, int32_t const* faceBoundaryConnectionZones, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneWritePolyBoundaryConnections32) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneWritePolyBoundaryConnections32) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyBoundaryConnections32_SZL( fileInfo->m_typeSpecificData, zone, ___2978, numBoundaryFaces, faceBoundaryConnectionCounts, faceBoundaryConnectionElems, faceBoundaryConnectionZones, isOneBased); return -1; } int32_t tecZoneWritePolyBoundaryConnections64( void*          fileHandle, int32_t        zone, int32_t        ___2978, int64_t        numBoundaryFaces, int32_t const* faceBoundaryConnectionCounts, int64_t const* faceBoundaryConnectionElems, int32_t const* faceBoundaryConnectionZones, int32_t        isOneBased) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneWritePolyBoundaryConnections64) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneWritePolyBoundaryConnections64) .plt format not yet supported\n");
 #endif
else return tecZoneWritePolyBoundaryConnections64_SZL( fileInfo->m_typeSpecificData, zone, ___2978, numBoundaryFaces, faceBoundaryConnectionCounts, faceBoundaryConnectionElems, faceBoundaryConnectionZones, isOneBased); return -1; } int32_t tecDataSetAddAuxData( void*       fileHandle, char const* ___2686, char const* value) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecDataSetAddAuxData) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecDataSetAddAuxData) .plt format not yet supported\n");
 #endif
else return tecDataSetAddAuxData_SZL(fileInfo->m_typeSpecificData, ___2686, value); return -1; } int32_t tecVarAddAuxData( void*       fileHandle, int32_t     ___4336, char const* ___2686, char const* value) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecVarAddAuxData) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecVarAddAuxData) .plt format not yet supported\n");
 #endif
else return tecVarAddAuxData_SZL(fileInfo->m_typeSpecificData, ___4336, ___2686, value); return -1; } int32_t tecZoneAddAuxData( void*       fileHandle, int32_t     zone, char const* ___2686, char const* value) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecZoneAddAuxData) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecZoneAddAuxData) .plt format not yet supported\n");
 #endif
else return tecZoneAddAuxData_SZL(fileInfo->m_typeSpecificData, zone, ___2686, value); return -1; } int32_t tecGeom2DLineSegmentsBegin( void*         fileHandle, double        xOrigin, double        yOrigin, int32_t       numPoints, double const* relativeX, double const* relativeY, int32_t       ___3160) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeom2DLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeom2DLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom2DLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, numPoints, relativeX, relativeY, ___3160); return -1; } int32_t tecGeom2DMultiLineSegmentsBegin( void*          fileHandle, double         xOrigin, double         yOrigin, int32_t        ___2836, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, int32_t        ___3160) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeom2DMultiLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeom2DMultiLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom2DMultiLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, ___2836, numSegmentPoints, relativeX, relativeY, ___3160); return -1; } int32_t tecGeom3DLineSegmentsBegin( void*         fileHandle, double        xOrigin, double        yOrigin, double        zOrigin, int32_t       numPoints, double const* relativeX, double const* relativeY, double const* relativeZ) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeom3DLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeom3DLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom3DLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, zOrigin, numPoints, relativeX, relativeY, relativeZ); return -1; } int32_t tecGeom3DMultiLineSegmentsBegin( void*          fileHandle, double         xOrigin, double         yOrigin, double         zOrigin, int32_t        ___2836, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, double const*  relativeZ) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeom3DMultiLineSegmentsBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeom3DMultiLineSegmentsBegin) .plt format not yet supported\n");
 #endif
else return tecGeom3DMultiLineSegmentsBegin_SZL( fileInfo->m_typeSpecificData, xOrigin, yOrigin, zOrigin, ___2836, numSegmentPoints, relativeX, relativeY, relativeZ); return -1; } int32_t tecGeomCircleBegin( void*   fileHandle, double  xCenter, double  yCenter, double  radius, int32_t ___3160) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomCircleBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomCircleBegin) .plt format not yet supported\n");
 #endif
else return tecGeomCircleBegin_SZL( fileInfo->m_typeSpecificData, xCenter, yCenter, radius, ___3160); return -1; } int32_t tecGeomEllipseBegin( void*   fileHandle, double  xCenter, double  yCenter, double  ___4458, double  ___1825, int32_t ___3160) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomEllipseBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomEllipseBegin) .plt format not yet supported\n");
 #endif
else return tecGeomEllipseBegin_SZL( fileInfo->m_typeSpecificData, xCenter, yCenter, ___4458, ___1825, ___3160); return -1; } int32_t tecGeomRectangleBegin( void*   fileHandle, double  xMin, double  yMin, double  xMax, double  yMax, int32_t ___3160) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomRectangleBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomRectangleBegin) .plt format not yet supported\n");
 #endif
else return tecGeomRectangleBegin_SZL( fileInfo->m_typeSpecificData, xMin, yMin, xMax, yMax, ___3160); return -1; } int32_t tecGeomSquareBegin( void*   fileHandle, double  xMin, double  yMin, double  size, int32_t ___3160) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomSquareBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomSquareBegin) .plt format not yet supported\n");
 #endif
else return tecGeomSquareBegin_SZL( fileInfo->m_typeSpecificData, xMin, yMin, size, ___3160); return -1; } int32_t tecGeomArrowheadSetInfo( void*   fileHandle, double  ___56, int32_t attachment, double  size, int32_t style) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomArrowheadSetInfo) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomArrowheadSetInfo) .plt format not yet supported\n");
 #endif
else return tecGeomArrowheadSetInfo_SZL( fileInfo->m_typeSpecificData, ___56, attachment, size, style); return -1; } int32_t tecGeomEllipseSetNumPoints( void*   fileHandle, int32_t numEllipsePoints) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomSetNumEllipsePoints) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomSetNumEllipsePoints) .plt format not yet supported\n");
 #endif
else return tecGeomEllipseSetNumPoints_SZL(fileInfo->m_typeSpecificData, numEllipsePoints); return -1; } int32_t tecGeomSetClipping( void*   fileHandle, int32_t ___493) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomSetClipping) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomSetClipping) .plt format not yet supported\n");
 #endif
else return tecGeomSetClipping_SZL( fileInfo->m_typeSpecificData, ___493); return -1; } int32_t tecGeomSetLineInfo( void*   fileHandle, int32_t ___2264, double  ___2987, double  thickness, int32_t color) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomSetLineInfo) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomSetLineInfo) .plt format not yet supported\n");
 #endif
else return tecGeomSetLineInfo_SZL( fileInfo->m_typeSpecificData, ___2264, ___2987, thickness, color); return -1; } int32_t tecGeomSetMacroFunctionCmd( void*       fileHandle, char const* macroFunctionCmd) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomSetMacroFunctionCmd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomSetMacroFunctionCmd) .plt format not yet supported\n");
 #endif
else return tecGeomSetMacroFunctionCmd_SZL(fileInfo->m_typeSpecificData, macroFunctionCmd); return -1; } int32_t tecGeomSetScope( void*   fileHandle, int32_t ___3443) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomSetScope) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomSetScope) .plt format not yet supported\n");
 #endif
else return tecGeomSetScope_SZL(fileInfo->m_typeSpecificData, ___3443); return -1; } int32_t tecGeomAttachToZone( void*   fileHandle, int32_t zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomAttachToZone) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomAttachToZone) .plt format not yet supported\n");
 #endif
else return tecGeomAttachToZone_SZL(fileInfo->m_typeSpecificData, zone); return -1; } int32_t tecGeomFill( void*  fileHandle, int32_t ___1409) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomFill) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomFill) .plt format not yet supported\n");
 #endif
else return tecGeomFill_SZL(fileInfo->m_typeSpecificData, ___1409); return -1; } int32_t tecGeomEnd(void* fileHandle) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecGeomEnd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecGeomEnd) .plt format not yet supported\n");
 #endif
else return tecGeomEnd_SZL(fileInfo->m_typeSpecificData); return -1; } int32_t tecCustomLabelsAddSet( void*       fileHandle, char const* ___2172) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecCustomLabelsAddSet) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecCustomLabelsAddSet) .plt format not yet supported\n");
 #endif
else return tecCustomLabelsAddSet_SZL(fileInfo->m_typeSpecificData, ___2172); return -1; } int32_t tecText2DBegin( void*       fileHandle, char const* string, double      x, double      ___4583, int32_t     ___3160, double      ___1825, int32_t     sizeUnits) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecText2DBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecText2DBegin) .plt format not yet supported\n");
 #endif
else return tecText2DBegin_SZL( fileInfo->m_typeSpecificData, string, x, ___4583, ___3160, ___1825, sizeUnits); return -1; } int32_t tecText3DBegin( void*       fileHandle, char const* string, double      x, double      ___4583, double      z, double      ___1825, int32_t     sizeUnits) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecText3DBegin) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecText3DBegin) .plt format not yet supported\n");
 #endif
else return tecText3DBegin_SZL( fileInfo->m_typeSpecificData, string, x, ___4583, z, ___1825, sizeUnits); return -1; } int32_t tecTextAttachToZone( void*   fileHandle, int32_t zone) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextAttachToZone) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextAttachToZone) .plt format not yet supported\n");
 #endif
else return tecTextAttachToZone_SZL(fileInfo->m_typeSpecificData, zone); return -1; } int32_t tecTextBoxSetInfo( void*   fileHandle, int32_t ___410, int32_t lineColor, int32_t ___1409, double  ___2290, double  margin) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextBoxSetInfo) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextBoxSetInfo) .plt format not yet supported\n");
 #endif
else return tecTextBoxSetInfo_SZL( fileInfo->m_typeSpecificData, ___410, lineColor, ___1409, ___2290, margin); return -1; } int32_t tecTextSetAnchor(void* fileHandle, int32_t ___38) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextSetAnchor) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextSetAnchor) .plt format not yet supported\n");
 #endif
else return tecTextSetAnchor_SZL(fileInfo->m_typeSpecificData, ___38); return -1; } int32_t tecTextSetAngle( void*  fileHandle, double ___56) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextSetAngle) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextSetAngle) .plt format not yet supported\n");
 #endif
else return tecTextSetAngle_SZL(fileInfo->m_typeSpecificData, ___56); return -1; } int32_t tecTextSetClipping(void* fileHandle, int32_t ___493) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextSetClipping) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextSetClipping) .plt format not yet supported\n");
 #endif
else return tecTextSetClipping_SZL(fileInfo->m_typeSpecificData, ___493); return -1; } int32_t tecTextSetColor( void*  fileHandle, int32_t color) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextSetColor) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextSetColor) .plt format not yet supported\n");
 #endif
else return tecTextSetColor_SZL(fileInfo->m_typeSpecificData, color); return -1; } int32_t tecTextSetTypeface( void*       fileHandle, char const* family, int32_t     isBold, int32_t     isItalic) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextSetTypeface) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextSetTypeface) .plt format not yet supported\n");
 #endif
else return tecTextSetTypeface_SZL(fileInfo->m_typeSpecificData, family, isBold, isItalic); return -1; } int32_t tecTextSetLineSpacing( void*  fileHandle, double ___2288) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextSetLineSpacing) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextSetLineSpacing) .plt format not yet supported\n");
 #endif
else return tecTextSetLineSpacing_SZL(fileInfo->m_typeSpecificData, ___2288); return -1; } int32_t tecTextSetMacroFunctionCmd( void* fileHandle, char const* macroFunctionCmd) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextSetMacroFunctionCmd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextSetMacroFunctionCmd) .plt format not yet supported\n");
 #endif
else return tecTextSetMacroFunctionCmd_SZL(fileInfo->m_typeSpecificData, macroFunctionCmd); return -1; } int32_t tecTextSetScope( void*   fileHandle, int32_t ___3443) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextSetScope) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextSetScope) .plt format not yet supported\n");
 #endif
else return tecTextSetScope_SZL(fileInfo->m_typeSpecificData, ___3443); return -1; } int32_t tecTextEnd(void* fileHandle) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecTextEnd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecTextEnd) .plt format not yet supported\n");
 #endif
else return tecTextEnd_SZL(fileInfo->m_typeSpecificData); return -1; } int32_t tecUserRecAdd( void*       fileHandle, char const* userRec) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecUserRecAdd) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecUserRecAdd) .plt format not yet supported\n");
 #endif
else return tecUserRecAdd_SZL(fileInfo->m_typeSpecificData, userRec); return -1; } int32_t tecFileWriterFlush( void*          fileHandle, int32_t        numZonesToRetain, int32_t const* zonesToRetain) { FileInfo* fileInfo = (FileInfo*)(fileHandle); if (!fileInfo) ___3185("Err: (tecFileWriterFlush) invalid fileHandle parameter\n");
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) ___3185("Err: (tecFileWriterFlush) .plt format not yet supported\n");
 #endif
else return tecFileWriterFlush_SZL(fileInfo->m_typeSpecificData, numZonesToRetain, zonesToRetain); return -1; } int32_t tecFileWriterClose(void** fileHandle) { FileInfo* fileInfo = NULL; if (fileHandle) fileInfo = (FileInfo*)(*fileHandle); if (!fileInfo) { ___3185("Err: (tecFileWriterClose) invalid fileHandle parameter\n"); }
 #if !defined TECIOMPI
else if (fileInfo->m_fileFormat == FILEFORMAT_PLT) { ___3185("Err: (tecFileWriterClose) .plt format not yet supported\n"); }
 #endif
else { int32_t ___3359 = tecFileWriterClose_SZL(&fileInfo->m_typeSpecificData); delete fileInfo; *fileHandle = NULL; return ___3359; } return -1; } int32_t TECINTERNAL142( const char* command, int64_t*    value) { REQUIRE(VALID_REF(command)); REQUIRE(VALID_REF(value));
 #if !defined TECIOMPI
if (strcmp(command, "GETPOLY32BITFACELIMIT") == 0) { return TECIOPLT_InternalGetPolyFace32BitLimit(value); } else if (strcmp(command, "SETPOLY32BITFACELIMIT") == 0) { return TECIOPLT_InternalSetPolyFace32BitLimit(value); }
 #else
___4279(command); ___4279(value);
 #endif
return -1; } int32_t TECINI142( char const*    ___4178, char const*    ___4350, char const*    ___1392, char const*    ___3448, int32_t const* ___1388, int32_t const* ___1405, int32_t const* ___939, int32_t const* ___2012) { int ___2698 = firstOpenFile(); if (___2698 == -1) { ___3186("Err: (TECINI142) Too many files (%d) opened for writing.\n", ___2698); return (-1); } ___1389[___2698] = *___1388; if (___689 == -1) ___689 = 0; int32_t ___3360;
 #if !defined TECIOMPI
if (___1389[___2698] == FILEFORMAT_PLT) ___3360 = ___3978(___2698, ___4178, ___4350, ___1392, ___3448, ___1405, ___939, ___2012); else
 #endif
___3360 = ___4000(___2698, ___4178, ___4350, ___1392, ___3448, ___1405, ___939, ___2012); if (___3360 >= 0) ___2041[___2698] = 1; return ___3360; } int32_t TECINI112( char const*     ___4178, char const*     ___4350, char const*     ___1392, char const*     ___3448, int32_t const* ___1405, int32_t const* ___939, int32_t const* ___2012) { return TECINI142(___4178, ___4350, ___1392, ___3448, &FILEFORMAT_PLT, ___1405, ___939, ___2012); } int32_t TECINI111( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___1406, int32_t const* ___940, int32_t const* ___4439) { return TECINI142(___4179, ___4351, ___1437, ___3449, &FILEFORMAT_PLT, ___1406, ___940, ___4439); } int32_t TECINI110( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___940, int32_t const* ___4439) { int32_t ___1532 = ___1533; return TECINI142(___4179, ___4351, ___1437, ___3449, &FILEFORMAT_PLT, &___1532, ___940, ___4439); } int32_t TECINI100( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___940, int32_t const* ___4439) { int32_t ___1532 = ___1533; return TECINI142(___4179, ___4351, ___1437, ___3449, &FILEFORMAT_PLT, &___1532, ___940, ___4439); } int32_t TECINI( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___940, int32_t const* ___4439) { int32_t ___1532 = ___1533; return TECINI142(___4179, ___4351, ___1437, ___3449, &FILEFORMAT_PLT, &___1532, ___940, ___4439); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecini142_( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___1389, int32_t const* ___1406, int32_t const* ___940, int32_t const* ___4439) { return TECINI142(___4179, ___4351, ___1437, ___3449, ___1389, ___1406, ___940, ___4439); } EXTERNC tecio_API int32_t tecini112_( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___1406, int32_t const* ___940, int32_t const* ___4439) { return TECINI142(___4179, ___4351, ___1437, ___3449, &FILEFORMAT_PLT, ___1406, ___940, ___4439); } EXTERNC tecio_API int32_t tecini111_( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___1406, int32_t const* ___940, int32_t const* ___4439) { return TECINI142(___4179, ___4351, ___1437, ___3449, &FILEFORMAT_PLT, ___1406, ___940, ___4439); } EXTERNC tecio_API int32_t tecini110_( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___940, int32_t const* ___4439) { int32_t ___1532 = ___1533; return TECINI142(___4179, ___4351, ___1437, ___3449, &FILEFORMAT_PLT, &___1532, ___940, ___4439); } EXTERNC tecio_API int32_t tecini100_( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___940, int32_t const* ___4439) { int32_t ___1532 = ___1533; return TECINI142(___4179, ___4351, ___1437, ___3449, &FILEFORMAT_PLT, &___1532, ___940, ___4439); } EXTERNC tecio_API int32_t tecini_( char const*     ___4179, char const*     ___4351, char const*     ___1437, char const*     ___3449, int32_t const* ___940, int32_t const* ___4439) { int32_t ___1532 = ___1533; return TECINI142(___4179, ___4351, ___1437, ___3449, &FILEFORMAT_PLT, &___1532, ___940, ___4439); }
 #endif
int32_t TECZNEFEMIXED142( char    const* ___4691, int64_t const* NumNodes, int32_t const* NumSections, int32_t const* CellShapePerSection, int32_t const* GridOrderPerSection, int32_t const* BasisFnPerSection, int64_t const* NumElementsPerSection, double  const* ___3642, int32_t const* ___3787, int32_t const* ___2804, int32_t const* ___1283, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3185("Err: (TECZNEFEMIXED142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
{ int32_t const FEMixedZoneType = FEMIXED; int64_t const ___2161 = 0; int32_t const ___2005 = 1; int64_t const NumElements = std::accumulate(NumElementsPerSection,NumElementsPerSection+(*NumSections), int64_t(0)); return ___4015( ___689, ___4691, &FEMixedZoneType, NumNodes, &NumElements, &___2161, *NumSections, CellShapePerSection, GridOrderPerSection, BasisFnPerSection, NumElementsPerSection, ___3642, ___3787, NULL  , &___2005, ___2804, ___1283, NULL, NULL, NULL, ___2984, ___4327, ___3553, ___3551); } } int32_t TECFEMIXEDPTN142( int32_t const* ___2978, int64_t const* ___2822, int64_t const* numCellsPerSection, int64_t const* numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int32_t const* ghostCells) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3185("Err: (TECFEMIXEDPTN142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
{ return TECIOSZL_FEMIXEDPTN( ___689, ___2978, ___2822, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); } } int32_t TECZNE142( char const*    ___4691, int32_t const* ___4693, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2161, int32_t const* , int32_t const* , int32_t const* , double const*  ___3642, int32_t const* ___3787, int32_t const* ___2976, int32_t const* ___2005, int32_t const* ___2804, int32_t const* ___1283, int32_t const* ___4194, int32_t const* ___2788, int32_t const* ___4190, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { int64_t const KMxOrNumFaces64 = ___2161 ? *___2161 : 0; int64_t const TotalNumFaceNodes64 = ___4194 ? *___4194 : 0; return ___3993( "TECZNE142", ___689, ___4691, ___4693, ___1909, ___2116, (___2161 ? &KMxOrNumFaces64 : NULL), ___3642, ___3787, ___2976, ___2005, ___2804, ___1283, (___4194 ? &TotalNumFaceNodes64 : NULL), ___2788, ___4190, ___2984, ___4327, ___3553, ___3551); } else
 #endif
{ int64_t const IMxOrNumPts64      = *___1909; int64_t const JMxOrNumElements64 = *___2116; int64_t const KMxOrNumFaces64    = ___2161 ? *___2161 : 0; return ___4015( ___689, ___4691, ___4693, &IMxOrNumPts64, &JMxOrNumElements64, &KMxOrNumFaces64, 0, NULL, NULL, NULL, NULL, ___3642, ___3787, ___2976, ___2005, ___2804, ___1283, ___4194, ___2788, ___4190, ___2984, ___4327, ___3553, ___3551); } } int32_t TECPOLYZNE142( char const*     ___4691, INTEGER4 const* ___4693, INTEGER4 const* NumNodes, INTEGER4 const* NumCells, INTEGER8 const* ___2807, INTEGER8 const* ___4194, double const*   ___3642, INTEGER4 const* ___3787, INTEGER4 const* ___2976, INTEGER4 const* ___2788, INTEGER4 const* ___4190, INTEGER4 const* ___2984, INTEGER4 const* ___4327, INTEGER4 const* ___3553, INTEGER4 const* ___3551) { INTEGER4 const ___2005 = 1; INTEGER4 const ___1283 = 0; INTEGER4 const ___2804 = 0;
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3993( "TECPOLYZNE142", ___689, ___4691, ___4693, NumNodes, NumCells, ___2807, ___3642, ___3787, ___2976, &___2005, &___2804, &___1283, ___4194, ___2788, ___4190, ___2984, ___4327, ___3553, ___3551); else
 #endif
{ INTEGER8 const NumNodes64 = *NumNodes; INTEGER8 const NumCells64 = *NumCells; INTEGER8 const NumFaces64 = (___2807 ? INTEGER8(*___2807) : 0); INTEGER4 const TotalNumFaceNodes32 = (___4194 ? INTEGER4(*___4194) : 0); return ___4015( ___689, ___4691, ___4693, &NumNodes64, &NumCells64, (___2807 ? &NumFaces64 : NULL), 0, NULL, NULL, NULL, NULL, ___3642, ___3787, ___2976, &___2005, &___2804, &___1283, (___4194 ? &TotalNumFaceNodes32 : NULL), ___2788, ___4190, ___2984, ___4327, ___3553, ___3551); } }
 #if defined ___1232
EXTERNC tecio_API int32_t tecpolyzne142_( char const*     ___4691, INTEGER4 const* ___4693, INTEGER4 const* NumNodes, INTEGER4 const* NumCells, INTEGER8 const* ___2807, INTEGER8 const* ___4194, double const*   ___3642, INTEGER4 const* ___3787, INTEGER4 const* ___2976, INTEGER4 const* ___2788, INTEGER4 const* ___4190, INTEGER4 const* ___2984, INTEGER4 const* ___4327, INTEGER4 const* ___3553, INTEGER4 const* ___3551) { return TECPOLYZNE142(___4691, ___4693, NumNodes, NumCells, ___2807, ___4194, ___3642, ___3787, ___2976, ___2788, ___4190, ___2984, ___4327, ___3553, ___3551); }
 #endif
int32_t TECZNE112( char const*     ___4598, int32_t const* ___4599, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2161, int32_t const* ___1835, int32_t const* ___2108, int32_t const* ___2137, double const*   ___3642, int32_t const* ___3787, int32_t const* ___2976, int32_t const* ___2004, int32_t const* ___2802, int32_t const* ___1438, int32_t const* ___2806, int32_t const* ___2800, int32_t const* ___2799, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { return TECZNE142(___4598, ___4599, ___1909, ___2116, ___2161, ___1835, ___2108, ___2137, ___3642, ___3787, ___2976, ___2004, ___2802, ___1438, ___2806, ___2800, ___2799, ___2984, ___4327, ___3553, ___3551); } int32_t TECZNE111( char const*     ___4598, int32_t const* ___4599, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2161, int32_t const* ___1835, int32_t const* ___2108, int32_t const* ___2137, double const*   ___3642, int32_t const* ___3787, int32_t const* ___2976, int32_t const* ___2004, int32_t const* ___2802, int32_t const* ___1438, int32_t const* ___2806, int32_t const* ___2800, int32_t const* ___2799, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { return TECZNE142(___4598, ___4599, ___1909, ___2116, ___2161, ___1835, ___2108, ___2137, ___3642, ___3787, ___2976, ___2004, ___2802, ___1438, ___2806, ___2800, ___2799, ___2984, ___4327, ___3553, ___3551); } int32_t TECZNE110( char const*     ___4598, int32_t const* ___4599, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2159, int32_t const* ___1835, int32_t const* ___2108, int32_t const* ___2137, double const*   ___3642, int32_t const* ___3787, int32_t const* ___2976, int32_t const* ___2004, int32_t const* ___2802, int32_t const* ___1438, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { int32_t ___2806      = 0; int32_t ___2800 = 0; int32_t ___2799 = 0; return TECZNE142(___4598, ___4599, ___1909, ___2116, ___2159, ___1835, ___2108, ___2137, ___3642, ___3787, ___2976, ___2004, ___2802, ___1438, &___2806, &___2800, &___2799, ___2984, ___4327, ___3553, ___3551); } int32_t TECZNE100( char const*     ___4598, int32_t const* ___4599, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2159, int32_t const* ___1835, int32_t const* ___2108, int32_t const* ___2137, int32_t const* ___2004, int32_t const* ___2802,
int32_t const* ___1438, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { double   ___3642 = 0.0; int32_t ___3787   = ___3789 + 1; int32_t ___2976 = ___333 + 1; int32_t ___2806      = 0; int32_t ___2800 = 0; int32_t ___2799 = 0; return TECZNE142(___4598, ___4599, ___1909, ___2116, ___2159, ___1835, ___2108, ___2137, &___3642, &___3787, &___2976, ___2004, ___2802, ___1438, &___2806, &___2800, &___2799, NULL, ___4327, ___3553, ___3551); }
 #if !defined INDEX_16_BIT 
namespace { ___372 ___2977( ___1170** ___3553, ___1170*  ___3551, char const* ___1132) { ___372 ___2039 = ___4227; REQUIRE(VALID_REF(___3553) && *___3553 == NULL); REQUIRE(VALID_REF(___3551)); REQUIRE(VALID_REF(___1132)); ___1170 ___2849; ___1170 ___2845;
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___2849 = ___3983(___689); ___2845  = ___3982(___689); } else
 #endif
{ ___2849 = ___4005(___689); ___2845  = ___4004(___689); } while (___2039 && *___1132) { while (*___1132 && *___1132 == ' ') ___1132++; if (*___1132 && !strncmp(___1132, "FECONNECT", 9)) { *___3551 = ___2849; } else if (*___1132 && !tecplot::___2011(*___1132)) { ___2039 = ___1303; } else if (*___1132) { char *___2757 = NULL; ___1170 ___4454 = strtol(___1132, &___2757, 10); if (0 < ___4454 && ___4454 < ___2845) { if (!(*___3553)) { *___3553 = ___23(___2845, ___1170, "Variable sharing list"); if (*___3553) memset(*___3553, (char)0, ___2845 * sizeof(___1170)); } if (*___3553) (*___3553)[___4454 - 1] = ___2849; else ___2039 = ___1303; } else { ___2039 = ___1303; } } while (*___1132 && *___1132 != ',') ___1132++; while (*___1132 && *___1132 == ',') ___1132++; } return ___2039; } }
 #endif
 #if !defined INDEX_16_BIT 
int32_t TECZNE( char const*     ___4691, int32_t const* ___1907, int32_t const* ___2114, int32_t const* ___2159, char const*     ___4596, char const*     ___1132) { int32_t    ___4693; int32_t    ___2005; int32_t   *___3553 = NULL; int32_t    ___3551; int32_t    ___3360 = 0; if (___4596 == NULL) ___3360 = -1; else if (!strcmp(___4596, "BLOCK")) { ___2005 = 1; ___4693 = ___4704; } else if (!strcmp(___4596, "FEBLOCK")) { ___2005 = 1; switch (*___2159) { case 0: ___4693 = 2; break; case 1: ___4693 = 3; break; case 2: ___4693 = 4; break; case 3: ___4693 = 5; break; } } else if (!strcmp(___4596, "POINT")) { ___2005 = 0; ___4693 = ___4704; } else if (!strcmp(___4596, "FEPOINT")) { ___2005 = 0; switch (*___2159) { case 0: ___4693 = 2; break; case 1: ___4693 = 3; break; case 2: ___4693 = 4; break; case 3: ___4693 = 5; break; } } else ___3360 = -1; ___3551 = 0; if (___3360 == 0 && ___1132 && !___2977(&___3553, &___3551, ___1132)) { ___3360 = -1; } if (___3360 == 0) { int32_t ___1835 = 0; int32_t ___2108 = 0; int32_t ___2137 = 0; int32_t ___2804 = 0; int32_t ___1283   = ___1288; double   ___3642 = 0.0; int32_t ___3787   = ___3789 + 1; int32_t ___2976 = ___333 + 1; int32_t ___2806      = 0; int32_t ___2800 = 0; int32_t ___2799 = 0; ___3360 = TECZNE142((char *)___4691, &___4693, ___1907, ___2114, ___2159, &___1835, &___2108, &___2137, &___3642, &___3787, &___2976, &___2005, &___2804, &___1283, &___2806, &___2800, &___2799, NULL, NULL, ___1132 ? ___3553 : NULL, &___3551); } if (___3553) ___1528(___3553, "Variable sharing list"); return (int32_t) ___3360; }
 #endif 
 #if defined ___1232
EXTERNC tecio_API int32_t TECZNEFEMIXED142_( char    const* ___4691, int64_t const* NumNodes, int32_t const* NumSections, int32_t const* CellShapePerSection, int32_t const* GridOrderPerSection, int32_t const* BasisFnPerSection, int64_t const* NumElementsPerSection, double  const* ___3642, int32_t const* ___3787, int32_t const* ___2804, int32_t const* ___1283, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { return TECZNEFEMIXED142( ___4691, NumNodes, NumSections, CellShapePerSection, GridOrderPerSection, BasisFnPerSection, NumElementsPerSection, ___3642, ___3787, ___2804, ___1283, ___2984, ___4327, ___3553, ___3551); } EXTERNC tecio_API int32_t TECFEMIXEDPTN142_( int32_t const* ___2978, int64_t const* ___2822, int64_t const* numCellsPerSection, int64_t const* numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t const* numGhostCellsPerSection, int32_t const* ghostCells) { return TECFEMIXEDPTN142( ___2978, ___2822, numCellsPerSection, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCellsPerSection, ghostCells); } EXTERNC tecio_API int32_t teczne142_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2159, int32_t const* ___1835, int32_t const* ___2108, int32_t const* ___2137, double const*   ___3642, int32_t const* ___3787, int32_t const* ___2976, int32_t const* ___2004, int32_t const* ___2802, int32_t const* ___1438, int32_t const* ___2806, int32_t const* ___2800, int32_t const* ___2799, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { return TECZNE142(___4691, ___4599, ___1909, ___2116, ___2159, ___1835, ___2108, ___2137, ___3642, ___3787, ___2976, ___2004, ___2802, ___1438, ___2806, ___2800, ___2799, ___2984, ___4327, ___3553, ___3551); } EXTERNC tecio_API int32_t teczne112_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2159, int32_t const* ___1835, int32_t const* ___2108, int32_t const* ___2137, double const*   ___3642, int32_t const* ___3787, int32_t const* ___2976, int32_t const* ___2004, int32_t const* ___2802, int32_t const* ___1438, int32_t const* ___2806, int32_t const* ___2800, int32_t const* ___2799, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { return TECZNE142(___4691, ___4599, ___1909, ___2116, ___2159, ___1835, ___2108, ___2137, ___3642, ___3787, ___2976, ___2004, ___2802, ___1438,
___2806, ___2800, ___2799, ___2984, ___4327, ___3553, ___3551); } EXTERNC tecio_API int32_t teczne111_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2159, int32_t const* ___1835, int32_t const* ___2108, int32_t const* ___2137, double const*   ___3642, int32_t const* ___3787, int32_t const* ___2976, int32_t const* ___2004, int32_t const* ___2802, int32_t const* ___1438, int32_t const* ___2806, int32_t const* ___2800, int32_t const* ___2799, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { return TECZNE142(___4691, ___4599, ___1909, ___2116, ___2159, ___1835, ___2108, ___2137, ___3642, ___3787, ___2976, ___2004, ___2802, ___1438, ___2806, ___2800, ___2799, ___2984, ___4327, ___3553, ___3551); } EXTERNC tecio_API int32_t teczne110_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2159, int32_t const* ___1835, int32_t const* ___2108, int32_t const* ___2137, double const*   ___3642, int32_t const* ___3787, int32_t const* ___2976, int32_t const* ___2004, int32_t const* ___2802, int32_t const* ___1438, int32_t const* ___2984, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { int32_t ___2806      = 0; int32_t ___2800 = 0; int32_t ___2799 = 0; return TECZNE142(___4691, ___4599, ___1909, ___2116, ___2159, ___1835, ___2108, ___2137, ___3642, ___3787, ___2976, ___2004, ___2802, ___1438, &___2806, &___2800, &___2799, ___2984, ___4327, ___3553, ___3551); } EXTERNC tecio_API int32_t teczne100_( char const*     ___4691, int32_t const* ___4599, int32_t const* ___1909, int32_t const* ___2116, int32_t const* ___2159, int32_t const* ___1835, int32_t const* ___2108, int32_t const* ___2137, int32_t const* ___2004, int32_t const* ___2802, int32_t const* ___1438, int32_t const* ___4327, int32_t const* ___3553, int32_t const* ___3551) { return TECZNE100(___4691, ___4599, ___1909, ___2116, ___2159, ___1835, ___2108, ___2137, ___2004, ___2802, ___1438, ___4327, ___3553, ___3551); } EXTERNC tecio_API int32_t teczne_( char const*     ___4691, int32_t const* ___1907, int32_t const* ___2114, int32_t const* ___2159, char const*     ___4596, char const*     ___1132) { return TECZNE(___4691, ___1907, ___2114, ___2159, ___4596, ___1132); }
 #endif
int32_t TECDAT142( int32_t const* N, void const*     ___1350, int32_t const* ___2013) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3973(___689, N, ___1350, ___2013); else
 #endif
return ___3995(___689, N, ___1350, ___2013); } int32_t TECDATD142( int32_t const* N, double const*  ___1350) { int32_t ___2012 = 1; return TECDAT142(N, ___1350, &___2012); } int32_t TECDATF142( int32_t const* N, float const*   ___1350) { int32_t ___2012 = 0; return TECDAT142(N, ___1350, &___2012); } int32_t TECDAT112( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); } int32_t TECDAT111( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); } int32_t TECDAT110( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); } int32_t TECDAT100( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); } int32_t TECDAT( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecdat142_( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); } EXTERNC tecio_API int32_t tecdatd142_( int32_t const* N, double const*  ___1350) { return TECDATD142(N, ___1350); } EXTERNC tecio_API int32_t tecdatf142_( int32_t const* N, float const*   ___1350) { return TECDATF142(N, ___1350); } EXTERNC tecio_API int32_t tecdat112_( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); } EXTERNC tecio_API int32_t tecdat111_( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); } EXTERNC tecio_API int32_t tecdat110_( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); } EXTERNC tecio_API int32_t tecdat100_( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); } EXTERNC tecio_API int32_t tecdat_( int32_t const* N, void const*     ___1350, int32_t const* ___2013) { return TECDAT142(N, ___1350, ___2013); }
 #endif
int32_t TECNOD142(int32_t const* ___2690) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3980(___689, ___2690); else
 #endif
return ___4002(___689, ___2690); } int32_t TECNOD112(int32_t const* ___2690) { return TECNOD142(___2690); } int32_t TECNOD111(int32_t const* ___2690) { return TECNOD142(___2690); } int32_t TECNOD110(int32_t const* ___2690) { return TECNOD142(___2690); } int32_t TECNOD100(int32_t const* ___2690) { return TECNOD142(___2690); } int32_t TECNOD(int32_t const* ___2690) { return TECNOD142(___2690); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecnod142_(int32_t const* ___2690) { return TECNOD142(___2690); } EXTERNC tecio_API int32_t tecnod112_(int32_t const* ___2690) { return TECNOD142(___2690); } EXTERNC tecio_API int32_t tecnod111_(int32_t const* ___2690) { return TECNOD142(___2690); } EXTERNC tecio_API int32_t tecnod110_(int32_t const* ___2690) { return TECNOD142(___2690); } EXTERNC tecio_API int32_t tecnod100_(int32_t const* ___2690) { return TECNOD142(___2690); } EXTERNC tecio_API int32_t tecnod_(int32_t const* ___2690) { return TECNOD142(___2690); }
 #endif
int32_t TECNODE142( int32_t const* N, int32_t const* ___2690) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3981(___689, N, ___2690); else
 #endif
return ___4003(___689, N, ___2690); } int32_t TECNODE112( int32_t const* N, int32_t const* ___2690) { return TECNODE142(N, ___2690); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecnode142_( int32_t const* N, int32_t const* ___2690) { return TECNODE142(N, ___2690); } EXTERNC tecio_API int32_t tecnode112_( int32_t const* N, int32_t const* ___2690) { return TECNODE142(N, ___2690); }
 #endif
int32_t TECFLUSH142( int32_t const* numZonesToRetain, int32_t const* zonesToRetain) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3185("Err: TECFLUSH does not yet support .plt format\n"); return -1; } else
 #endif
return TECIOSZL_FLUSH(___689, numZonesToRetain, zonesToRetain); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecflush142_( int32_t const* numZonesToRetain, int32_t const* zonesToRetain) { return TECFLUSH142(numZonesToRetain, zonesToRetain); }
 #endif
int32_t TECEND142(void) { int32_t ___3360;
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) ___3360 = ___3974(___689); else
 #endif
___3360 = ___3996(___689); ___2041[___689] = 0; ___689 = 0; while ((___689 < ___2381) && !___2041[___689]) ___689++; if (___689 == ___2381) ___689 = -1; return ___3360; } int32_t TECEND112(void) { return TECEND142(); } int32_t TECEND111(void) { return TECEND142(); } int32_t TECEND110(void) { return TECEND142(); } int32_t TECEND100(void) { return TECEND142(); } int32_t TECEND(void) { return TECEND142(); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecend142_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend112_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend111_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend110_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend100_(void) { return TECEND142(); } EXTERNC tecio_API int32_t tecend_(void) { return TECEND142(); }
 #endif
int32_t TECLAB142(char const* S) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3979(___689, S); else
 #endif
return ___4001(___689, S); } int32_t TECLAB112(char const* S) { return TECLAB142(S); } int32_t TECLAB111(char const* S) { return TECLAB142(S); } int32_t TECLAB110(char const* S) { return TECLAB142(S); } int32_t TECLAB100(char const* S) { return TECLAB142(S); } int32_t TECLAB(char const* S) { return TECLAB142(S); }
 #if defined ___1232
EXTERNC tecio_API int32_t teclab142_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab112_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab111_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab110_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab100_(char const* S) { return TECLAB142(S); } EXTERNC tecio_API int32_t teclab_(char const* S) { return TECLAB142(S); }
 #endif
int32_t TECUSR142(char const* S) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3990(___689, S); else
 #endif
return ___4012(___689, S); } int32_t TECUSR112(char const* S) { return TECUSR142(S); } int32_t TECUSR111(char const* S) { return TECUSR142(S); } int32_t TECUSR110(char const* S) { return TECUSR142(S); } int32_t TECUSR100(char const* S) { return TECUSR142(S); } int32_t TECUSR(char const* S) { return TECUSR142(S); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecusr142_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr112_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr111_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr110_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr100_(char const* S) { return TECUSR142(S); } EXTERNC tecio_API int32_t tecusr_(char const* S) { return TECUSR142(S); }
 #endif
int32_t TECGEO142( double const*  ___4575, double const*  ___4592, double const*  ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*  ___2988, double const*  ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*  ___187, double const*  ___171, int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*   ___4573, float const*   ___4590, float const*   ___4597, char const*    mfc) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3977(___689, ___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); else
 #endif
return ___3999(___689, ___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } int32_t TECGEO112( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } int32_t TECGEO111( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } int32_t TECGEO110( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171,
int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } int32_t TECGEO100( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } int32_t TECGEO( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { int ___494 = (int)___496; return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, &___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecgeo142_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t tecgeo112_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t tecgeo111_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410,
___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t tecgeo110_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t tecgeo100_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___494, int32_t const* ___2837, int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO142(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___494, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); } EXTERNC tecio_API int32_t tecgeo_( double const*   ___4575, double const*   ___4592, double const*   ___4716, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* Color, int32_t const* ___1410, int32_t const* ___2022, int32_t const* ___1651, int32_t const* ___2265, double const*   ___2988, double const*   ___2291, int32_t const* ___2795, int32_t const* ___188, int32_t const* ___176, double const*   ___187, double const*   ___171, int32_t const* ___3444, int32_t const* ___2837,
int32_t const* ___2839, float const*    ___4573, float const*    ___4590, float const*    ___4597, char const*     mfc) { return TECGEO(___4575, ___4592, ___4716, ___3161, ___227, ___4600, Color, ___1410, ___2022, ___1651, ___2265, ___2988, ___2291, ___2795, ___188, ___176, ___187, ___171, ___3444, ___2837, ___2839, ___4573, ___4590, ___4597, mfc); }
 #endif
int32_t TECTXT142( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3989(___689, ___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); else
 #endif
return ___4011(___689, ___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } int32_t TECTXT112( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } int32_t TECTXT111( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } int32_t TECTXT110( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } int32_t TECTXT100( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600,
int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } int32_t TECTXT( double const*   ___4576, double const*   ___4593, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, char const*     Text, char const*     mfc) { double    ___4716     = 0.0; int       ___494 = (int)___496; return TECTXT142(___4576, ___4593, &___4716, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, &___494, Text, mfc); }
 #if defined ___1232
EXTERNC tecio_API int32_t tectxt142_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } EXTERNC tecio_API int32_t tectxt112_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } EXTERNC tecio_API int32_t tectxt111_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } EXTERNC tecio_API int32_t tectxt110_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403,
int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } EXTERNC tecio_API int32_t tectxt100_( double const*   ___4575, double const*   ___4592, double const*   ___4714, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, int32_t const* ___494, char const*     ___3814, char const*     mfc) { return TECTXT142(___4575, ___4592, ___4714, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, ___494, ___3814, mfc); } EXTERNC tecio_API int32_t tectxt_( double const*   ___4576, double const*   ___4593, int32_t const* ___3161, int32_t const* ___227, int32_t const* ___4600, int32_t const* ___353, int32_t const* ___1451, double const*   ___1449, int32_t const* ___411, double const*   ___409, double const*   ___407, int32_t const* ___403, int32_t const* ___405, double const*   ___57, int32_t const* ___39, double const*   ___2289, int32_t const* ___4082, int32_t const* ___3444, char const*     Text, char const*     mfc) { return TECTXT(___4576, ___4593, ___3161, ___227, ___4600, ___353, ___1451, ___1449, ___411, ___409, ___407, ___403, ___405, ___57, ___39, ___2289, ___4082, ___3444, Text, mfc); }
 #endif
int32_t TECFIL142(int32_t const* F) { if ((*F < 1) || (*F > ___2381)) { ___3187("Err: (TECFIL142) Invalid file %d. Number must be between 1 and %d.\n", *F, ___2381); return (-1); } if (!___2041[*F-1]) { ___3186("Err: (TECFIL142) Invalid file %d. File must first be opened with TECINI.\n", *F); return (-1); } ___689 = *F-1; return 0; } int32_t TECFIL112(int32_t const* F) { return TECFIL142(F); } int32_t TECFIL111(int32_t const* F) { return TECFIL142(F); } int32_t TECFIL110(int32_t const* F) { return TECFIL142(F); } int32_t TECFIL100(int32_t const* F) { return TECFIL142(F); } int32_t TECFIL(int32_t const* F) { return TECFIL142(F); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecfil142_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil112_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil111_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil110_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil100_(int32_t const* F) { return TECFIL142(F); } EXTERNC tecio_API int32_t tecfil_(int32_t const* F) { return TECFIL142(F); }
 #endif
void TECFOREIGN142(int32_t const* ___2892) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) ___3976(___689, ___2892); else
 #endif
___3998(___689, ___2892); } void TECFOREIGN112(int32_t const* ___2892) { TECFOREIGN142(___2892); } void TECFOREIGN111(int32_t const* ___2892) { TECFOREIGN142(___2892); } void TECFOREIGN110(int32_t const* ___2892) { TECFOREIGN142(___2892); } void TECFOREIGN100(int32_t const* ___2892) { TECFOREIGN142(___2892); }
 #if defined ___1232
EXTERNC tecio_API void tecforeign142_(int32_t const* ___2892) { TECFOREIGN142(___2892); } EXTERNC tecio_API void tecforeign112_(int32_t const* ___2892) { TECFOREIGN142(___2892); } EXTERNC tecio_API void tecforeign111_(int32_t const* ___2892) { TECFOREIGN142(___2892); } EXTERNC tecio_API void tecforeign110_(int32_t const* ___2892) { TECFOREIGN142(___2892); } EXTERNC tecio_API void tecforeign100_(int32_t const* ___2892) { TECFOREIGN142(___2892); }
 #endif
int32_t TECAUXSTR142( char const* ___2687, char const* ___4315) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3972(___689, ___2687, ___4315); else
 #endif
return ___3994(___689, ___2687, ___4315); } int32_t TECAUXSTR112( char const* ___2687, char const* ___4315) { return TECAUXSTR142(___2687, ___4315); } int32_t TECAUXSTR111( char const* ___2687, char const* ___4315) { return TECAUXSTR142(___2687, ___4315); } int32_t TECAUXSTR110( char const* ___2687, char const* ___4315) { return TECAUXSTR142(___2687, ___4315); } int32_t TECAUXSTR100( char const* ___2687, char const* ___4315) { return TECAUXSTR142(___2687, ___4315); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecauxstr142_( char const* ___2687, char const* ___4315) { return TECAUXSTR142(___2687, ___4315); } EXTERNC tecio_API int32_t tecauxstr112_( char const* ___2687, char const* ___4315) { return TECAUXSTR142(___2687, ___4315); } EXTERNC tecio_API int32_t tecauxstr111_( char const* ___2687, char const* ___4315) { return TECAUXSTR142(___2687, ___4315); } EXTERNC tecio_API int32_t tecauxstr110_( char const* ___2687, char const* ___4315) { return TECAUXSTR142(___2687, ___4315); } EXTERNC tecio_API int32_t tecauxstr100_( char const* ___2687, char const* ___4315) { return TECAUXSTR142(___2687, ___4315); }
 #endif
int32_t TECZAUXSTR142( char const* ___2687, char const* ___4315) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3992(___689, ___2687, ___4315); else
 #endif
return ___4014(___689, ___2687, ___4315); } int32_t TECZAUXSTR112( char const* ___2687, char const* ___4315) { return TECZAUXSTR142(___2687, ___4315); } int32_t TECZAUXSTR111( char const* ___2687, char const* ___4315) { return TECZAUXSTR142(___2687, ___4315); } int32_t TECZAUXSTR110( char const* ___2687, char const* ___4315) { return TECZAUXSTR142(___2687, ___4315); } int32_t TECZAUXSTR100( char const* ___2687, char const* ___4315) { return TECZAUXSTR142(___2687, ___4315); }
 #if defined ___1232
EXTERNC tecio_API int32_t teczauxstr142_( char const* ___2687, char const* ___4315) { return TECZAUXSTR142(___2687, ___4315); } EXTERNC tecio_API int32_t teczauxstr112_( char const* ___2687, char const* ___4315) { return TECZAUXSTR142(___2687, ___4315); } EXTERNC tecio_API int32_t teczauxstr111_( char const* ___2687, char const* ___4315) { return TECZAUXSTR142(___2687, ___4315); } EXTERNC tecio_API int32_t teczauxstr110_( char const* ___2687, char const* ___4315) { return TECZAUXSTR142(___2687, ___4315); } EXTERNC tecio_API int32_t teczauxstr100_( char const* ___2687, char const* ___4315) { return TECZAUXSTR142(___2687, ___4315); }
 #endif
int32_t TECVAUXSTR142( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3991(___689, ___4337, ___2687, ___4315); else
 #endif
return ___4013(___689, ___4337, ___2687, ___4315); } int32_t TECVAUXSTR112( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2687, ___4315); } int32_t TECVAUXSTR111( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2687, ___4315); } int32_t TECVAUXSTR110( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2687, ___4315); } int32_t TECVAUXSTR100( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2687, ___4315); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecvauxstr142_( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2687, ___4315); } EXTERNC tecio_API int32_t tecvauxstr112_( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2687, ___4315); } EXTERNC tecio_API int32_t tecvauxstr111_( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2687, ___4315); } EXTERNC tecio_API int32_t tecvauxstr110_( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2687, ___4315); } EXTERNC tecio_API int32_t tecvauxstr100_( int32_t const* ___4337, char const*     ___2687, char const*     ___4315) { return TECVAUXSTR142(___4337, ___2687, ___4315); }
 #endif
int32_t TECFACE142(int32_t const* ___1256) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3975(___689, ___1256); else
 #endif
return ___3997(___689, ___1256); } int32_t TECFACE112(int32_t const* ___1256) { return TECFACE142(___1256); } int32_t TECFACE111(int32_t const* ___1256) { return TECFACE142(___1256); } int32_t TECFACE110(int32_t const* ___1256) { return TECFACE142(___1256); } int32_t TECFACE100(int32_t const* ___1256) { return TECFACE142(___1256); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecface142_(int32_t const* ___1256) { return TECFACE142(___1256); } EXTERNC tecio_API int32_t tecface112_(int32_t const* ___1256) { return TECFACE142(___1256); } EXTERNC tecio_API int32_t tecface111_(int32_t const* ___1256) { return TECFACE142(___1256); } EXTERNC tecio_API int32_t tecface110_(int32_t const* ___1256) { return TECFACE142(___1256); } EXTERNC tecio_API int32_t tecface100_(int32_t const* ___1256) { return TECFACE142(___1256); }
 #endif
int32_t TECPOLY142( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3984(___689, ___1292, ___1295, ___1257, ___1301, ___1251, ___1252, ___1254); else
 #endif
return ___4006(___689, ___1292, ___1295, ___1257, ___1301, ___1251, ___1252, ___1254); } int32_t TECPOLY112( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLY142(___1292, ___1295, ___1257, ___1301, ___1251, ___1252, ___1254); } int32_t TECPOLY111( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1251, int32_t const* ___1252, int16_t const* ___1254) { int32_t    ___3360 = 0; ___1170 *___1305 = NULL; int32_t ___4191; int32_t ___4192;
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___4191 = ___3987(___689); ___4192 = ___3988(___689); } else
 #endif
{ ___4191 = ___4009(___689); ___4192 = ___4010(___689); } if (___4191 > 0) { ___23(___4191, ___1170, "32-bit FaceBndryConnectionZones"); if (___1305 != NULL) { for (___2226 face = 0; face < ___4192; face++) ___1305[face] = (___1170)___1254[face]; } else { ___3185("Err: (TECPOLY111) Out of memory allocating temporary data.\n"); return (-1); } } ___3360 = TECPOLY142(___1292, ___1295, ___1257, ___1301, ___1251, ___1252, ___1305); if (___1305 != NULL) ___1528(___1305, "32-bit FaceBndryConnectionZones"); return ___3360; }
 #if defined ___1232
EXTERNC tecio_API int32_t tecpoly142_( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1253, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLY142(___1292, ___1295, ___1257, ___1301, ___1253, ___1252, ___1254); } EXTERNC tecio_API int32_t tecpoly112_( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1253, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLY142(___1292, ___1295, ___1257, ___1301, ___1253, ___1252, ___1254); } EXTERNC tecio_API int32_t tecpoly111_( int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301, int32_t const* ___1253, int32_t const* ___1252, int16_t const* ___1254) { return TECPOLY111(___1292, ___1295, ___1257, ___1301, ___1253, ___1252, ___1254); }
 #endif
int32_t TECPOLYFACE142( int32_t const* ___2807, int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3986(___689, ___2807, ___1292, ___1295, ___1257, ___1301); else
 #endif
return ___4008(___689, ___2807, ___1292, ___1295, ___1257, ___1301); } int32_t TECPOLYFACE112( int32_t const* ___2807, int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301) { return TECPOLYFACE142(___2807, ___1292, ___1295, ___1257, ___1301); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecpolyface142_( int32_t const* ___2807, int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301) { return TECPOLYFACE142(___2807, ___1292, ___1295, ___1257, ___1301); } EXTERNC tecio_API int32_t tecpolyface112_( int32_t const* ___2807, int32_t const* ___1292, int32_t const* ___1295, int32_t const* ___1257, int32_t const* ___1301) { return TECPOLYFACE142(___2807, ___1292, ___1295, ___1257, ___1301); }
 #endif
int32_t TECPOLYBCONN142( int32_t const* ___2779, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) return ___3985(___689, ___2779, ___1251, ___1252, ___1254); else
 #endif
return ___4007(___689, ___2779, ___1251, ___1252, ___1254); } int32_t TECPOLYBCONN112( int32_t const* ___2779, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLYBCONN142(___2779, ___1251, ___1252, ___1254); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecpolybconn142_( int32_t const* ___2779, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLYBCONN142(___2779, ___1251, ___1252, ___1254); } EXTERNC tecio_API int32_t tecpolybconn112_( int32_t const* ___2779, int32_t const* ___1251, int32_t const* ___1252, int32_t const* ___1254) { return TECPOLYBCONN142(___2779, ___1251, ___1252, ___1254); }
 #endif
int32_t TECFEPTN142( int32_t const* ___2978, int32_t const* numnodes, int32_t const* numcells, int32_t const* ngnodes, int32_t const* gnodes, int32_t const* gnpartitions, int32_t const* gnpnodes, int32_t const* ngcells, int32_t const* gcells) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3185("Err: (TECFEPTN142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
return TECIOSZL_FEPTN( ___689, ___2978, numnodes, numcells, ngnodes, gnodes, gnpartitions, gnpnodes, ngcells, gcells); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecfeptn142_( int32_t const* ___2978, int32_t const* numnodes, int32_t const* numcells, int32_t const* ngnodes, int32_t const* gnodes, int32_t const* gnpartitions, int32_t const* gnpnodes, int32_t const* ngcells, int32_t const* gcells) { return TECFEPTN142( ___2978, numnodes, numcells, ngnodes, gnodes, gnpartitions, gnpnodes, ngcells, gcells); }
 #endif
int32_t TECIJKPTN142( int32_t const* ___2978, int32_t const* imin, int32_t const* jmin, int32_t const* kmin, int32_t const* imax, int32_t const* jmax, int32_t const* kmax) {
 #if !defined TECIOMPI
if (___1389[___689] == FILEFORMAT_PLT) { ___3185("Err: (TECIJKPTN142) Can be called only for SZL data (FileFormat = 1).\n"); return 9; } else
 #endif
return TECIOSZL_IJKPTN( ___689, ___2978, imin, jmin, kmin, imax, jmax, kmax); }
 #if defined ___1232
EXTERNC tecio_API int32_t tecijkptn142_( int32_t const* ___2978, int32_t const* imin, int32_t const* jmin, int32_t const* kmin, int32_t const* imax, int32_t const* jmax, int32_t const* kmax) { return TECIJKPTN142( ___2978, imin, jmin, kmin, imax, jmax, kmax); }
 #endif
int32_t TECMPIINIT142(void* communicator, int32_t const* mainrank) {
 #   if !defined TECIOMPI
___4279(communicator); ___4279(mainrank); ___3185("Err: (TECMPIINIT142) To use the TECIO MPI symbols you must link your application " "with the teciompi library instead of the non-MPI version, tecio.\n"); return -1;
 #   else
if (!communicator) return 1; else if (!mainrank || *mainrank < 0) return 2; return TECIOSZL_MPIINIT(&___689, communicator, mainrank);
 #   endif
}
 #if defined ___1232
EXTERNC tecio_API int32_t tecmpiinit142_(void* communicator, int32_t const* mainrank) { return TECMPIINIT142(communicator, mainrank); }
 #endif
int32_t TECZNEMAP142(int32_t const* npartitions, int32_t const* ptnranks) {
 #   if !defined TECIOMPI
___4279(npartitions); ___4279(ptnranks); ___3185("Err: (TECZNEMAP142) To use the TECIO MPI symbols you must link your application " "with the teciompi library instead of the non-MPI version, tecio.\n"); return -1;
 #   else
if (!npartitions) ___3185("Err: (TECZNEMAP142) Bad value <NULL> for parameter npartitions.\n"); else if (*npartitions < 1) ___3186("Err: (TECZNEMAP142) Bad value for parameter npartitions: %d.\n", *npartitions); else if (!ptnranks) ___3185("Err: (TECZNEMAP142) Bad value <NULL> for parameter ptnranks.\n"); else return TECIOSZL_ZNEMAP(___689, npartitions, ptnranks); return -1;
 #   endif
}
 #if defined ___1232
EXTERNC tecio_API int32_t tecznemap142_(int32_t* npartitions, int32_t* ptnworkers) { return TECZNEMAP142(npartitions, ptnworkers); }
 #endif
EXTERNC tecio_API int32_t convertrawdata(char const* ___1392) { return tecioszl_convertrawdata(___1392); } namespace { bool validFileHandle(void* fileHandle, char const* routine) { if (fileFormatForHandle.find(fileHandle) == fileFormatForHandle.end()) { std::cerr << "Invalid file handle passed to routine " << routine << std::endl; return false; } else { return true; } } } int32_t tecCustomLabelsGetNumSets(void* fileHandle, int32_t* numSets) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(numSets)) { std::cerr << "Invalid 'numSets' parameter to tecCustomLabelsGetNumSets. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_CustomLabelsGetNumSets(fileHandle, numSets); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t numCustomLabelSets(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t numSets; if (tecCustomLabelsGetNumSets(fileHandle, &numSets) == 0) return numSets; return 0; } } int32_t tecCustomLabelsGetSet(void* fileHandle, int32_t ___4453, char** labelSet) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4453 <= 0 || numCustomLabelSets(fileHandle) < ___4453) { std::cerr << "Invalid 'whichSet' parameter to tecCustomLabelsGetSet. Must be 0 < whichSet <= numSets (" << numCustomLabelSets(fileHandle) << ")." << std::endl; } else if (!VALID_REF(labelSet) || *labelSet != NULL) { std::cerr << "Invalid 'labelSet' parameter to tecCustomLabelsGetSet. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_CustomLabelsGetSet(fileHandle, ___4453, labelSet); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t numDataSetAuxDataItems(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3359; tecDataSetAuxDataGetNumItems(fileHandle, &___3359); return ___3359; } } int32_t tecDataSetAuxDataGetItem(void* fileHandle, int32_t whichItem, char** ___2686, char** value) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (whichItem <= 0 || numDataSetAuxDataItems(fileHandle) < whichItem) { std::cerr << "Invalid 'whichItem' parameter to tecDataSetAuxDataGetItem. Must be 0 < whichItem <= numItems." << std::endl; } else if (!VALID_REF(___2686) || *___2686 != NULL) { std::cerr << "Invalid 'name' parameter to tecDataSetAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; } else if (!VALID_REF(value) || *value != NULL) { std::cerr << "Invalid 'value' parameter to tecDataSetAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetAuxDataGetItem(fileHandle, whichItem, ___2686, value); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecDataSetAuxDataGetNumItems(void* fileHandle, int32_t* ___2813) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (!VALID_REF(___2813)) { std::cerr << "Invalid 'numItems' parameter to tecDataSetAuxDataGetNumItems. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetAuxDataGetNumItems(fileHandle, ___2813); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecDataSetGetNumVars(void* fileHandle, int32_t* ___2844) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___2844)) { std::cerr << "Invalid 'numVars' parameter to tecDataSetGetNumVars. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetGetNumVars(fileHandle, ___2844); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t ___2844(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3359 = 0; if (tecDataSetGetNumVars(fileHandle, &___3359) == 0) return ___3359; return 0; } } int32_t tecDataSetGetNumZones(void* fileHandle, int32_t* ___2847) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___2847)) { std::cerr << "Invalid 'numZones' parameter to tecDataSetGetNumZones. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetGetNumZones(fileHandle, ___2847); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecDataSetGetTitle(void* fileHandle, char** ___4178) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___4178) || *___4178 != NULL) { std::cerr << "Invalid 'title' parameter to tecDataSetGetTitle. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_DataSetGetTitle(fileHandle, ___4178); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecFileGetType(void* fileHandle, int32_t* ___1405) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(___1405)) { std::cerr << "Invalid 'fileType' parameter to tecFileGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_FileGetType(fileHandle, ___1405); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecFileReaderClose(void** fileHandle) { int32_t returnCode = -1; if (validFileHandle(*fileHandle, "tecFileReaderClose")) { if (fileFormatForHandle[*fileHandle] == FILEFORMAT_SZL) { returnCode = tecioSZL_FileReaderClose(fileHandle); } else { ___476(!"Not implemented for .plt"); } fileFormatForHandle.erase(*fileHandle); } return returnCode; } int32_t tecFileReaderOpen(char const* ___1392, void** fileHandle) { int32_t ___3359 = 0; if (!___1392 || strlen(___1392) == 0) { std::cerr << "tecFileReaderOpen: Bad fileName parameter."; ___3359 = -1; } if (!fileHandle) { std::cerr << "tecFileReaderOpen: Bad fileHandle parameter.";
___3359 = -1; } *fileHandle = NULL; switch (tecioSZL_FileReaderOpen(___1392, fileHandle)) { case TecioSZLFileOpenResult_OK: fileFormatForHandle[*fileHandle] = FILEFORMAT_SZL; break; case TecioSZLFileOpenResult_ErrorOpeningFile: std::cerr << "tecFileReaderOpen: Error opening file \"" << ___1392 << "\" for reading." << std::endl; ___3359 = -1; break; case TecioSZLFileOpenResult_BadFormat: std::cerr << "tecFileReaderOpen: File \"" << ___1392 << "\" does not appear to be a .szplt file"; ___3359 = -1; break; case TecioSZLFileOpenResult_OutOfMemory: std::cerr << "Error reading file \"" << ___1392 << ".\" Out of memory." << std::endl; ___3359 = -1; break; default: ___476(___1303); ___3359 = -1; break; } ENSURE(EQUIVALENCE(___3359 == 0, VALID_REF(*fileHandle))); return ___3359; } namespace { int32_t numGeoms(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3359; if (tecGeomGetNumGeoms(fileHandle, &___3359) == 0) return ___3359; return 0; } bool validGeom(void* fileHandle, int32_t ___1553, char const* routineName) { REQUIRE(VALID_REF(fileHandle)); if (___1553 <= 0 || numGeoms(fileHandle) < ___1553) { std::cerr << "Invalid '___1553' parameter to " << routineName << ". Must be 0 < ___1553 <= numGeoms (" << numGeoms(fileHandle) << ")." << std::endl; return false; } return true; } } int32_t tecGeomArrowheadGetAngle(void* fileHandle, int32_t ___1553, double* ___56) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___56)) { std::cerr << "Invalid '___56' parameter to tecGeomArrowheadGetAngle. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomArrowheadGetAngle(fileHandle, ___1553, ___56); } else { ___476(!"Not ___1906 for .plt files"); } return -1; } int32_t tecGeomArrowheadGetAttach(void* fileHandle, int32_t ___1553, int32_t* attachment) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(attachment)) { std::cerr << "Invalid 'attachment' parameter to tecGeomArrowheadGetAttach. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomArrowheadGetAttach(fileHandle, ___1553, attachment); } else { ___476(!"Not ___1906 for .plt files"); } return -1; } int32_t tecGeomArrowheadGetSize(void* fileHandle, int32_t ___1553, double* arrowheadSize) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(arrowheadSize)) { std::cerr << "Invalid 'arrowheadSize' parameter to tecGeomArrowheadGetSize. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomArrowheadGetSize(fileHandle, ___1553, arrowheadSize); } else { ___476(!"Not ___1906 for .plt files"); } return -1; } int32_t tecGeomArrowheadGetStyle(void* fileHandle, int32_t ___1553, int32_t* arrowheadStyle)
{ if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(arrowheadStyle)) { std::cerr << "Invalid 'arrowheadStyle' parameter to tecGeomArrowheadGetStyle. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomArrowheadGetStyle(fileHandle, ___1553, arrowheadStyle); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { GeomType_e ___1650(void* fileHandle, int32_t ___1553) { int32_t type; if (tecGeomGetType(fileHandle, ___1553, &type) == 0) return (GeomType_e)type; return GeomType_Invalid; } } int32_t tecGeomCircleGetRadius(void* fileHandle, int32_t ___1553, double* radius) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1650(fileHandle, ___1553) != GeomType_Circle) { std::cerr << "Invalid 'geom' parameter to tecGeomCircleGetRadius. The referenced geometry must be a circle." << std::endl; } else if (!VALID_REF(radius)) { std::cerr << "Invalid 'radius' parameter to tecGeomCircleGetRadius. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomCircleGetRadius(fileHandle, ___1553, radius); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomEllipseGetNumPoints(void* fileHandle, int32_t ___1553, int32_t* numEllipsePoints) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1650(fileHandle, ___1553) != GeomType_Ellipse && ___1650(fileHandle, ___1553) != GeomType_Circle) { std::cerr << "Invalid 'geom' parameter to tecGeomEllipseGetNumPoints. The referenced geometry must be an ellipse or a circle." << std::endl; } else if (!VALID_REF(numEllipsePoints)) { std::cerr << "Invalid 'numEllipsePoints' parameter to tecGeomEllipseGetNumPoints. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomEllipseGetNumPoints(fileHandle, ___1553, numEllipsePoints); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomEllipseGetSize(void* fileHandle, int32_t ___1553, double* horizontalAxis, double* verticalAxis) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1650(fileHandle, ___1553) != GeomType_Ellipse) { std::cerr << "Invalid 'geom' parameter to tecGeomEllipseGetSize. The referenced geometry must be an ellipse." << std::endl; } else if (!VALID_REF(horizontalAxis)) { std::cerr << "Invalid 'horizontalAxis' parameter to tecGeomEllipseGetSize. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(verticalAxis)) { std::cerr << "Invalid 'verticalAxis' parameter to tecGeomEllipseGetSize. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomEllipseGetSize(fileHandle, ___1553, horizontalAxis, verticalAxis);
} else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetAnchorPos(void* fileHandle, int32_t ___1553, double* x, double* ___4583, double* z) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(x)) { std::cerr << "Invalid 'x' parameter to tecGeomGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(___4583)) { std::cerr << "Invalid 'y' parameter to tecGeomGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(z)) { std::cerr << "Invalid 'z' parameter to tecGeomGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetAnchorPos(fileHandle, ___1553, x, ___4583, z); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetClipping(void* fileHandle, int32_t ___1553, int32_t* ___493) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___493)) { std::cerr << "Invalid 'clipping' parameter to tecGeomGetClipping. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetClipping(fileHandle, ___1553, ___493); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetColor(void* fileHandle, int32_t ___1553, int32_t* color) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(color)) { std::cerr << "Invalid 'color' parameter to tecGeomGetColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetColor(fileHandle, ___1553, color); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetCoordMode(void* fileHandle, int32_t ___1553, int32_t* coordMode) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(coordMode)) { std::cerr << "Invalid 'coordMode' parameter to tecGeomGetCoordMode. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetCoordMode(fileHandle, ___1553, coordMode); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetFillColor(void* fileHandle, int32_t ___1553, int32_t* ___1409) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___1409)) { std::cerr << "Invalid 'fillColor' parameter to tecGeomGetFillColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetFillColor(fileHandle, ___1553, ___1409); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetLinePattern(void* fileHandle, int32_t ___1553, int32_t* ___2264)
{ if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2264)) { std::cerr << "Invalid 'linePattern' parameter to tecGeomGetLinePattern. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetLinePattern(fileHandle, ___1553, ___2264); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetLineThickness(void* fileHandle, int32_t ___1553, double* ___2290) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2290)) { std::cerr << "Invalid 'lineThickness' parameter to tecGeomGetLineThickness. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetLineThickness(fileHandle, ___1553, ___2290); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetMacroFunctionCmd(void* fileHandle, int32_t ___1553, char** macroFunctionCmd) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(macroFunctionCmd) || *macroFunctionCmd != NULL) { std::cerr << "Invalid 'macroFunctionCmd' parameter to tecGeomGetMacroFunctionCmd. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetMacroFunctionCmd(fileHandle, ___1553, macroFunctionCmd); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetNumGeoms(void* fileHandle, int32_t* numGeoms) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (!VALID_REF(numGeoms)) { std::cerr << "Invalid 'numGeoms' parameter to tecGeomGetNumGeoms. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetNumGeoms(fileHandle, numGeoms); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetPatternLength(void* fileHandle, int32_t ___1553, double* ___2987) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2987)) { std::cerr << "Invalid 'patternLength' parameter to tecGeomGetPatternLength. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetPatternLength(fileHandle, ___1553, ___2987); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetScope(void* fileHandle, int32_t ___1553, int32_t* ___3443) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___3443)) { std::cerr << "Invalid 'scope' parameter to tecGeomGetScope. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL)
{ return tecioSZL_GeomGetScope(fileHandle, ___1553, ___3443); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetType(void* fileHandle, int32_t ___1553, int32_t* type) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(type)) { std::cerr << "Invalid 'type' parameter to tecGeomGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetType(fileHandle, ___1553, type); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomGetZone(void* fileHandle, int32_t ___1553, int32_t* zone) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(zone)) { std::cerr << "Invalid 'zone' parameter to tecGeomGetZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomGetZone(fileHandle, ___1553, zone); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomIsAttached(void* fileHandle, int32_t ___1553, int32_t* ___2003) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2003)) { std::cerr << "Invalid 'isAttached' parameter to tecGeomIsAttached. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomIsAttached(fileHandle, ___1553, ___2003); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomIsFilled(void* fileHandle, int32_t ___1553, int32_t* ___2021) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (!VALID_REF(___2021)) { std::cerr << "Invalid 'isFilled' parameter to tecGeomIsFilled. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomIsFilled(fileHandle, ___1553, ___2021); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t ___2836(void* fileHandle, int32_t ___1553) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3359; if (tecGeomLineGetSegmentCount(fileHandle, ___1553, &___3359) == 0) return ___3359; return 0; } int32_t segmentPointCount(void* fileHandle, int32_t ___1553, int32_t segment) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(___1553 > 0); REQUIRE(segment > 0); int32_t pointCount; if (tecGeomLineSegmentGetPointCount(fileHandle, ___1553, segment, &pointCount) == 0) return pointCount; return 0; } } int32_t tecGeomLineGetPoint(void* fileHandle, int32_t ___1553, int32_t segment, int32_t index, double* x, double* ___4583, double* z) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1650(fileHandle, ___1553) != GeomType_LineSegs && ___1650(fileHandle, ___1553) != GeomType_LineSegs3D) { std::cerr << "Invalid 'geom' parameter to tecGeomLineGetPoint. Must be a line-type geometry." << std::endl;
} else if (segment <= 0 || ___2836(fileHandle, ___1553) < segment) { std::cerr << "Invalid 'segment' parameter to tecGeomLineSegmentGetPointCount. Must be 0 < segment <= numSegments (" << ___2836(fileHandle, ___1553) << ")." << std::endl; } else if (index < 1 || segmentPointCount(fileHandle, ___1553, segment) < index) { std::cerr << "Invalid 'index' parameter to tecGeomLineGetPoint. Must be 0 < index < segmentPointCount (" << segmentPointCount(fileHandle, ___1553, segment) << " for this segment)." << std::endl; } else if (!VALID_REF(x)) { std::cerr << "Invalid 'x' parameter to tecGeomLineGetPoint. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(___4583)) { std::cerr << "Invalid 'y' parameter to tecGeomLineGetPoint. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(z)) { std::cerr << "Invalid 'z' parameter to tecGeomLineGetPoint. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomLineGetPoint(fileHandle, ___1553, segment, index, x, ___4583, z); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomLineGetSegmentCount(void* fileHandle, int32_t ___1553, int32_t* segmentCount) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1650(fileHandle, ___1553) != GeomType_LineSegs && ___1650(fileHandle, ___1553) != GeomType_LineSegs3D) { std::cerr << "Invalid 'geom' parameter to tecGeomLineGetSegmentCount. Must be a line-type geometry." << std::endl; } else if (!VALID_REF(segmentCount)) { std::cerr << "Invalid 'segmentCount' parameter to tecGeomLineGetSegmentCount. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomLineGetSegmentCount(fileHandle, ___1553, segmentCount); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomLineSegmentGetPointCount(void* fileHandle, int32_t ___1553, int32_t segment, int32_t* pointCount) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1650(fileHandle, ___1553) != GeomType_LineSegs && ___1650(fileHandle, ___1553) != GeomType_LineSegs3D) { std::cerr << "Invalid 'geom' parameter to tecGeomLineSegmentGetPointCount. Must be a line-type geometry." << std::endl; } else if (segment <= 0 || ___2836(fileHandle, ___1553) < segment) { std::cerr << "Invalid 'segment' parameter to tecGeomLineSegmentGetPointCount. Must be 0 < segment <= numSegments (" << ___2836(fileHandle, ___1553) << ")." << std::endl; } else if (!VALID_REF(pointCount)) { std::cerr << "Invalid 'pointCount' parameter to tecGeomLineSegmentGetPointCount. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomLineSegmentGetPointCount(fileHandle, ___1553, segment, pointCount); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomRectangleGetSize(void* fileHandle, int32_t ___1553, double* ___4458, double* ___1825)
{ if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1650(fileHandle, ___1553) != GeomType_Rectangle) { std::cerr << "Invalid 'geom' parameter to tecGeomRectangleGetSize. The referenced geometry must be a rectangle." << std::endl; } else if (!VALID_REF(___4458)) { std::cerr << "Invalid 'width' parameter to tecGeomRectangleGetSize. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(___1825)) { std::cerr << "Invalid 'height' parameter to tecGeomRectangleGetSize. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomRectangleGetSize(fileHandle, ___1553, ___4458, ___1825); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecGeomSquareGetSize(void* fileHandle, int32_t ___1553, double* size) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validGeom(fileHandle, ___1553, FUNCTION_NAME)) return -1; if (___1650(fileHandle, ___1553) != GeomType_Square) { std::cerr << "Invalid 'geom' parameter to tecGeomSquareGetSize. The referenced geometry must be a square." << std::endl; } else if (!VALID_REF(size)) { std::cerr << "Invalid 'size' parameter to tecGeomSquareGetSize. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_GeomSquareGetSize(fileHandle, ___1553, size); } else { ___476(!"Not implemented for .plt files"); } return -1; } void tecStringFree(char** string) { delete[] *string; *string = NULL; } int32_t tecStringLength(char const* string) { if (!VALID_REF(string)) return -1; return static_cast<int32_t>(strlen(string)); } namespace { int32_t numTexts(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3359; if (tecTextGetNumTexts(fileHandle, &___3359) == 0) return ___3359; return 0; } bool validText(void* fileHandle, int32_t ___4043, char const* routineName) { REQUIRE(VALID_REF(fileHandle)); if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter passed to " << routineName << ". must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; return false; } return true; } } int32_t tecTextBoxGetColor(void* fileHandle, int32_t ___4043, int32_t* ___402) { if (!validFileHandle(fileHandle, FUNCTION_NAME) || !validText(fileHandle, ___4043, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetColor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___402)) { std::cerr << "Invalid 'boxColor' parameter to tecTextBoxGetColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetColor(fileHandle, ___4043, ___402); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextBoxGetFillColor(void* fileHandle, int32_t ___4043, int32_t* ___404) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetFillColor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___404)) { std::cerr << "Invalid 'boxFillColor' parameter to tecTextBoxGetFillColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetFillColor(fileHandle, ___4043, ___404); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextBoxGetLineThickness(void* fileHandle, int32_t ___4043, double* ___406) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetLineThickness. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___406)) { std::cerr << "Invalid 'boxLineThickness' parameter to tecTextBoxGetLineThickness. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetLineThickness(fileHandle, ___4043, ___406); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextBoxGetMargin(void* fileHandle, int32_t ___4043, double* ___408) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetMargin. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___408)) { std::cerr << "Invalid 'boxMargin' parameter to tecTextBoxGetMargin. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetMargin(fileHandle, ___4043, ___408); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextBoxGetType(void* fileHandle, int32_t ___4043, int32_t* ___410) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextBoxGetType. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___410)) { std::cerr << "Invalid 'boxType' parameter to tecTextBoxGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextBoxGetType(fileHandle, ___4043, ___410); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetAnchor(void* fileHandle, int32_t ___4043, int32_t* ___38) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetAnchor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___38)) { std::cerr << "Invalid 'anchor' parameter to tecTextGetAnchor. Must be a valid memory reference." << std::endl;
} else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetAnchor(fileHandle, ___4043, ___38); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetAnchorPos(void* fileHandle, int32_t ___4043, double* x, double* ___4583, double* z) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetAnchorPos. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(x)) { std::cerr << "Invalid 'x' parameter to tecTextGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(___4583)) { std::cerr << "Invalid 'y' parameter to tecTextGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(z)) { std::cerr << "Invalid 'z' parameter to tecTextGetAnchorPos. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetAnchorPos(fileHandle, ___4043, x, ___4583, z); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetAngle(void* fileHandle, int32_t ___4043, double* ___56) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetAngle. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___56)) { std::cerr << "Invalid 'angle' parameter to tecTextGetAngle. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetAngle(fileHandle, ___4043, ___56); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetClipping(void* fileHandle, int32_t ___4043, int32_t* ___493) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetClipping. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___493)) { std::cerr << "Invalid 'clipping' parameter to tecTextGetClipping. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetClipping(fileHandle, ___4043, ___493); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetColor(void* fileHandle, int32_t ___4043, int32_t* color) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetColor. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(color)) { std::cerr << "Invalid 'color' parameter to tecTextGetColor. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetColor(fileHandle, ___4043, color);
} else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetCoordMode(void* fileHandle, int32_t ___4043, int32_t* coordMode) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetCoordMode. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(coordMode)) { std::cerr << "Invalid 'coordMode' parameter to tecTextGetCoordMode. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetCoordMode(fileHandle, ___4043, coordMode); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetHeight(void* fileHandle, int32_t ___4043, double* ___1825) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetHeight. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___1825)) { std::cerr << "Invalid 'height' parameter to tecTextGetHeight. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetHeight(fileHandle, ___4043, ___1825); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetLineSpacing(void* fileHandle, int32_t ___4043, double* ___2288) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetLineSpacing. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___2288)) { std::cerr << "Invalid 'lineSpacing' parameter to tecTextGetLineSpacing. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetLineSpacing(fileHandle, ___4043, ___2288); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetMacroFunctionCmd(void* fileHandle, int32_t ___4043, char** macroFunctionCmd) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetMacroFunctionCmd. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(macroFunctionCmd) || *macroFunctionCmd != NULL) { std::cerr << "Invalid 'macroFunctionCmd' parameter to tecTextGetMacroFunctionCmd. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetMacroFunctionCmd(fileHandle, ___4043, macroFunctionCmd); } else { ___476(!"Not implemented for .plt files"); } return -1; } EXTERNC tecio_API int32_t tecTextGetNumTexts(void* fileHandle, int32_t* numTexts) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1;
if (!VALID_REF(numTexts)) { std::cerr << "Invalid 'numTexts' parameter to tecTextGetNumTexts. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetNumTexts(fileHandle, numTexts); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetScope(void* fileHandle, int32_t ___4043, int32_t* ___3443) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetScope. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___3443)) { std::cerr << "Invalid 'scope' parameter to tecTextGetScope. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetScope(fileHandle, ___4043, ___3443); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetSizeUnits(void* fileHandle, int32_t ___4043, int32_t* sizeUnits) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetSizeUnits. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(sizeUnits)) { std::cerr << "Invalid 'sizeUnits' parameter to tecTextGetSizeUnits. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetSizeUnits(fileHandle, ___4043, sizeUnits); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetString(void* fileHandle, int32_t ___4043, char** string) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetString. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(string) || *string != NULL) { std::cerr << "Invalid 'string' parameter to tecTextGetString. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetString(fileHandle, ___4043, string); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextGetTypeface(void* fileHandle, int32_t ___4043, char** typeface) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetTypeface. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(typeface) || *typeface != NULL) { std::cerr << "Invalid 'typeface' parameter to tecTextGetTypeface. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetTypeface(fileHandle, ___4043, typeface); } else { ___476(!"Not implemented for .plt files");
} return -1; } int32_t tecTextGetZone(void* fileHandle, int32_t ___4043, int32_t* zone) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextGetZone. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(zone)) { std::cerr << "Invalid 'zone' parameter to tecTextGetZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextGetZone(fileHandle, ___4043, zone); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextIsAttached(void* fileHandle, int32_t ___4043, int32_t* ___2003) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextIsAttached. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(___2003)) { std::cerr << "Invalid 'isAttached' parameter to tecTextIsAttached. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextIsAttached(fileHandle, ___4043, ___2003); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextIsBold(void* fileHandle, int32_t ___4043, int32_t* isBold) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextIsBold. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(isBold)) { std::cerr << "Invalid 'isBold' parameter to tecTextIsBold. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextIsBold(fileHandle, ___4043, isBold); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecTextIsItalic(void* fileHandle, int32_t ___4043, int32_t* isItalic) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4043 < 0 || numTexts(fileHandle) < ___4043) { std::cerr << "Invalid 'text' parameter to tecTextIsItalic. must be 0 < text < numTexts (" << numTexts(fileHandle) << ")." << std::endl; } else if (!VALID_REF(isItalic)) { std::cerr << "Invalid 'isItalic' parameter to tecTextIsItalic. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_TextIsItalic(fileHandle, ___4043, isItalic); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t numVarAuxDataItems(void* fileHandle, int32_t ___4336) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(___4336 > 0); int32_t ___2813; if (tecVarAuxDataGetNumItems(fileHandle, ___4336, &___2813) == 0) return ___2813; return 0; } } int32_t tecVarAuxDataGetItem(void* fileHandle, int32_t ___4336, int32_t whichItem, char** ___2686, char** value) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (___4336 <= 0 || ___2844(fileHandle) < ___4336) { std::cerr << "Invalid 'var' parameter to tecVarAuxDataGetItem. Must be 0 < var <= numVars." << std::endl; } else if (whichItem < 0 || numVarAuxDataItems(fileHandle, ___4336) < whichItem) { std::cerr << "Invalid 'whichItem' parameter to tecVarAuxDataGetItem. Must be 0 < whichItem <= numItems (" << numVarAuxDataItems(fileHandle, ___4336) << ")." << std::endl; } else if (!VALID_REF(___2686) || *___2686 != NULL) { std::cerr << "Invalid 'name' parameter to tecVarAuxDataGetItem. Must be a valid reference and point to NULL." << std::endl; } else if (!VALID_REF(value) || *value != NULL) { std::cerr << "Invalid 'value' parameter to tecVarAuxDataGetItem. Must be a valid reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_VarAuxDataGetItem(fileHandle, ___4336, whichItem, ___2686, value); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecVarAuxDataGetNumItems(void* fileHandle, int32_t ___4336, int32_t* ___2813) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4336 <= 0 || ___2844(fileHandle) < ___4336) { std::cerr << "Invalid 'var' parameter to tecVarAuxDataGetNumItems. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(___2813)) { std::cerr << "Invalid 'numItems' parameter to tecVarAuxDataGetNumItems. Must be a valid reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_VarAuxDataGetNumItems(fileHandle, ___4336, ___2813); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecVarGetName(void* fileHandle, int32_t ___4336, char** ___2686) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4336 <= 0 || ___2844(fileHandle) < ___4336) { std::cerr << "Invalid 'var' parameter to tecVarGetName. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(___2686) || *___2686 != NULL) { std::cerr << "Invalid 'name' parameter to tecVarGetName. Must be a valid reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_VarGetName(fileHandle, ___4336, ___2686); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecVarIsEnabled(void* fileHandle, int32_t ___4336, int32_t* isEnabled) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (___4336 <= 0 || ___2844(fileHandle) < ___4336) { std::cerr << "Invalid 'var' parameter to tecVarIsEnabled. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(isEnabled)) { std::cerr << "Invalid 'isEnabled' parameter to tecVarIsEnabled. Must be a valid reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_VarIsEnabled(fileHandle, ___4336, isEnabled); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t ___2847(void* fileHandle) { REQUIRE(VALID_REF(fileHandle)); int32_t ___3359 = 0; if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { tecioSZL_DataSetGetNumZones(fileHandle, &___3359);
} else { ___476(!"Not implemented for .plt files"); } return ___3359; } } namespace { int32_t numZoneAuxDataItems(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(0 < zone && zone <= ___2847(fileHandle)); int32_t ___3359 = 0; if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { tecioSZL_ZoneAuxDataGetNumItems(fileHandle, zone, &___3359); } else { ___476(!"Not implemented for .plt files"); } return ___3359; } } int32_t tecZoneAuxDataGetItem(void* fileHandle, int32_t zone, int32_t whichItem, char** ___2686, char** value) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneAuxDataGetItem. Must be 0 < zone <= numZones." << std::endl; } else if (whichItem <= 0 || numZoneAuxDataItems(fileHandle, zone) < whichItem) { std::cerr << "Invalid 'whichItem' parameter to tecZoneAuxDataGetItem. Must be 0 < whichItem <= numItems." << std::endl; } else if (!VALID_REF(___2686) || *___2686 != NULL) { std::cerr << "Invalid 'name' parameter to tecZoneAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; } else if (!VALID_REF(value) || *value != NULL) { std::cerr << "Invalid 'value' parameter to tecZoneAuxDataGetItem. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneAuxDataGetItem(fileHandle, zone, whichItem, ___2686, value); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneAuxDataGetNumItems(void* fileHandle, int32_t zone, int32_t* ___2813) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneAuxDataGetNumItems. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___2813)) { std::cerr << "Invalid 'numItems' parameter to tecZoneAuxDataGetNumItems. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneAuxDataGetNumItems(fileHandle, zone, ___2813); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneConnectivityGetSharedZone(void* fileHandle, int32_t zone, int32_t* sharedZone) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneConnectivityGetSharedZone. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(sharedZone)) { std::cerr << "Invalid 'sharedZone' parameter to tecZoneConnectivityGetSharedZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneConnectivityGetSharedZone(fileHandle, zone, sharedZone); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrGetConnections(void* fileHandle, int32_t zone, int32_t* connections) { if (!validFileHandle(fileHandle, FUNCTION_NAME))
return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetConnections. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(connections)) { std::cerr << "Invalid 'connections' parameter to tecZoneFaceNbrGetConnections. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrGetConnections(fileHandle, zone, connections); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrGetConnections64(void* fileHandle, int32_t zone, int64_t* connections) { ___4279(fileHandle); ___4279(zone); ___4279(connections); ___476(!"Not implemented"); return -1; } int32_t tecZoneFaceNbrGetMode(void* fileHandle, int32_t zone, int32_t* ___2505) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetMode. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___2505)) { std::cerr << "Invalid 'mode' parameter to tecZoneFaceNbrGetMode. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrGetMode(fileHandle, zone, ___2505); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrGetNumConnections(void* fileHandle, int32_t zone, int64_t* numConnections) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetNumConnections. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(numConnections)) { std::cerr << "Invalid 'numConnections' parameter to tecZoneFaceNbrGetNumConnections. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrGetNumConnections(fileHandle, zone, numConnections); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrGetNumValues(void* fileHandle, int32_t zone, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrGetNumValues. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(numValues)) { std::cerr << "Invalid 'numValues' parameter to tecZoneFaceNbrGetNumValues. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrGetNumValues(fileHandle, zone, numValues); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneFaceNbrsAre64Bit(void* fileHandle, int32_t zone, int32_t* are64Bit) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneFaceNbrsAre64Bit. Must be 0 < zone <= numZones." << std::endl;
} else if (!VALID_REF(are64Bit)) { std::cerr << "Invalid 'are64Bit' parameter to tecZoneFaceNbrsAre64Bit. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneFaceNbrsAre64Bit(fileHandle, zone, are64Bit); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetIJK(void* fileHandle, int32_t zone, int64_t* iMax, int64_t* jMax, int64_t* kMax) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetIJK. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(iMax)) { std::cerr << "Invalid 'iMax' parameter to tecZoneGetIJK. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(jMax)) { std::cerr << "Invalid 'jMax' parameter to tecZoneGetIJK. Must be a valid memory reference." << std::endl; } else if (!VALID_REF(kMax)) { std::cerr << "Invalid 'kMax' parameter to tecZoneGetIJK. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetIJK(fileHandle, zone, iMax, jMax, kMax); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetParentZone(void* fileHandle, int32_t zone, int32_t* ___2975) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetParentZone. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___2975)) { std::cerr << "Invalid 'parentZone' parameter to tecZoneGetParentZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { *___2975 = 0; return 0; } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetSolutionTime(void* fileHandle, int32_t zone, double* ___3641) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetSolutionTime. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___3641)) { std::cerr << "Invalid 'solutionTime' parameter to tecZoneGetSolutionTime. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetSolutionTime(fileHandle, zone, ___3641); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetStrandID(void* fileHandle, int32_t zone, int32_t* ___3786) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetStrandID. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___3786)) { std::cerr << "Invalid 'strandID' parameter to tecZoneGetStrandID. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL)
{ return tecioSZL_ZoneGetStrandID(fileHandle, zone, ___3786); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetTitle(void* fileHandle, int32_t zone, char** ___4178) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetTitle. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(___4178) || *___4178 != NULL) { std::cerr << "Invalid 'title' parameter to tecZoneGetTitle. Must be a valid memory reference and point to NULL." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetTitle(fileHandle, zone, ___4178); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetType(void* fileHandle, int32_t zone, int32_t* type) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetType. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(type)) { std::cerr << "Invalid 'type' parameter to tecZoneGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetType(fileHandle, zone, type); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetNumSections(void* fileHandle, int32_t zone, int32_t* numSections) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetNumSections. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(numSections)) { std::cerr << "Invalid 'numSections' parameter to tecZoneGetNumSections. Must be a valid memory " "reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetNumSections(fileHandle, zone, numSections); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneGetSectionMetrics( void* fileHandle, int32_t zone, int32_t section, int32_t* cellShape, int32_t* gridOrder, int32_t* basisFunction, int64_t* numElemsInSection, int32_t* numNodesPerCell) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; int32_t numSections{0}; tecZoneGetNumSections(fileHandle, zone, &numSections); if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneGetSectionMetrics. Must be 0 < zone <= numZones." << std::endl; } else if (section <= 0 || numSections < section) { std::cerr << "Invalid 'section' parameter to tecZoneGetSectionMetrics. Must be 0 < " "section <= numSections(zone)." << std::endl; } else if (!VALID_REF(cellShape)) { std::cerr << "Invalid 'cellShape' parameter to tecZoneGetSectionMetrics. Must be a valid memory " "reference." << std::endl; } else if (!VALID_REF(gridOrder)) { std::cerr << "Invalid 'gridOrder' parameter to tecZoneGetSectionMetrics. Must be a valid memory "
"reference." << std::endl; } else if (!VALID_REF(basisFunction)) { std::cerr << "Invalid 'basisFunction' parameter to tecZoneGetSectionMetrics. Must be a valid memory " "reference." << std::endl; } else if (!VALID_REF(numElemsInSection)) { std::cerr << "Invalid 'numElemsInSection' parameter to tecZoneGetSectionMetrics. Must be a valid memory " "reference." << std::endl; } else if (!VALID_REF(numNodesPerCell)) { std::cerr << "Invalid 'numNodesPerCell' parameter to tecZoneGetSectionMetrics. Must be a " "valid memory " "reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneGetSectionMetrics(fileHandle, zone, section, cellShape, gridOrder, basisFunction, numElemsInSection, numNodesPerCell); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneIsEnabled(void* fileHandle, int32_t zone, int32_t* isEnabled) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneIsEnabled. Must be 0 < zone <= numZones." << std::endl; } else if (!VALID_REF(isEnabled)) { std::cerr << "Invalid 'isEnabled' parameter to tecZoneIsEnabled. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneIsEnabled(fileHandle, zone, isEnabled); } else { ___476(!"Not implemented for .plt files"); } return -1; } namespace { int32_t ___4692(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); int32_t type; tecZoneGetType(fileHandle, zone, &type); return type; } bool zoneHasNodeMap(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); int32_t type; tecZoneGetType(fileHandle, zone, &type); return ((1 <= type && type <= 5) || type == 8); } int64_t zoneNumCells(void* fileHandle, int32_t zone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0 && zoneHasNodeMap(fileHandle, zone)); int64_t iMax; int64_t jMax; int64_t kMax; if (tecZoneGetIJK(fileHandle, zone, &iMax, &jMax, &kMax) == 0) return jMax; else return 0; } int32_t nodeMapGetNumValues(void* fileHandle, int32_t zone, int64_t ___2782, int64_t* numValues) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0 && zoneHasNodeMap(fileHandle, zone)); int64_t iMax; int64_t jMax; int64_t kMax; if (tecZoneGetIJK(fileHandle, zone, &iMax, &jMax, &kMax) == 0) { *numValues = ___2782 * kMax; return 0; } return -1; } } int32_t tecZoneNodeMapGet(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2782, int32_t* ___2724) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGet. Must be 0 < zone <= numZones." << std::endl; } else if (!zoneHasNodeMap(fileHandle, zone)) { std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGetNumValues. Must be a line segment, triangular, quadrilateral, tetrahedral or brick zone." << std::endl;
} else if (startCell <= 0) { std::cerr << "Invalid 'startCell' parameter to tecZoneNodeMapGet. Must be > 0." << std::endl; } else if (___2782 <= 0 || zoneNumCells(fileHandle, zone) < startCell + ___2782 - 1) { std::cerr << "Invalid 'numCells' parameter to tecZoneNodeMapGet. Must be 0 < numCells <= zoneNumCells - startCell + 1." << std::endl; } else if (!VALID_REF(___2724)) { std::cerr << "Invalid 'nodeMap' parameter to tecZoneNodeMapGet. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneNodeMapGet(fileHandle, zone, startCell, ___2782, ___2724); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneNodeMapGet64(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2782, int64_t* ___2724) { ___4279(fileHandle); ___4279(zone); ___4279(startCell); ___4279(___2782); ___4279(___2724); ___476(!"Not implemented"); return 1; } int32_t tecZoneNodeMapGetNumValues(void* fileHandle, int32_t zone, int64_t ___2782, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGetNumValues. Must be 0 < zone <= numZones." << std::endl; } else if (!zoneHasNodeMap(fileHandle, zone)) { std::cerr << "Invalid 'zone' parameter to tecZoneNodeMapGetNumValues. Must be a line segment, triangular, quadrilateral, tetrahedral or brick zone." << std::endl; } else if (___2782 <= 0) { std::cerr << "Invalid 'numCells' parameter to tecZoneNodeMapGetNumValues. Must be > 0." << std::endl; } else if (!VALID_REF(numValues)) { std::cerr << "Invalid 'numValues' parameter to tecZoneNodeMapGetNumValues. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return nodeMapGetNumValues(fileHandle, zone, ___2782, numValues); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneSectionNodeMapGetNumValues(void* fileHandle, int32_t zone, int32_t section, int64_t ___2782, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; int32_t numSections{0}; tecZoneGetNumSections(fileHandle, zone, &numSections); if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneSectionNodeMapGetNumValues. Must be 0 < zone <= " "numZones." << std::endl; } else if (section <= 0 || numSections < section) { std::cerr << "Invalid 'section' parameter to tecZoneSectionNodeMapGetNumValues. Must be 0 < " "section <= numSections(zone)." << std::endl; } else if (___4692(fileHandle, zone) != 8) { std::cerr << "Invalid 'zone' parameter to tecZoneSectionNodeMapGetNumValues. Must be an " "FEMixed zone." << std::endl; } else if (___2782 <= 0) { std::cerr << "Invalid 'numCells' parameter to tecZoneSectionNodeMapGetNumValues. Must be > 0." << std::endl; } else if (!VALID_REF(numValues)) { std::cerr << "Invalid 'numValues' parameter to tecZoneSectionNodeMapGetNumValues. Must be a valid "
"memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { int32_t cellShape{0}; int32_t gridOrder{0}; int32_t basisFunction{0}; int64_t numElemsInSection{0}; int32_t numNodesPerCell{0}; int32_t ___3359 = tecZoneGetSectionMetrics( fileHandle, zone, section, &cellShape, &gridOrder, &basisFunction, &numElemsInSection, &numNodesPerCell); *numValues = numNodesPerCell * ___2782; return ___3359; } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneNodeMapIs64Bit(void* fileHandle, int32_t zone, int32_t* is64Bit) { ___4279(fileHandle); ___4279(zone); *is64Bit = 0; return 0; } int32_t tecZonePolyGetBoundaryConnectionCounts(void* fileHandle, int32_t zone, int64_t startConnection, int64_t numConnections, int32_t* connectionCounts) { ___4279(fileHandle); ___4279(zone); ___4279(startConnection); ___4279(numConnections); ___4279(connectionCounts); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetBoundaryConnections(void* fileHandle, int32_t zone, int64_t startConnection, int64_t numConnections, int32_t* connectedElements, int32_t* connectedZones) { ___4279(fileHandle); ___4279(zone); ___4279(startConnection); ___4279(numConnections); ___4279(connectedElements); ___4279(connectedZones); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetFaceElems(void* fileHandle, int32_t zone, int64_t startFace, int64_t numFaces, int32_t* leftElems, int32_t* rightElems) { ___4279(fileHandle); ___4279(zone); ___4279(startFace); ___4279(numFaces); ___4279(leftElems); ___4279(rightElems); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetFaceNodeCounts(void* fileHandle, int32_t zone, int64_t startFace, int64_t numFaces, int32_t* nodeCounts) { ___4279(fileHandle); ___4279(zone); ___4279(startFace); ___4279(numFaces); ___4279(nodeCounts); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetFaceNodes(void* fileHandle, int32_t zone, int64_t startFace, int64_t numFaces, int32_t* ___1294) { ___4279(fileHandle); ___4279(zone); ___4279(startFace); ___4279(numFaces); ___4279(___1294); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetNumConnectedBoundaryFaces(void* fileHandle, int32_t zone, int64_t* numFaces) { ___4279(fileHandle); ___4279(zone); ___4279(numFaces); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetTotalNumFaceNodes(void* fileHandle, int32_t zone, int64_t* ___2822) { ___4279(fileHandle); ___4279(zone); ___4279(___2822); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl; return -1; } int32_t tecZonePolyGetTotalNumBoundaryConnections(void* fileHandle, int32_t zone, int64_t* numConnections) { ___4279(fileHandle); ___4279(zone); ___4279(numConnections); std::cerr << "Reading polyhedral data is not yet implemented." << std::endl;
return -1; } namespace { int32_t zoneVarGetNumValues(void* fileHandle, int32_t zone, int32_t ___4336, int64_t* numValues) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4336 > 0); REQUIRE(VALID_REF(numValues)); *numValues = 0; int32_t isPassive = 0; int32_t ___3359 = tecZoneVarIsPassive(fileHandle, zone, ___4336, &isPassive); if (___3359 == 0 && isPassive == 0) { int64_t iMax; int64_t jMax; int64_t kMax; ___3359 = tecZoneGetIJK(fileHandle, zone, &iMax, &jMax, &kMax); if (___3359 == 0) { int32_t ___4692; ___3359 = tecZoneGetType(fileHandle, zone, &___4692); if (___3359 == 0) { int64_t ___2822; int64_t ___2782; if (___4692 == 0) { ___2822 = iMax * jMax * kMax; ___2782 = std::max((int64_t)1, iMax - 1) * std::max((int64_t)1, jMax - 1) * std::max((int64_t)1, kMax - 1); } else { ___2822 = iMax; ___2782 = jMax; } int32_t ___4326; ___3359 = tecZoneVarGetValueLocation(fileHandle, zone, ___4336, &___4326); if (___3359 == 0) { if (___4326 == 0) *numValues = ___2782; else *numValues = ___2822; } } } } return ___3359; } int64_t zoneVarNumValues(void* fileHandle, int32_t zone, int32_t ___4336) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4336 > 0); int64_t numValues; zoneVarGetNumValues(fileHandle, zone, ___4336, &numValues); return numValues; } FieldDataType_e zoneVarType(void* fileHandle, int32_t zone, int32_t ___4336) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4336 > 0); int32_t type; tecZoneVarGetType(fileHandle, zone, ___4336, &type); return static_cast<FieldDataType_e>(type); } bool checkZoneVarGetValuesParameters(char const* routine, FieldDataType_e type, void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, void* values) { REQUIRE(VALID_REF(routine)); REQUIRE(VALID_ENUM(type, FieldDataType_e)); int32_t nZones = ___2847(fileHandle); int64_t nValues = zoneVarNumValues(fileHandle, zone, ___4336); FieldDataType_e actualType = zoneVarType(fileHandle, zone, ___4336); boost::unordered_map<FieldDataType_e, char const*> varTypeNames = boost::assign::map_list_of<FieldDataType_e, char const*> (FieldDataType_Float, "float") (FieldDataType_Double, "double") (FieldDataType_Int32, "int32_t") (FieldDataType_Int16, "int16_t") (FieldDataType_Byte, "uint8_t") (___1363, "bit"); if (!validFileHandle(fileHandle, routine)) return false; else if (zone <= 0 || nZones < zone) std::cerr << "Invalid 'zone' parameter to " << routine << ". Must be 0 < zone <= " << nZones << "." << std::endl; else if (___4336 <= 0 || ___2844(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to " << routine << ". Must be 0 < var <= " << ___2844(fileHandle) << "." << std::endl; else if (actualType != type) std::cerr << routine << " called for non-" << varTypeNames[type] << " variable. Variable " << ___4336 << " of zone " << zone << " is of type " << varTypeNames[actualType] << "." << std::endl; else if (startIndex <= 0 || nValues < startIndex) std::cerr << "Invalid 'startIndex' parameter to " << routine << " for zone " << zone << ", var " << ___4336 <<
". Must be 0 < startIndex <= numVarValues (" << nValues << ")." << std::endl; else if (numValues <= 0 || nValues - startIndex + 1 < numValues) std::cerr << "Invalid 'numValues' parameter to " << routine << " for zone " << zone << ", var " << ___4336 << ". Must be 0 < numValues <= numVarValues - startIndex + 1 (" << nValues - startIndex + 1 << ")." << std::endl; else if (!VALID_REF(values)) std::cerr << "Invalid 'values' parameter to " << routine << ". Must be a valid memory reference." << std::endl; else return true; return false; } } int32_t tecZoneVarGetDoubleValues(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, double* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetDoubleValues", FieldDataType_Double, fileHandle, zone, ___4336, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetDoubleValues(fileHandle, zone, ___4336, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetFloatValues(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, float* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetFloatValues", FieldDataType_Float, fileHandle, zone, ___4336, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetFloatValues(fileHandle, zone, ___4336, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetInt16Values(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, int16_t* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetInt16Values", FieldDataType_Int16, fileHandle, zone, ___4336, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetInt16Values(fileHandle, zone, ___4336, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetInt32Values(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, int32_t* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetInt32Values", FieldDataType_Int32, fileHandle, zone, ___4336, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetInt32Values(fileHandle, zone, ___4336, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetNumValues(void* fileHandle, int32_t zone, int32_t ___4336, int64_t* numValues) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) std::cerr << "Invalid 'zone' parameter to tecZoneVarGetNumValues. Must be 0 < zone <= numZones." << std::endl; else if (___4336 <= 0 || ___2844(fileHandle) < ___4336) std::cerr << "Invalid 'var' parameter to tecZoneVarGetNumValues. Must be 0 < var <= numVars." << std::endl;
else if (!VALID_REF(numValues)) std::cerr << "Invalid 'numValues' parameter to tecZoneVarGetNumValues. Must be a valid memory reference." << std::endl; else return zoneVarGetNumValues(fileHandle, zone, ___4336, numValues); return -1; } int32_t tecZoneVarGetSharedZone(void* fileHandle, int32_t zone, int32_t ___4336, int32_t* sharedZone) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneVarGetSharedZone. Must be 0 < zone <= numZones." << std::endl; } else if (___4336 <= 0 || ___2844(fileHandle) < ___4336) { std::cerr << "Invalid 'var' parameter to tecZoneVarGetSharedZone. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(sharedZone)) { std::cerr << "Invalid 'sharedZone' parameter to tecZoneVarGetSharedZone. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetSharedZone(fileHandle, zone, ___4336, sharedZone); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetType(void* fileHandle, int32_t zone, int32_t ___4336, int32_t* type) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneVarGetType. Must be 0 < zone <= numZones." << std::endl; } else if (___4336 <= 0 || ___2844(fileHandle) < ___4336) { std::cerr << "Invalid 'var' parameter to tecZoneVarGetType. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(type)) { std::cerr << "Invalid 'type' parameter to tecZoneVarGetType. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetType(fileHandle, zone, ___4336, type); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetUInt8Values(void* fileHandle, int32_t zone, int32_t ___4336, int64_t startIndex, int64_t numValues, uint8_t* values) { if (!checkZoneVarGetValuesParameters("tecZoneVarGetUInt8Values", FieldDataType_Byte, fileHandle, zone, ___4336, startIndex, numValues, values)) { return -1; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetUInt8Values(fileHandle, zone, ___4336, startIndex, numValues, values); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarGetValueLocation(void* fileHandle, int32_t zone, int32_t ___4336, int32_t* location) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneVarGetValueLocation. Must be 0 < zone <= numZones." << std::endl; } else if (___4336 <= 0 || ___2844(fileHandle) < ___4336) { std::cerr << "Invalid 'var' parameter to tecZoneVarGetValueLocation. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(location)) { std::cerr << "Invalid 'location' parameter to tecZoneVarGetValueLocation. Must be a valid memory reference." << std::endl;
} else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarGetValueLocation(fileHandle, zone, ___4336, location); } else { ___476(!"Not implemented for .plt files"); } return -1; } int32_t tecZoneVarIsPassive(void* fileHandle, int32_t zone, int32_t ___4336, int32_t* isPassive) { if (!validFileHandle(fileHandle, FUNCTION_NAME)) return -1; if (zone <= 0 || ___2847(fileHandle) < zone) { std::cerr << "Invalid 'zone' parameter to tecZoneVarIsPassive. Must be 0 < zone <= numZones." << std::endl; } else if (___4336 <= 0 || ___2844(fileHandle) < ___4336) { std::cerr << "Invalid 'var' parameter to tecZoneVarIsPassive. Must be 0 < var <= numVars." << std::endl; } else if (!VALID_REF(isPassive)) { std::cerr << "Invalid 'isPassive' parameter to tecZoneVarIsPassive. Must be a valid memory reference." << std::endl; } else if (fileFormatForHandle[fileHandle] == FILEFORMAT_SZL) { return tecioSZL_ZoneVarIsPassive(fileHandle, zone, ___4336, isPassive); } else { ___476(!"Not implemented for .plt files"); } return -1; }
