 #pragma once
#include "ThirdPartyHeadersBegin.h"
#  include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "AltTecUtil.h"
namespace tecplot { namespace ___3934 { typedef boost::shared_ptr<class ___1350> FieldDataPtr; class ___1350 { public: ___1350(___37* tecUtil, ___1170 zone, ___1170 ___4336, bool writable = false, bool ___962 = false); ___1350() : m_tecUtil(0) , m_fieldData(0) , m_rawDataPtr(0) , m_getFieldValue(0) , m_setFieldValue(0) , ___2460(___1367) , ___2670(___4329) , ___2669(0) , m_allocated(false) {} ~___1350() { if (m_allocated) free(m_rawDataPtr); } void allocate( FieldDataType_e ___1361, ValueLocation_e ___4326, ___2226 ___4325); bool ___2066() const { return (VALID_REF(m_tecUtil) && ___2669 > 0 && (m_fieldData != NULL || m_rawDataPtr != NULL) && VALID_ENUM(___2460, FieldDataType_e)); } double ___1779(___2226 index) const; ValueLocation_e ___1785() const { return ___2670; } FieldDataType_e getValueType() const { return ___2460; } ___2226 ___1782() const { return ___2669; } void ___3505(___2226 index, double value); void ___1758(double* minVal, double* maxVal) const; void* getRawPointer() const { ENSURE(VALID_REF_OR_NULL(m_rawDataPtr)); return m_rawDataPtr; } private: ___1350 RawValuePtrGetReadableOrWritablePtr( ___1170 zone, ___1170 ___4336, ___372  getWritable, ___372  getDerived); ___37* m_tecUtil; ___1359 m_fieldData; void* m_rawDataPtr; ___1381 m_getFieldValue; ___1382 m_setFieldValue; FieldDataType_e ___2460; ValueLocation_e ___2670; ___2226 ___2669; bool m_allocated; }; inline double ___1350::___1779(___2226 index) const { REQUIRE(0 < index && index <= ___2669); double value; ___476(VALID_REF_OR_NULL(m_rawDataPtr)); if (m_rawDataPtr != NULL) { switch(___2460) { case FieldDataType_Float: value = (double)(((float *)m_rawDataPtr)[index - 1]); break; case FieldDataType_Double: value = ((double *)m_rawDataPtr)[index - 1]; break; case FieldDataType_Int32: value = (double)(((int32_t *)m_rawDataPtr)[index - 1]); break; case FieldDataType_Int16: value = (double)(((int16_t *)m_rawDataPtr)[index - 1]); break; case FieldDataType_Byte: value = (double)(((uint8_t *)m_rawDataPtr)[index - 1]); break; case ___1363: value = (double)((((uint8_t *)m_rawDataPtr)[(index - 1) / 8] >> ((index - 1) % 8)) & (uint8_t)0x1); break; default: ___476(___1303); value = 0.0; break; } } else { ___476(VALID_FN_REF(m_getFieldValue)); value = m_getFieldValue(m_fieldData, index - 1); } return value; } inline void ___1350::___3505(___2226 index, double value) { REQUIRE(0 < index && index <= ___2669); ___476(VALID_REF_OR_NULL(m_rawDataPtr)); if (m_rawDataPtr != NULL) { switch (___2460) { case FieldDataType_Float: ((float *)(m_rawDataPtr))[index - 1] = ___648(value); break; case FieldDataType_Double: ((double *)(m_rawDataPtr))[index - 1] = ___487(value); break; case FieldDataType_Int32: ((___2226 *)(m_rawDataPtr))[index - 1] = ___650(value);
break; case FieldDataType_Int16: ((short *)(m_rawDataPtr))[index - 1] = ___649(value); break; case FieldDataType_Byte: ((uint8_t *)(m_rawDataPtr))[index - 1] = CONVERT_DOUBLE_TO_UINT8(value); break; case ___1363: { ___2226 byteOffset = (index - 1) / 8; uint8_t    bitMask = (uint8_t)(01 << ((index - 1) % 8)); if (value < 1.0) ((uint8_t *)(m_rawDataPtr))[byteOffset] &= ~bitMask; else ((uint8_t *)(m_rawDataPtr))[byteOffset] |= bitMask; } break; default: ___476(___1303); } } else { ___476(VALID_FN_REF(m_setFieldValue)); m_setFieldValue(m_fieldData, index - 1, (double)(value)); } } }}
