#include "ThirdPartyHeadersBegin.h"
#include <float.h>
#include <algorithm>
 #if !defined TECIOMPI
#include <atomic>
 #endif
#include <cctype>
#include <limits>
 #if defined DO_SUBZONE_HISTOGRAM || defined DO_ITEMANDSUBZONE_HISTOGRAM
#include <set>
 #endif
#include <sstream>
#include <stdexcept>
#include <string>
#include <boost/assign.hpp>
#include <boost/make_shared.hpp>
#include <boost/ref.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "exportSubzonePlt.h"
#include "AltTecUtil.h"
#include "FEZoneInfo.h"
#include "fileStuff.h"
#include "FileStreamWriter.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
 #if defined DO_SUBZONE_HISTOGRAM || defined DO_ITEMANDSUBZONE_HISTOGRAM
#include "FileSystem.h"
#include "ItemAddress.h"
#include "NodeMap.h"
 #endif
#include "TecplotVersion.h"
#include "writeValueArray.h"
#include "ZoneInfoCache.h"
#include "zoneUtil.h"
#include "ZoneVarMetadata.h"
#include "ZoneWriterAbstract.h"
#include "ZoneWriterFactory.h"
 #define HEADER_STRING_FORMAT "%-14s"
 #define SZPLT_REVISION "$Revision: " ___4025 " $"
namespace tecplot { namespace ___3934 { namespace { char ___847(DataFileType_e ___842) { REQUIRE(VALID_ENUM(___842, DataFileType_e)); if (___842 == ___843) return 'F'; else if (___842 == ___844) return 'G'; else return 'S'; } } ___372 ___4516( FileWriterInterface& file, char const*          ___1405, uint32_t const       fileVersion, ___372            includeRevisionNumber, uint64_t             dataSetHeaderLocation) { REQUIRE(VALID_NON_ZERO_LEN_STR(___1405) && strlen(___1405) <= 7); REQUIRE(fileVersion <= 999); ___372 ___2038 = ___4227; try { size_t const headerBufferSize = 128; char headerBuffer[headerBufferSize]; ___2038 = snprintf(headerBuffer, headerBufferSize, "#!%s %3.3" PRIu32 "%c%c", ___1405, fileVersion, file.___2001() ? 'T' : 'B', ___847(file.___842())) < static_cast<int>(headerBufferSize); std::string header(headerBuffer); if (includeRevisionNumber) header.append(" ").append(SZPLT_REVISION); ___2038 = ___2038 && file.fprintf(HEADER_STRING_FORMAT"\r\n", header.c_str()) >= SZPLT_FILE_HEADER_MIN_SIZE      && writeValue<uint64_t, true, 0>(file, ___1384, ___1383) && writeValue<uint64_t, true, 0>(file, ___893, dataSetHeaderLocation); } catch (std::bad_alloc const&) { ___2038 = ___1303; } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } namespace { ___372 writeInitialDataSetHeader( FileWriterInterface& file, ___3946 const&   headerTagMap) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); ___3943 tagDescriptionMap = DATASET_HEADER_TAG_DESCRIPTIONS_MAP_INITIALIZER; ___2038 = ___2038 && writeValue<uint16_t, false, 0>(file, ___2840, static_cast<uint16_t>(headerTagMap.size())); UInt16Array tagArray; ___2038 = ___2038 && tagArray.alloc(headerTagMap.size()); if (___2038) { size_t numTags = 0; for (___3946::const_iterator value = headerTagMap.begin(); value != headerTagMap.end(); ++value) tagArray[numTags++] = value->first; ___2038 = ___2038 && ___4563<uint16_t, false, 0>(file, ___3944, ___2746, numTags, tagArray.data()); } for (___3946::const_iterator value = headerTagMap.begin(); value != headerTagMap.end(); ++value) ___2038 = ___2038 && writeValue<uint64_t, true, 0>(file, tagDescriptionMap[value->first].c_str(), value->second); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 writePerDataSetFileHeader( FileWriterInterface& szpltFile, ___3946&         ___3945, char const*          dataSetTitle) { REQUIRE(szpltFile.___2040()); REQUIRE(VALID_REF(dataSetTitle)); ___3945[DATA_SET_TITLE_TAG] = szpltFile.fileLoc(); uint32_t dataSetTitleLength = static_cast<uint32_t>(strlen(dataSetTitle)); ___372 ___2038 = writeValue<uint32_t, false, 0>(szpltFile, DATA_SET_TITLE_LENGTH, dataSetTitleLength) && ___4544(szpltFile, DATA_SET_TITLE_DESCRIPTION, dataSetTitle); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 ___4545( FileWriterInterface& file,
char const*          ___970, size_t               ___2813, ___3817 const&   itemNames) { REQUIRE(file.___2040()); REQUIRE(VALID_DESCRIPTION(___970)); REQUIRE(___2813>0); REQUIRE(itemNames.size() == ___2813); uint64_t totalStringListSize = 0; if (file.___2001()) totalStringListSize = ___206 + 2; for (size_t ___2084 = 0; ___2084 < ___2813; ___2084++) { totalStringListSize += itemNames[___2084].size(); if (file.___2001()) totalStringListSize += 2; else totalStringListSize += 1; } if (___970) { char ___1416[___206 + 1]; sprintf(___1416, "%sTotalSize", ___970); writeValue<uint64_t, false, 0>(file, ___1416, totalStringListSize); } else writeValue<uint64_t, false, 0>(file, NULL , totalStringListSize); ___372 ___2038 = ___4227; if (file.___2001()) { ___2038 = ___2038 && (file.fprintf("%*s\r\n", -___206, ___970) != 0); for (size_t ___2084 = 0; ___2084 < ___2813; ___2084++) ___2038 = ___2038 && (file.fprintf("%s\r\n", itemNames[___2084].c_str()) != 0); } else { for (size_t ___2084 = 0; ___2084 < ___2813; ___2084++) ___2038 = ___2038 && (file.fprintf("%s\r", itemNames[___2084].c_str()) != 0); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 ___4541( FileWriterInterface&   file, ___3946&           ___3945, ___4352 const       ___2844, ___4707 const& ___4706) { REQUIRE(file.___2040()); REQUIRE(___4706.m_varNames.size() == size_t(___2844)); ___372 ___2038 = ___4227; if (___2844 > 0) { ___3945[___4365] = file.fileLoc(); ___2038 = ___4545(file, ___4364, ___2844, ___4706.m_varNames); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { template <typename T> ___372 writeZoneSecTaggedArray( FileWriterInterface&                            file, ___3946&                                    ___3945, uint16_t                                        fileLocTag, char const*                                     ___970, ___4636                                     ___2847, ___2241<uint8_t> const&               zoneNumSections, ___2241<___2241<T> > const& zoneSecArray) { REQUIRE(file.___2040()); REQUIRE(VALID_REF(___970)); REQUIRE(___2847 == checked_numeric_cast<___4636>(zoneNumSections.size())); REQUIRE(zoneNumSections.size() == zoneSecArray.size()); ___372 ___2038 = ___4227; ___3945[fileLocTag] = file.fileLoc(); for (___4636 zone = 0; ___2038 && zone < ___2847; ++zone) { ___476(zoneNumSections[zone] == checked_numeric_cast<uint8_t>(zoneSecArray[zone].size())); if (zoneNumSections[zone] > 0) ___2038 = ___4563<T, false, 0>( file, ___970, ___2746, zoneNumSections[zone], zoneSecArray[zone].data()); } return ___2038; } } namespace { ___372 ___4543( FileWriterInterface&   file, uint32_t               fileVersion, ___3946&           ___3945, ___4636 const      ___2847, ___1390 const&    ___4629,
___4707 const& ___4706) { REQUIRE(file.___2040()); REQUIRE(fileVersion == 105 || fileVersion == 231 || fileVersion == 232); REQUIRE(___4706.m_zoneNames.size() == size_t(___2847)); ___372 ___2038 = ___4227; if (___2847 > 0) { ___3945[___4651] = file.fileLoc(); ___2038 = ___4545(file, ___4650, ___2847, ___4706.m_zoneNames); ___3945[ZONE_TYPE_FILE_LOC_TAG] = file.fileLoc(); ___2038 = ___2038 && ___4563<char, false, 0>(file, ___4694, ___2746, ___2847, ___4706.m_zoneTypes.data()); ___3945[___4610] = file.fileLoc(); ___2038 = ___2038 && ___4563<uint8_t, false, 0>(file, ___4609, ___2746, ___2847, ___4706.m_zoneFaceNeighborModes.data()); ___3945[___4676] = file.fileLoc(); ___2038 = ___2038 && ___4563<double, false, 0>(file, ___4675, ___2746, ___2847, ___4706.m_zoneSolutionTimes.data()); ___3945[___4686] = file.fileLoc(); ___2038 = ___2038 && ___4563<uint32_t, false, 0>(file, ___4685, ___2746, ___2847, ___4706.m_zoneStrandIDs.data()); ___3945[___4670] = file.fileLoc(); ___2038 = ___2038 && ___4563<int32_t, false, 0>(file, ___4669, ___2746, ___2847, ___4706.m_zoneParentZones.data()); ___3945[ZONE_IMAX_OR_NUM_NODES_FILE_LOC_TAG] = file.fileLoc(); ___2038 = ___2038 && ___4563<uint64_t, false, 0>(file, ZONE_IMAX_OR_NUM_NODES_ARRAY_DESCRIPTION, ___2746, ___2847, ___4706.m_zoneIMaxOrNumNodes.data()); ___3945[ZONE_JMAX_OR_NUM_CELLS_FILE_LOC_TAG] = file.fileLoc(); ___2038 = ___2038 && ___4563<uint64_t, false, 0>(file, ZONE_JMAX_OR_NUM_CELLS_ARRAY_DESCRIPTION, ___2746, ___2847, ___4706.m_zoneJMaxOrNumCells.data()); ___3945[ZONE_KMAX_OR_NUM_CORNERS_FILE_LOC_TAG] = file.fileLoc(); ___2038 = ___2038 && ___4563<uint64_t, false, 0>(file, ZONE_KMAX_OR_NUM_CORNERS_ARRAY_DESCRIPTION, ___2746, ___2847, ___4706.m_zoneKMaxOrNumCorners.data()); ___3945[___4674] = file.fileLoc(); ___2038 = ___2038 && ___4563<int32_t, false, 0>(file, ___4673, ___2746, ___2847, ___4706.m_zoneShareConnectivityWithZone.data()); if (fileVersion >= 231) { ___3945[ZONE_NUM_SECTIONS_FILE_LOC_TAG] = file.fileLoc(); ___2038 = ___2038 && ___4563<uint8_t, false, 0>(file, ZONE_NUM_SECTIONS_ARRAY_DESCRIPTION, ___2746, ___2847, ___4706.m_zoneNumSections.data()); if (fileVersion < 232) { ___476(fileVersion == 231); ___2241<UInt32Array> zoneNumElemsPerSec_uint32; ___2038 = zoneNumElemsPerSec_uint32.alloc(___2847); for (___4636 zone = 0; ___2038 && zone < ___2847; ++zone) { ___2038 = zoneNumElemsPerSec_uint32[zone].alloc(___4706.m_zoneNumSections[zone]);
for (uint8_t section = 0; section < ___4706.m_zoneNumSections[zone]; ++section) zoneNumElemsPerSec_uint32[zone][section] = checked_numeric_cast<uint32_t>( ___4706.m_zoneNumElemsPerSec[zone][section]); } ___2038 = ___2038 && writeZoneSecTaggedArray<uint32_t>(file, ___3945, ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG, ZONE_NUM_ELEMS_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, zoneNumElemsPerSec_uint32); } else { ___2038 = ___2038 && writeZoneSecTaggedArray<int64_t>(file, ___3945, ZONE_NUM_ELEMS_PER_SECTION_FILE_LOC_TAG, ZONE_NUM_ELEMS_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, ___4706.m_zoneNumElemsPerSec); } ___2038 = ___2038 && writeZoneSecTaggedArray<uint8_t>(file, ___3945, ZONE_CELL_SHAPE_PER_SECTION_FILE_LOC_TAG, ZONE_CELL_SHAPE_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, ___4706.m_zoneCellShapePerSec); ___2038 = ___2038 && writeZoneSecTaggedArray<uint8_t>(file, ___3945, ZONE_GRID_ORDER_PER_SECTION_FILE_LOC_TAG, ZONE_GRID_ORDER_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, ___4706.m_zoneGridOrderPerSec); ___2038 = ___2038 && writeZoneSecTaggedArray<uint8_t>(file, ___3945, ZONE_CELL_BASIS_FUNC_PER_SECTION_FILE_LOC_TAG, ZONE_CELL_BASIS_FUNC_PER_SECTION_ARRAY_DESCRIPTION, ___2847, ___4706.m_zoneNumSections, ___4706.m_zoneCellBasisFuncPerSec); } ___3945[___4630] = file.fileLoc(); ___2038 = ___2038 && ___4563<uint64_t, true, 0>(file, ___4628, ___2746, ___2847, ___4629.data()); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 ___4542( FileWriterInterface&   file, ___3946&           ___3945, ___4352 const       ___2844, ___4636 const      ___2847, ___4707 const& ___4706) { REQUIRE(file.___2040()); if (___2847 == 0 || ___2844 == 0) return ___4227; REQUIRE(___4706.m_vzMinMaxes.size() == size_t(___2844)); REQUIRE(___4706.m_vzMinMaxes[0].size() == size_t(___2847) && ___4706.m_vzMinMaxes[___2844 / 2].size() == size_t(___2847) && ___4706.m_vzMinMaxes[___2844 - 1].size() == size_t(___2847)); REQUIRE(___4706.m_vzValueLocations.size() == size_t(___2844)); REQUIRE(___4706.m_vzValueLocations[0].size() == size_t(___2847) && ___4706.m_vzValueLocations[___2844 / 2].size() == size_t(___2847) && ___4706.m_vzValueLocations[___2844 - 1].size() == size_t(___2847)); REQUIRE(___4706.m_vzFieldDataTypes.size() == size_t(___2844)); REQUIRE(___4706.m_vzFieldDataTypes[0].size() == size_t(___2847) && ___4706.m_vzFieldDataTypes[___2844 / 2].size() == size_t(___2847) && ___4706.m_vzFieldDataTypes[___2844 - 1].size() == size_t(___2847)); REQUIRE(___4706.m_vzIsPassive.size() == size_t(___2844)); REQUIRE(___4706.m_vzIsPassive[0].size() == size_t(___2847) && ___4706.m_vzIsPassive[___2844 / 2].size() == size_t(___2847) &&
___4706.m_vzIsPassive[___2844 - 1].size() == size_t(___2847)); REQUIRE(___4706.m_vzShareVarWithZone.size() == size_t(___2844)); REQUIRE(___4706.m_vzShareVarWithZone[0].size() == size_t(___2847) && ___4706.m_vzShareVarWithZone[___2844 / 2].size() == size_t(___2847) && ___4706.m_vzShareVarWithZone[___2844 - 1].size() == size_t(___2847)); ___372 ___2038 = ___4227; ___3945[VAR_ZONE_MIN_MAX_FILE_LOC_TAG] = file.fileLoc(); bool minMaxesMustBeDouble = false; for (___4352 ___4336 = 0; !minMaxesMustBeDouble && ___4336 < ___2844; ++___4336) { for (___4636 zone = 0; !minMaxesMustBeDouble && zone < ___2847; ++zone) { FieldDataType_e ___1361 = (FieldDataType_e)___4706.m_vzFieldDataTypes[___4336][zone]; if (___1361 == FieldDataType_Double || ___1361 == FieldDataType_Int32) minMaxesMustBeDouble = true; } } for (___4352 ___4336 = 0; ___2038 && ___4336 < ___2844; ++___4336) { if (minMaxesMustBeDouble) ___2038 = ___2038 && ___4528<double>(file, VAR_ZONE_MIN_MAX_ARRAY_DESCRIPTION, ___4336, ___2847, &___4706.m_vzMinMaxes[___4336][0], ___944 / 2); else ___2038 = ___2038 && ___4528<float>(file, VAR_ZONE_MIN_MAX_ARRAY_DESCRIPTION, ___4336, ___2847, &___4706.m_vzMinMaxes[___4336][0], ___944 / 2); } ___3945[___4393] = file.fileLoc(); for (___4352 ___4336 = 0; ___4336 < ___2844; ___4336++) ___2038 = ___2038 && ___4563<uint8_t, false, 0>(file, ___4392, ___4336, ___2847, &___4706.m_vzValueLocations[___4336][0]); ___3945[___4384] = file.fileLoc(); for (___4352 ___4336 = 0; ___4336 < ___2844; ___4336++) ___2038 = ___2038 && ___4563<uint8_t, false, 0>(file, ___4383, ___4336, ___2847, &___4706.m_vzFieldDataTypes[___4336][0]); ___3945[___4387] = file.fileLoc(); for (___4352 ___4336 = 0; ___4336 < ___2844; ___4336++) ___2038 = ___2038 && ___4563<uint8_t, false, 0>(file, ___4386, ___4336, ___2847, &___4706.m_vzIsPassive[___4336][0]); ___3945[___4390] = file.fileLoc(); for (___4352 ___4336 = 0; ___4336 < ___2844; ___4336++) ___2038 = ___2038 && ___4563<int32_t, false, 0>(file, ___4389, ___4336, ___2847, &___4706.m_vzShareVarWithZone[___4336][0]); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 writeDataSetHeaders( FileWriterInterface&          szpltFile, uint32_t                      fileVersion, ___372                     dataSetIsAvailable, std::string const&            dataSetTitle, ___4352                    ___2844, ___4636                   ___2847, ___3946&                  headerTagMap, ___4707 const&        ___4706, ___1390 const&           szpltZoneHeaderFileLocs, ___934& ___933) { REQUIRE(szpltFile.___2040()); if (dataSetIsAvailable) { REQUIRE(___2844>0); REQUIRE(___4706.m_varNames.size() == size_t(___2844));
REQUIRE(___4706.m_varNames[0].size() > 0 && ___4706.m_varNames[___2844 / 2].size() > 0 && ___4706.m_varNames[___2844 - 1].size() > 0); REQUIRE(___2847>0); REQUIRE(___4706.m_zoneNames.size() == size_t(___2847)); REQUIRE(___4706.m_zoneNames[0].size() > 0 && ___4706.m_zoneNames[___2847 / 2].size() > 0 && ___4706.m_zoneNames[___2847 - 1].size() > 0); REQUIRE(szpltZoneHeaderFileLocs.size() == size_t(___2847)); REQUIRE(VALID_FILE_LOC(szpltZoneHeaderFileLocs[0]) && VALID_FILE_LOC(szpltZoneHeaderFileLocs[___2847 / 2]) && VALID_FILE_LOC(szpltZoneHeaderFileLocs[___2847 - 1])); REQUIRE(___4706.m_vzMinMaxes.size() == size_t(___2844)); REQUIRE(___4706.m_vzMinMaxes[0].size() == size_t(___2847) && ___4706.m_vzMinMaxes[___2844 / 2].size() == size_t(___2847) && ___4706.m_vzMinMaxes[___2844 - 1].size() == size_t(___2847)); REQUIRE(___4706.m_vzValueLocations.size() == size_t(___2844)); REQUIRE(___4706.m_vzValueLocations[0].size() == size_t(___2847) && ___4706.m_vzValueLocations[___2844 / 2].size() == size_t(___2847) && ___4706.m_vzValueLocations[___2844 - 1].size() == size_t(___2847)); REQUIRE(___4706.m_vzValueLocations[0][0] < ___4329 && ___4706.m_vzValueLocations[___2844 / 2][___2847 / 2] < ___4329 && ___4706.m_vzValueLocations[___2844 - 1][___2847 - 1] < ___4329); REQUIRE(___4706.m_vzFieldDataTypes.size() == size_t(___2844)); REQUIRE(___4706.m_vzFieldDataTypes[0].size() == size_t(___2847) && ___4706.m_vzFieldDataTypes[___2844 / 2].size() == size_t(___2847) && ___4706.m_vzFieldDataTypes[___2844 - 1].size() == size_t(___2847)); REQUIRE(___4706.m_vzFieldDataTypes[0][0] < ___1367 && ___4706.m_vzFieldDataTypes[___2844 / 2][___2847 / 2] < ___1367 && ___4706.m_vzFieldDataTypes[___2844 - 1][___2847 - 1] < ___1367); } ___372 ___2038 = ___4227; try { uint64_t initialFileHeaderLoc = szpltFile.fileLoc(); ___2038 = ___2038 && writeInitialDataSetHeader(szpltFile, headerTagMap); ___2038 = ___2038 && writePerDataSetFileHeader(szpltFile, headerTagMap, dataSetTitle.c_str()); ___2038 = ___2038 && ___4543(szpltFile, fileVersion, headerTagMap, ___2847, szpltZoneHeaderFileLocs, ___4706); ___2038 = ___2038 && ___4541(szpltFile, headerTagMap, ___2844, ___4706); ___2038 = ___2038 && ___4542(szpltFile, headerTagMap, ___2844, ___2847, ___4706); uint64_t finalFileLoc = szpltFile.fileLoc(); ___2038 = ___2038 && szpltFile.___3460(initialFileHeaderLoc); ___2038 = ___2038 && writeInitialDataSetHeader(szpltFile, headerTagMap); ___2038 = ___2038 && szpltFile.___3460(finalFileLoc);
 #ifdef PROFILE_FILE_ACCESS
if (___2038) { FileStreamWriter* fileWriter = dynamic_cast<FileStreamWriter*>(&szpltFile); if (fileWriter) ___933.___7(fileWriter->statistics().___2781); }
 #else
___4279(___933);
 #endif
} catch(std::bad_alloc const&) { ___2038 = ___1184("Out of memory while writing file header."); } catch(...) { ___2038 = ___1184("Unrecoverable error while writing file header."); } return ___2038; } ___372 ___4484( FileWriterInterface& file, uint32_t             numAuxData) { REQUIRE(file.___2040()); ___372 ___2038 = ___4227; if (file.___2001()) ___2038 = writeValue<uint32_t, false, 0>(file, SZPLT_AUX_DATA_MARKER_DESCRIPTION, SZPLT_AUX_DATA_MARKER); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, ___233, numAuxData); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 writeAuxDataItem( FileWriterInterface& file, AuxDataLocation_e    auxDataLocation, ___1170           auxDataEntity, char const*          itemName, AuxDataType_e        itemType, char const*          itemValueString) { return writeValue<uint8_t, false, 0>(file, ___252, static_cast<uint8_t>(auxDataLocation)) && writeValue<uint32_t, false, 0>(file, ___239, static_cast<uint32_t>(auxDataEntity)) && writeValue<uint32_t, false, 0>(file, ___262, static_cast<uint32_t>(strlen(itemName))) && ___4544(file, ___261, itemName) && writeValue<uint8_t, false, 0>(file, ___268, static_cast<uint8_t>(itemType)) && writeValue<uint32_t, false, 0>(file, ___272, static_cast<uint32_t>(strlen(itemValueString))) && ___4544(file, ___271, itemValueString); } namespace { uint32_t countRetainedAuxDataItems(___264 auxData, ___37& ___36) { uint32_t ___3359 = 0; if (auxData) { int32_t ___2813 = ___36.___247(auxData); for (int32_t index = 1; index <= ___2813; ++index) { char* itemName = 0; ___90 itemValue = 0; AuxDataType_e itemType; ___372 ___3362; ___36.___243(auxData, index, &itemName, &itemValue, &itemType, &___3362); if (___3362) ++___3359; ___36.___3818(&itemName); ___36.___3818(reinterpret_cast<char**>(&itemValue)); } } return ___3359; } uint32_t countAuxData( ___37&      ___36, ItemSetIterator& varIter, ItemSetIterator& zoneIter) { uint32_t numAuxData = 0; if (___36.___894()) { numAuxData = countRetainedAuxDataItems(___36.___235(), ___36); varIter.reset(); while (varIter.hasNext()) { ___4352 const datasetVar = varIter.next(); if (!___36.___4353(datasetVar + 1)) continue; numAuxData += countRetainedAuxDataItems(___36.___273(datasetVar + 1), ___36); } zoneIter.reset(); while (zoneIter.hasNext()) { ___4636 const ___902 = zoneIter.next(); if (!___36.___4638(___902 + 1)) continue; numAuxData += countRetainedAuxDataItems(___36.___274(___902 + 1), ___36); } } return numAuxData; } ___372 ___4483( FileWriterInterface& file, ___37&          ___36, ___264           auxData, AuxDataLocation_e    auxDataLocation, ___1170           auxDataEntity, uint32_t&            numItemsWritten)
{ REQUIRE(file.___2040()); REQUIRE(VALID_REF(auxData)); REQUIRE(VALID_ENUM(auxDataLocation, AuxDataLocation_e)); REQUIRE(auxDataEntity >= 0); int32_t ___2813 = ___36.___247(auxData); numItemsWritten = 0; ___372 ___2038 = ___4227; for (int32_t index = 1; ___2038 && index <= ___2813; ++index) { char* itemName = 0; ___90 itemValue = 0; AuxDataType_e itemType; ___372 ___3362; ___36.___243(auxData, index, &itemName, &itemValue, &itemType, &___3362); ___476(itemType == ___270); if (___3362) { ++numItemsWritten; char const* itemValueString = reinterpret_cast<char const*>(itemValue); ___2038 = writeAuxDataItem(file, auxDataLocation, auxDataEntity, itemName, itemType, itemValueString); } ___36.___3818(&itemName); ___36.___3818(reinterpret_cast<char**>(&itemValue)); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 writeAuxDataItems( FileWriterInterface& file, ___37&          ___36, ItemSetIterator&     varIter, ItemSetIterator&     zoneIter, ___4636          fileZoneOffset) { ___372 ___2038 = ___4227; if (___36.___894()) { ___264 auxData = ___36.___235(); uint32_t numItemsWritten = 0; if (auxData) { ___2038 = ___2038 && ___4483( file, ___36, auxData, ___253, 0, numItemsWritten); } varIter.reset(); ___4352 const baseVar = varIter.baseItem(); while (___2038 && varIter.hasNext()) { ___4352 const datasetVar = varIter.next(); ___4636 const fileVar = datasetVar - baseVar; auxData = ___36.___273(datasetVar + 1); if (auxData) { ___2038 = ___2038 && ___4483( file, ___36, auxData, ___258, fileVar + 1, numItemsWritten); } } zoneIter.reset(); while (___2038 && zoneIter.hasNext()) { ___4636 const ___902 = zoneIter.next(); ___4636 const fileZone = ___902 + fileZoneOffset; if (!___36.___4638(___902 + 1)) continue; auxData = ___36.___274(___902 + 1); if (auxData) { ___2038 = ___2038 && ___4483( file, ___36, auxData, ___259, fileZone + 1, numItemsWritten); } } } return ___2038; } ___372 ___4482( FileWriterInterface& file, ___37&          ___36, ItemSetIterator&     varIter, ItemSetIterator&     zoneIter, ___3946&         headerTagMap) { REQUIRE(file.___2040()); headerTagMap[___241] = file.fileLoc(); uint32_t numAuxData = countAuxData(___36, varIter, zoneIter); ___372 ___2038 = ___4484(file, numAuxData); ___2038 = ___2038 && writeAuxDataItems(file, ___36, varIter, zoneIter, -zoneIter.baseItem()); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4522( FileWriterInterface& file, uint32_t             numGeoms) { REQUIRE(file.___2040()); ___372 ___2038 = ___4227; if (file.___2001()) ___2038 = writeValue<uint32_t, false, 0>(file, SZPLT_GEOMETRY_MARKER_DESCRIPTION, SZPLT_GEOMETRY_MARKER); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, NUM_GEOMS_DESCRIPTION, numGeoms);
ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4523( FileWriterInterface& file, ___37&          ___36, GeomID_t             geomID) { REQUIRE(file.___2040()); uint32_t ___2836 = (uint32_t)___36.___1618(geomID); bool is3D = (___36.___1601(geomID) == CoordSys_Grid3D); ___372 ___2038 = writeValue<uint32_t, false, 0>(file, ___1621, ___2836); for(uint32_t segment = 0; ___2038 && segment < ___2836; ++segment) { uint32_t numPts = (uint32_t)___36.___1617(geomID, static_cast<int32_t>(segment + 1)); ___1103 xPts; ___1103 yPts; ___1103 zPts; ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, ___1620, numPts) && xPts.alloc(static_cast<uint64_t>(numPts)) && yPts.alloc(static_cast<uint64_t>(numPts)); if (is3D) ___2038 = ___2038 && zPts.alloc(static_cast<uint64_t>(numPts)); for(uint32_t i = 0; i < numPts; ++i) { if (is3D) ___36.___1558(geomID, static_cast<int32_t>(segment + 1), static_cast<___2226>(i + 1), &xPts[i], &yPts[i], &zPts[i]); else ___36.___1555(geomID, static_cast<int32_t>(segment + 1), static_cast<___2226>(i + 1), &xPts[i], &yPts[i]); } ___2038 = ___2038 && ___4563<double, false, 0>(file, ___1653, segment, static_cast<size_t>(numPts), xPts.data()) && ___4563<double, false, 0>(file, ___1655, segment, static_cast<size_t>(numPts), yPts.data()); if (is3D) ___2038 && ___4563<double, false, 0>(file, ___1658, segment, static_cast<size_t>(numPts), zPts.data()); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { uint32_t countGeoms(___37& ___36) { uint32_t numGeoms = 0; for (GeomID_t geomID = ___36.___1590(); geomID != ___4036; geomID = ___36.___1599(geomID)) { if (___36.___1604(geomID) != GeomType_Image) ++numGeoms; } return numGeoms; } ___372 ___4521( FileWriterInterface& file, ___37&          ___36, GeomID_t             geomID, int32_t              fileZoneOffset) { REQUIRE(file.___2040()); double ___4574; double ___4591; double ___4715; ___36.___1589(geomID, &___4574, &___4591, &___4715); ___372 ___2038 = writeValue<double, false, 0>(file, ___1652, ___4574) && writeValue<double, false, 0>(file, ___1654, ___4591) && writeValue<double, false, 0>(file, ___1657, ___4715); uint8_t ___3160 = (uint8_t)___36.___1601(geomID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___1625, ___3160); uint8_t ___2003 = ___36.___1608(geomID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___1609, ___2003); ___4636 zone = ___36.___1605(geomID); ___2038 = ___2038 && writeValue<int32_t, false, 0>(file, ___1656, zone + fileZoneOffset); uint16_t color = (uint16_t)___36.___1592(geomID); ___2038 = ___2038 && writeValue<uint16_t, false, 0>(file, ___1569, color); uint16_t ___1409 = (uint16_t)___36.___1594(geomID);
___2038 = ___2038 && writeValue<uint16_t, false, 0>(file, ___1580, ___1409); uint8_t ___2021 = (uint8_t)___36.___1595(geomID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___1610, ___2021); uint8_t ___1650 = (uint8_t)___36.___1604(geomID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, GEOM_GEOM_TYPE, ___1650); uint8_t ___2264 = (uint8_t)___36.___1596(geomID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___1611, ___2264); double ___2987 = ___36.___1600(geomID); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1623, ___2987); double ___2290 = ___36.___1597(geomID); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1612, ___2290); if (___1650 == (uint8_t)GeomType_Circle || ___1650 == (uint8_t)GeomType_Ellipse) { uint16_t ___2794 = static_cast<uint16_t>(___36.___1574(geomID)); ___2038 = ___2038 && writeValue<uint16_t, false, 0>(file, ___1619, ___2794); } else { ___2038 = ___2038 && writeValue<uint16_t, false, 0>(file, ___1619, 0); } if (___1650 == (uint8_t)GeomType_LineSegs) { uint8_t arrowheadStyle = (uint8_t)___36.___1565(geomID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___1567, arrowheadStyle); uint8_t arrowheadAttachment = (uint8_t)___36.___1563(geomID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___1561, arrowheadAttachment); double arrowheadSize = ___36.___1564(geomID); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1566, arrowheadSize); double arrowheadAngle = ___36.___1562(geomID); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1560, arrowheadAngle); } else { ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___1567, 0); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___1561, 0); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1566, 0); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1560, 0); } uint8_t geomScope = (uint8_t)___36.___1603(geomID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___1631, geomScope); uint8_t geomClipping = (uint8_t)___36.___1591(geomID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, GEOM_CLIPPING, geomClipping); char* ___2331 = 0; if (___36.___1598(geomID, &___2331) && ___2331 != 0) { uint32_t length = static_cast<uint32_t>(strlen(___2331)); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, ___1614, length); if (length > 0) ___4544(file, ___1613, ___2331); ___36.___3818(&___2331); } else { ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, ___1614, 0);
} switch (___36.___1604(geomID)) { case GeomType_LineSegs: { ___2038 = ___2038 && ___4523(file, ___36, geomID); } break; case GeomType_Rectangle: { double ___4458; double ___1825; ___36.___1626(geomID, &___4458, &___1825); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1628, ___4458) && writeValue<double, false, 0>(file, ___1627, ___1825); } break; case GeomType_Square: { ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1648, ___36.___1647(geomID)); } break; case GeomType_Circle: { ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1606, ___36.___1568(geomID)); } break; case GeomType_Ellipse: { double horizontalAxis; double verticalAxis; ___36.___1575(geomID, &horizontalAxis, &verticalAxis); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___1576, horizontalAxis) && writeValue<double, false, 0>(file, ___1577, verticalAxis); } break; default: ___476(___1303); break; } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 writeGeomItems( FileWriterInterface& file, ___37&          ___36, int32_t              fileZoneOffset) { REQUIRE(file.___2040()); ___372 ___2038 = ___4227; for(GeomID_t geomID = ___36.___1590(); ___2038 && geomID != ___4036; geomID = ___36.___1599(geomID)) { if (___36.___1604(geomID) != GeomType_Image) ___2038 = ___4521(file, ___36, geomID, fileZoneOffset); } return ___2038; } ___372 ___4524( FileWriterInterface& file, ___37&          ___36, ___4636          ___341, ___3946&         headerTagMap) { REQUIRE(file.___2040()); headerTagMap[___1579] = file.fileLoc(); uint32_t numGeoms = countGeoms(___36); ___372 ___2038 = ___4522(file, numGeoms); ___2038 = ___2038 && writeGeomItems(file, ___36, -___341); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { uint32_t countTexts(___37& ___36) { uint32_t numTexts = 0; for (TextID_t textID = ___36.___4088(); textID != ___4036; textID = ___36.___4094(textID)) ++numTexts; return numTexts; } ___372 ___4547( FileWriterInterface& file, uint32_t             numTexts) { REQUIRE(file.___2040()); ___372 ___2038 = ___4227; if (file.___2001()) ___2038 = writeValue<uint32_t, false, 0>(file, SZPLT_TEXT_MARKER_DESCRIPTION, SZPLT_TEXT_MARKER); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, NUM_TEXTS_DESCRIPTION, numTexts); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4546( FileWriterInterface& file, ___37&          ___36, TextID_t             textID, int32_t              fileZoneOffset) { REQUIRE(file.___2040()); double ___4574 = 0.0; double ___4591 = 0.0; double ___4715 = 0.0; ___36.___4086(textID, &___4574, &___4591, &___4715); ___372 ___2038 = writeValue<double, false, 0>(file, ___4137, ___4574) && writeValue<double, false, 0>(file, ___4138, ___4591) &&
writeValue<double, false, 0>(file, ___4141, ___4715); uint16_t ___4081 = (uint16_t)___36.___4090(textID); ___2038 = ___2038 && writeValue<uint16_t, false, 0>(file, ___4083, ___4081); uint16_t ___4060 = (uint16_t)___36.___4065(textID); ___2038 = ___2038 && writeValue<uint16_t, false, 0>(file, ___4061, ___4060); uint16_t ___4062 = (uint16_t)___36.___4066(textID); ___2038 = ___2038 && writeValue<uint16_t, false, 0>(file, ___4063, ___4062); double ___4072 = ___36.___4067(textID); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___4073, ___4072); double ___4074 = ___36.___4068(textID); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___4075, ___4074); uint8_t ___4079 = (uint8_t)___36.___4069(textID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, TEXT_BOX_TYPE, ___4079); uint8_t ___4044 = (uint8_t)___36.___4085(textID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___4045, ___4044); double ___4057 = ___36.___4087(textID); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___4058, ___4057); uint8_t ___4080 = (uint8_t)___36.___4089(textID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, TEXT_CLIPPING, ___4080); double ___4104 = ___36.___4091(textID); ___2038 = ___2038 && writeValue<double, false, 0>(file, TEXT_HEIGHT, ___4104); double ___4108 = ___36.___4092(textID); ___2038 = ___2038 && writeValue<double, false, 0>(file, ___4109, ___4108); uint8_t ___4116 = (uint8_t)___36.___4095(textID); ___2038 = ___2038 &&  writeValue<uint8_t, false, 0>(file, ___4117, ___4116); uint8_t ___4120 = (uint8_t)___36.___4097(textID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___4121, ___4120); uint8_t ___4125 = (uint8_t)___36.___4098(textID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___4126, ___4125); char* ___4127 = 0; ___36.___4099(textID, &___4127); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, ___4129, static_cast<uint32_t>(strlen(___4127))); if (strlen(___4127) > 0) ___2038 = ___2038 && ___4544(file, ___4128, ___4127); ___36.___3818(&___4127); char* ___4130 = ___36.___4100(textID); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, ___4132, static_cast<uint32_t>(strlen(___4130))); if (strlen(___4130) > 0) ___2038 = ___2038 && ___4544(file, ___4131, ___4130); ___36.___3818(&___4130); uint8_t ___4133 = (uint8_t)___36.___4101(textID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___4134, ___4133); uint8_t ___4135 = (uint8_t)___36.___4102(textID);
___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___4136, ___4135); int32_t ___4139 = (int32_t)___36.___4103(textID); ___2038 = ___2038 && writeValue<int32_t, false, 0>(file, ___4140, ___4139 + fileZoneOffset); uint8_t ___4106 = (uint8_t)___36.___4106(textID); ___2038 = ___2038 && writeValue<uint8_t, false, 0>(file, ___4107, ___4106); char* ___4110 = 0; if (___36.___4093(textID, &___4110) && ___4110 != 0) { ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, ___4112, static_cast<uint32_t>(strlen(___4110))); if (strlen(___4110) > 0) ___2038 = ___2038 && ___4544(file, ___4111, ___4110); ___36.___3818(&___4110); } else { ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, ___4112, 0); } ___36.___3818(&___4110); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 writeTextItems( FileWriterInterface& file, ___37&          ___36, int32_t              fileZoneOffset) { ___372 ___2038 = ___4227; for (TextID_t textID = ___36.___4088(); ___2038 && textID != ___4036; textID = ___36.___4094(textID)) ___2038 = ___4546(file, ___36, textID, fileZoneOffset); return ___2038; } ___372 ___4548( FileWriterInterface& file, ___37&          ___36, ___4636          ___341, ___3946&         headerTagMap) { REQUIRE(file.___2040()); headerTagMap[___4084] = file.fileLoc(); uint32_t numTexts = countTexts(___36); ___372 ___2038 = ___4547(file, numTexts); ___2038 = ___2038 && writeTextItems(file, ___36, -___341); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { uint32_t countCustomLabelSets(___37& ___36) { uint32_t numCustomLabelSets = 0; if (___36.___894()) numCustomLabelSets = ___36.___795(); return numCustomLabelSets; } ___372 ___4504( FileWriterInterface& file, uint32_t             numCustomLabelSets) { REQUIRE(file.___2040()); ___372 ___2038 = ___4227; if (file.___2001()) ___2038 = writeValue<uint32_t, false, 0>(file, SZPLT_CUSTOM_LABELS_MARKER_DESCRIPTION, SZPLT_CUSTOM_LABELS_MARKER); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, ___791, numCustomLabelSets); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4503( FileWriterInterface& file, ___37&          ___36, int32_t              customLabelNum) { REQUIRE(file.___2040()); ___3840 ___2170 = 0; ___3817 customLabels; ___372 ___2038 = ___36.___794(&___2170, customLabelNum); int32_t numLabels = 0; if (___2038) { numLabels = (int32_t)___36.___3833(___2170); ___2038 = ___2038 && customLabels.alloc(static_cast<uint64_t>(numLabels)) && writeValue<uint32_t, false, 0>(file, ___2821, numLabels);
} for(int32_t i = 1; ___2038 && i <= ___36.___3833(___2170); ++i) { char* label = ___36.___3834(___2170, i); customLabels[i - 1] = label; ___36.___3818(&label); } ___2038 = ___2038 && ___4545(file, ___792, (size_t)numLabels, customLabels); if (___2170) ___36.___3828(&___2170); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 writeCustomLabelSets( FileWriterInterface& file, ___37&          ___36) { ___372 ___2038 = ___4227; uint32_t numCustomLabelSets = countCustomLabelSets(___36); for (uint32_t customLabelNum = 1; ___2038 && customLabelNum <= numCustomLabelSets; ++customLabelNum) ___2038 = ___4503(file, ___36, static_cast<int32_t>(customLabelNum)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4502( FileWriterInterface& file, ___37&          ___36, ___3946&         headerTagMap) { REQUIRE(file.___2040()); headerTagMap[___793] = file.fileLoc(); uint32_t numCustomLabelSets = countCustomLabelSets(___36); ___372 ___2038 = ___4504(file, numCustomLabelSets); ___2038 = ___2038 && writeCustomLabelSets(file, ___36); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } }
 #if defined DO_SUBZONE_HISTOGRAM || defined DO_ITEMANDSUBZONE_HISTOGRAM
namespace { ___372 ___2882( std::string const& pltFileName, ___4636        zone, char const*        ___2505, FILE*&             fileHandle) { REQUIRE(!pltFileName.empty()); REQUIRE(zone>=0); REQUIRE(VALID_NON_ZERO_LEN_STR(___2505)); REQUIRE(fileHandle==NULL); char histogramFileName[1000]; sprintf(histogramFileName, "%s.zone%" PRIu64 ".histogram.csv", pltFileName.c_str(), uint64_t(zone+1)); ___372 ___2038 = ___4227; fileHandle = tecplot::filesystem::fileOpen(histogramFileName, ___2505); if (fileHandle == NULL) ___2038 = ___1184("Cannot open histogram file %s", histogramFileName); return ___2038; } }
 #endif
 #ifdef DO_SUBZONE_HISTOGRAM
___372 OutputSubzoneHistograms( char const*       szpltFileName, ___37&       ___36, ___4636       zone, boost::shared_ptr<___1348 const> ___1347) { ___372 ___2038 = ___4227; REQUIRE(VALID_NON_ZERO_LEN_STR(szpltFileName)); REQUIRE(VALID_REF(___1347.get())); ItemAddress64::SubzoneOffset_t const ___2784 = ___1347->___2784(); ItemAddress64::SubzoneOffset_t const ___2824 = ___1347->___2824(); SubzoneOffsetArray cszRefsByNszHistogram; SubzoneOffsetArray nszRefsByCszHistogram; ___2038 = ___2038 && cszRefsByNszHistogram.alloc(___2784+1, ItemAddress64::SubzoneOffset_t(0)); ___2038 = ___2038 && nszRefsByCszHistogram.alloc(___2824+1, ItemAddress64::SubzoneOffset_t(0)); SubzoneOffsetSetArray cszRefsByNsz; ___2038 = ___2038 && cszRefsByNsz.alloc(___2824); if (___2038) { ___2730 ___2724 = boost::make_shared<___2725>(&___36, zone+1); if (!___2724->___2066()) return ___1303; CellNodeIndex_t const numNodesPerCell = ___1347->getNumNodesPerCell(section); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2784; ___467++) { SubzoneOffsetSet nszRefs; ItemAddress64::ItemOffset_t const ___2783 = ___1347->___2783(___467); for (ItemAddress64::ItemOffset_t cszOffset = 0; cszOffset < ___2783; cszOffset++) { ItemAddress64 const ___686(0, ___467, cszOffset); ___463 const datasetCell = ___1347->___4608(___686); ___476(datasetCell<___1347->___1765()); for (CellNodeIndex_t nOffset = 0; nOffset < numNodesPerCell; nOffset++) { ___2719 const datasetNode = ___2724->___1762(datasetCell+1, nOffset+1) - 1; ___476(datasetNode<___1347->___1767()); ItemAddress64 const ___2760 = ___1347->___3925(datasetNode); ItemAddress64::SubzoneOffset_t const ___2735 = ___2760.subzoneOffset(); nszRefs.insert(___2735); cszRefsByNsz[___2735].insert(___467); } } if (___2038) { size_t const numNszRefs = nszRefs.size(); ___476(numNszRefs<nszRefsByCszHistogram.size()); nszRefsByCszHistogram[numNszRefs]++; } } for (ItemAddress64::SubzoneOffset_t ___2735 = 0; ___2735 < ___2824; ___2735++) { size_t const numCszRefs = cszRefsByNsz[___2735].size(); ___476(numCszRefs<cszRefsByNszHistogram.size()); cszRefsByNszHistogram[numCszRefs]++; } } if (___2038) { FILE* histogramFile = NULL; ___2038 = ___2882(szpltFileName, zone, "wt", histogramFile); if (___2038) { fprintf(histogramFile,"\nZone %" PRIu64 " (%" PRIu64 " cells, %" PRIu64 " cell subzones, %" PRIu64 " nodes, %" PRIu64 " node subzones)\n", uint64_t(zone+1), uint64_t(___1347->___1765()), uint64_t(___2784), uint64_t(___1347->___1767()), uint64_t(___2824)); fprintf(histogramFile,"\nNszs per Cell Subzone Histogram\n"); fprintf(histogramFile,"\nNumNodeSubzonesReferenced,Count\n"); for (ItemAddress64::SubzoneOffset_t nodeSubzoneCount = 0; nodeSubzoneCount <= ___2824; nodeSubzoneCount++)
if (nszRefsByCszHistogram[nodeSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(nodeSubzoneCount), uint64_t(nszRefsByCszHistogram[nodeSubzoneCount])); fprintf(histogramFile,"\nCszs per Node Subzone Histogram\n"); fprintf(histogramFile,"\nNumCellSubzonesReferenced,Count\n"); for (ItemAddress64::SubzoneOffset_t cellSubzoneCount = 0; cellSubzoneCount <= ___2784; cellSubzoneCount++) if (cszRefsByNszHistogram[cellSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(cellSubzoneCount), uint64_t(cszRefsByNszHistogram[cellSubzoneCount])); } ___4196(histogramFile); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #endif
 #ifdef DO_ITEMANDSUBZONE_HISTOGRAM
___372 OutputItemAndSubzoneHistograms( char const*       szpltFileName, ___37&       ___36, ___4636       zone, boost::shared_ptr<___1348 const> ___1347) { ___372 ___2038 = ___4227; REQUIRE(VALID_NON_ZERO_LEN_STR(szpltFileName)); REQUIRE(VALID_REF(___1347.get())); ___463 const ___2782 = ___1347->___1765(); ___2719 const ___2822 = ___1347->___1767(); ___462 cellRefsByNszHistogram; ___2718 nodeRefsByCszHistogram; ___2038 = ___2038 && cellRefsByNszHistogram.alloc(___2782+1, ___463(0)); ___2038 = ___2038 && nodeRefsByCszHistogram.alloc(___2822+1, ___2719(0)); typedef std::set<___463> CellIndexSet; ___2241<CellIndexSet> cellsRefsByNsz; ___2038 = ___2038 && cellsRefsByNsz.alloc(___2822); if (___2038) { ___2730 ___2724 = boost::make_shared<___2725>(&___36, zone+1); if (!___2724->___2066()) return ___1303; CellNodeIndex_t const numNodesPerCell = ___1347->getNumNodesPerCell(section); ItemAddress64::SubzoneOffset_t const ___2784 = ___1347->___2784(); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2784; ___467++) { CellIndexSet nodeRefs; ItemAddress64::ItemOffset_t const ___2783 = ___1347->___2783(___467); for (ItemAddress64::ItemOffset_t cszOffset = 0; cszOffset < ___2783; cszOffset++) { ItemAddress64 const ___686(0, ___467, cszOffset); ___463 const datasetCell = ___1347->___4608(___686); ___476(datasetCell < ___2782); for (CellNodeIndex_t nOffset = 0; nOffset < numNodesPerCell; nOffset++) { ___2719 const datasetNode = ___2724->___1762(datasetCell+1, nOffset+1) - 1; ___476(datasetNode<___2822); ItemAddress64 const ___2760 = ___1347->___3925(datasetNode); ItemAddress64::SubzoneOffset_t const ___2735 = ___2760.subzoneOffset(); nodeRefs.insert(datasetNode); cellsRefsByNsz[___2735].insert(datasetCell); } } if (___2038) { size_t const numNodeRefs = nodeRefs.size(); ___476(numNodeRefs < nodeRefsByCszHistogram.size()); nodeRefsByCszHistogram[numNodeRefs]++; } } ItemAddress64::SubzoneOffset_t const ___2824 = ___1347->___2824(); for (ItemAddress64::SubzoneOffset_t ___2735 = 0; ___2735 < ___2824; ___2735++) { size_t const numCellRefs = cellsRefsByNsz[___2735].size(); ___476(numCellRefs < cellRefsByNszHistogram.size()); cellRefsByNszHistogram[numCellRefs]++; } } if (___2038) { FILE* histogramFile = NULL; ___2038 = ___2882(szpltFileName, zone, "at", histogramFile); if (___2038) { fprintf(histogramFile,"\nZone %" PRIu64 " (%" PRIu64 " cells, %" PRIu64 " cell subzones, %" PRIu64 " nodes, %" PRIu64 " node subzones)\n", uint64_t(zone+1), uint64_t(___1347->___1765()), uint64_t(___2782), uint64_t(___1347->___1767()), uint64_t(___2822)); fprintf(histogramFile,"\nNodes per Cell Subzone Histogram\n"); fprintf(histogramFile,"\nNumNodesReferenced,Count\n"); for (ItemAddress64::SubzoneOffset_t nodeSubzoneCount = 0; nodeSubzoneCount <= ___2822; nodeSubzoneCount++)
if (nodeRefsByCszHistogram[nodeSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(nodeSubzoneCount), uint64_t(nodeRefsByCszHistogram[nodeSubzoneCount])); fprintf(histogramFile,"\nCells per Node Subzone Histogram\n"); fprintf(histogramFile,"\nNumCellsReferenced,Count\n"); for (ItemAddress64::SubzoneOffset_t cellSubzoneCount = 0; cellSubzoneCount <= ___2782; cellSubzoneCount++) if (cellRefsByNszHistogram[cellSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(cellSubzoneCount), uint64_t(cellRefsByNszHistogram[cellSubzoneCount])); } ___4196(histogramFile); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #endif
namespace { inline ___372 ___477(___37& ___36) { ___372 ___2038 = ___4227; if (!___36.___894() && ___36.___1590() == ___4036 && ___36.___4088() == ___4036) ___2038 = ___1184("Cannot export dataset: The active frame has no data, texts or geoms to export."); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { inline ___372 ___479(___37& ___36, ___4352  ___4336) { REQUIRE(___36.___894()); REQUIRE(___4336<___36.___888()); ___372 ___2038 = ___4227; if (!___36.___4353(___4336 + 1)) ___2038 = ___1184("Cannot export dataset: Variable %" PRIu64 " is disabled and cannot be exported.", uint64_t(___4336 + 1)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { inline ___372 ___481(___37& ___36, ___4636 zone) { REQUIRE(___36.___894()); REQUIRE(zone < ___36.___889()); ___372 ___2038 = ___4227; if (!___36.___4638(zone + 1)) ___2038 = ___1184("Cannot export dataset: Zone %" PRIu64 " is disabled and cannot be exported.", uint64_t(zone + 1)); else if ((___4646(___36, zone) || ___4643(___36, zone)) && !___4642(___36, zone) && !___4644(___36, zone)) ___2038 = ___1184("Cannot export dataset: Zone %" PRIu64 " is unsupported type", uint64_t(zone + 1)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { ___372 ___478( ___37&      ___36, ItemSetIterator& varIter, ItemSetIterator& zoneIter, DataFileType_e   ___842) { REQUIRE(VALID_ENUM(___842, DataFileType_e)); ___372 ___2038 = ___477(___36); if (___2038) { ___4352 const numVarsToWrite = varIter.___2813(); varIter.reset(); while (___2038 && varIter.hasNext()) ___2038 = ___479(___36, varIter.next()); ___372 hasVolumeZones     = ___1303; ___372 atLeastOneZoneIsFE = ___1303; zoneIter.reset(); while (___2038 && zoneIter.hasNext()) { ___4636 const ___902 = zoneIter.next(); if (___4646(___36, ___902)) hasVolumeZones = ___4227; if (___36.___4640(___902 + 1)) atLeastOneZoneIsFE = ___4227; ___2038 = ___481(___36, ___902); } if (___2038 && hasVolumeZones) { if ((___842 != ___846) && (numVarsToWrite < 3                 || !___36.___4353(1) || !___36.___4353(2) || !___36.___4353(3))) { ___2038 = ___1303; ___1184("Err:  Variables 1,2 and 3 are needed to calculate subzones and must be enabled to export a szplt file"); } else if (___36.___1511() == ___3116) { if (___842 != ___846 && atLeastOneZoneIsFE && (___36.___4345('X') != 1 || ___36.___4345('Y') != 2 || ___36.___4345('Z') != 3)) { ___1930("Warning:\n" "Calculations to determine subzones for szl zones assumes the first 3 variables in the dataset are X,Y, and Z.\n"
"The X,Y,Z axis assignments in the current frame are not the first 3 variables and thus the resulting subzone distribution may not be optimal"); } } else if (___842 != ___846) { ___1930("Warning:\n" "Calculations to determine subzones for szl zones assumes the first 3 variables in the dataset are X,Y, and Z.\n" "If the first 3 variables in the current dataset do not represent X,Y, and Z the resulting subzone distribution may not be optimal"); } } } return ___2038; } } namespace { ___372 ___25( ___1390& szpltZoneHeaderFileLocs, ___37&   ___36, ___4636   ___2847, bool          fillWithValidValues) { szpltZoneHeaderFileLocs.___935(); return IMPLICATION(___36.___894(), szpltZoneHeaderFileLocs.alloc( ___2847, fillWithValidValues ? ___1391(0): ___330)); } } namespace { ___3946 initializedHeaderTagMap( uint32_t                    fileVersion, ___4636                 numZonesToWrite, ___4352                  numVarsToWrite, uint64_t                    numPartitionFiles, ___1843 const&                  maxIJKSubzoneSize, ItemAddress64::ItemOffset_t maxFESubzoneSize) { REQUIRE(fileVersion == 105 || fileVersion == 231 || fileVersion == 232); ___3946 headerTagMap = DATASET_HEADER_TAG_MAP_V105_INITIALIZER; if (fileVersion > 105) { ___3946 const headerTagMap_v231 = DATASET_HEADER_TAG_MAP_V231_INITIALIZER; headerTagMap.insert(headerTagMap_v231.begin(), headerTagMap_v231.end()); } headerTagMap[___2850]           = static_cast<uint64_t>(numZonesToWrite); headerTagMap[___2846]            = static_cast<uint64_t>(numVarsToWrite); headerTagMap[SUBZONE_MAX_I_SIZE_TAG]  = static_cast<uint64_t>(maxIJKSubzoneSize.i()); headerTagMap[SUBZONE_MAX_J_SIZE_TAG]  = static_cast<uint64_t>(maxIJKSubzoneSize.___2104()); headerTagMap[SUBZONE_MAX_K_SIZE_TAG]  = static_cast<uint64_t>(maxIJKSubzoneSize.___2133()); headerTagMap[SUBZONE_MAX_FE_SIZE_TAG] = static_cast<uint64_t>(maxFESubzoneSize); if (numPartitionFiles > 0) headerTagMap[NUM_PARTITION_FILES_TAG] = numPartitionFiles; return headerTagMap; } } ___372 ___1240( ___37&                   ___36, FileWriterInterface&          szpltFile, ___1386 const&        ___1385, ___372                     includeRevisionNumber, DataSetWriter&                dataSetWriter, ___3502                        vars, ___3502                        ___4671, ___934& ___933) { REQUIRE(szpltFile.___2040()); REQUIRE(___1385.getFileVersion() == 105 || ___1385.getFileVersion() == 231 || ___1385.getFileVersion() == 232); REQUIRE(VALID_REF_OR_NULL(vars)); REQUIRE(VALID_REF_OR_NULL(___4671));
 #if !defined TECIOMPI
REQUIRE(std::atomic<double>().is_lock_free());
 #endif
szpltFile.___3495(___1385.___2001()); szpltFile.setDataFileType(___1385.___842()); ItemSetIterator varIter(___36, ___36.___894() ? ___36.___888() : 0, vars); ItemSetIterator zoneIter(___36, ___36.___894() ? ___36.___889() : 0, ___4671); ___372 ___2038 = ___478(___36, varIter, zoneIter, szpltFile.___842()); if (___2038) { ___36.___3780("Exporting szplt file...", ___4227 , ___4227/*___3581*/); ___2038 = ___2038 && ___36.___3770(0); ___4352 numVarsToWrite = 0; ___4636 numZonesToWrite = 0; uint64_t numPartitionFiles = 0; if (___36.___894()) { numVarsToWrite = varIter.___2813(); numZonesToWrite = zoneIter.___2813(); numPartitionFiles = static_cast<uint64_t>(___36.datasetGetNumPartitionFiles()); } ___1390 szpltZoneHeaderFileLocs; ___2038 = ___2038 && ___25(szpltZoneHeaderFileLocs, ___36, numZonesToWrite, true); try { ___3946 headerTagMap = initializedHeaderTagMap( ___1385.getFileVersion(), numZonesToWrite, numVarsToWrite, numPartitionFiles, ___1385.___1756(), ___1385.___1755()); ___2038 = ___2038 && ___4516(szpltFile, SZPLT_FILE_TYPE, ___1385.getFileVersion(), includeRevisionNumber, 0); ___4482(szpltFile, ___36, varIter, zoneIter, headerTagMap) && ___4524(szpltFile, ___36, zoneIter.baseItem(), headerTagMap) && ___4548(szpltFile, ___36, zoneIter.baseItem(), headerTagMap) && ___4502(szpltFile, ___36, headerTagMap); ___2038 = ___2038 && ___25(szpltZoneHeaderFileLocs, ___36, numZonesToWrite, false) && dataSetWriter.writeDataSet(szpltFile, ___1385.getFileVersion(), szpltZoneHeaderFileLocs) && szpltFile.seekToFileEnd(); if (___2038) { uint64_t dataSetHeaderLocation = szpltFile.fileLoc(); ___372 dataSetIsAvailable = ___36.___894(); std::string dataSetTitle; if (dataSetIsAvailable) { char* ___4178 = 0; ___36.datasetGetTitle(&___4178); dataSetTitle = ___4178; ___36.___3818(&___4178); } ___2038 = ___2038 && writeDataSetHeaders(szpltFile, ___1385.getFileVersion(), dataSetIsAvailable, dataSetTitle, numVarsToWrite, numZonesToWrite, headerTagMap, dataSetWriter.___4706(), szpltZoneHeaderFileLocs, ___933) && szpltFile.___3461() && ___4516(szpltFile, SZPLT_FILE_TYPE, ___1385.getFileVersion(), includeRevisionNumber, dataSetHeaderLocation); }
 #ifdef PROFILE_FILE_ACCESS
FileStreamWriter* fileWriter = dynamic_cast<FileStreamWriter*>(&szpltFile); if (fileWriter) ___933.___7(fileWriter->statistics().___2781);
 #endif
} catch (std::bad_alloc const&) { ___2038 = ___1184("Out of memory while writing file."); } catch (std::runtime_error const& e) { std::ostringstream ___2893; ___2893 << "Error encountered while writing file: " << e.what(); ___2038 = ___1184(___2893.str().c_str()); } catch (...) { ___2038 = ___1184("Unrecoverable error while writing file."); } ___36.___3771(); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 writeIntermediateFiles( ___37&                   ___36, FileWriterInterface&          headerFile, FileWriterInterface&          zoneFile, FileWriterInterface&          auxDataFile, FileWriterInterface&          geometryFile, FileWriterInterface&          textFile, FileWriterInterface&          customLabelsFile, ___1386 const&        ___1385, uint64_t                      numHeadersInFile, uint32_t                      numAuxDataInFile, uint32_t                      numGeomsInFile, uint32_t                      numTextsInFile, uint32_t                      numCustomLabelsInFile, ___372                     includeRevisionNumber, DataSetWriter&                dataSetWriter, ___3502                        vars, ___3502                        ___4671, int32_t                       fileZoneOffset, ___934& ___933) { REQUIRE(headerFile.___2040()); REQUIRE(zoneFile.___2040()); REQUIRE(auxDataFile.___2040()); REQUIRE(geometryFile.___2040()); REQUIRE(textFile.___2040()); REQUIRE(customLabelsFile.___2040()); REQUIRE(___1385.getFileVersion() == 105 || ___1385.getFileVersion() == 231 || ___1385.getFileVersion() == 232); REQUIRE(VALID_REF_OR_NULL(vars)); REQUIRE(VALID_REF_OR_NULL(___4671));
 #if !defined TECIOMPI
REQUIRE(std::atomic<double>().is_lock_free());
 #endif
ItemSetIterator varIter(___36, ___36.___894() ? ___36.___888() : 0, vars); ItemSetIterator zoneIter(___36, ___36.___894() ? ___36.___889() : 0, ___4671); ___372 ___2038 = ___478(___36, varIter, zoneIter, ___1385.___842()); if (___2038) { ___36.___3780("Exporting szplt temp files...", ___4227 , ___4227/*___3581*/); ___2038 = ___2038 && ___36.___3770(0); ___4352 numVarsToWrite = 0; ___4636 numZonesToWrite = 0; uint64_t numPartitionFiles = 0; if (___36.___894()) { numVarsToWrite = varIter.___2813(); numZonesToWrite = zoneIter.___2813(); numPartitionFiles = static_cast<uint64_t>(___36.datasetGetNumPartitionFiles()); } if (numHeadersInFile == 0) ___2038 = ___2038 && writeValue<uint64_t, false, 0>(headerFile, SZPLT_NUM_INTERMEDIATE_HEADERS, numHeadersInFile); ___2038 = ___2038 && zoneFile.___3461() && ___4516(zoneFile, SZPLT_FILE_TYPE, ___1385.getFileVersion(), includeRevisionNumber, 1); try { ___3946 headerTagMap = initializedHeaderTagMap( ___1385.getFileVersion(), numZonesToWrite, numVarsToWrite, numPartitionFiles, ___1385.___1756(), ___1385.___1755()); ___1390 szpltZoneHeaderFileLocs; ___372 dataSetIsAvailable = ___36.___894(); std::string dataSetTitle; if (dataSetIsAvailable) { char* ___4178 = 0; ___36.datasetGetTitle(&___4178); dataSetTitle = ___4178; ___36.___3818(&___4178); } uint64_t headersCount = numHeadersInFile + 1; uint32_t auxDataCount = numAuxDataInFile + countAuxData(___36, varIter, zoneIter); uint32_t geomCount = numGeomsInFile + countGeoms(___36); uint32_t textCount = numTextsInFile + countTexts(___36); uint32_t customLabelsCount = numCustomLabelsInFile + countCustomLabelSets(___36); ___2038 = ___2038 && headerFile.seekToFileEnd(); ___2038 = ___2038 && auxDataFile.seekToFileEnd(); ___2038 = ___2038 && textFile.seekToFileEnd(); ___2038 = ___2038 && geometryFile.seekToFileEnd(); ___2038 = ___2038 && customLabelsFile.seekToFileEnd(); ___2038 = ___2038 && auxDataFile.___3461() && ___4484(auxDataFile, auxDataCount) && auxDataFile.seekToFileEnd() && writeAuxDataItems(auxDataFile, ___36, varIter, zoneIter, fileZoneOffset) && geometryFile.___3461() && ___4522(geometryFile, geomCount) && geometryFile.seekToFileEnd() && writeGeomItems(geometryFile, ___36, fileZoneOffset) && textFile.___3461() && ___4547(textFile, textCount) && textFile.seekToFileEnd() && writeTextItems(textFile, ___36, fileZoneOffset) && customLabelsFile.___3461() && ___4504(customLabelsFile, customLabelsCount) && customLabelsFile.seekToFileEnd() && writeCustomLabelSets(customLabelsFile, ___36) && ___25(szpltZoneHeaderFileLocs, ___36, numZonesToWrite, false) && zoneFile.seekToFileEnd() && dataSetWriter.writeDataSet(zoneFile, ___1385.getFileVersion(), szpltZoneHeaderFileLocs) &&
headerFile.___3461() && writeValue<uint64_t, false, 0>(headerFile, SZPLT_NUM_INTERMEDIATE_HEADERS, headersCount) && headerFile.seekToFileEnd() && writeDataSetHeaders(headerFile, ___1385.getFileVersion(), dataSetIsAvailable, dataSetTitle, numVarsToWrite, numZonesToWrite, headerTagMap, dataSetWriter.___4706(), szpltZoneHeaderFileLocs, ___933);
 #ifdef PROFILE_FILE_ACCESS
FileStreamWriter* fileWriter = dynamic_cast<FileStreamWriter*>(&szpltFile); if (fileWriter) ___933.___7(fileWriter->statistics().___2781);
 #endif
} catch (std::bad_alloc const&) { ___2038 = ___1184("Out of memory while writing file."); } catch (std::runtime_error const& e) { std::ostringstream ___2893; ___2893 << "Error encountered while writing file: " << e.what(); ___2038 = ___1184(___2893.str().c_str()); } catch (...) { ___2038 = ___1184("Unrecoverable error while writing file."); } ___36.___3771(); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } }}
