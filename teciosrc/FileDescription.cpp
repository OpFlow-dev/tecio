#include "ThirdPartyHeadersBegin.h"
#include <string>
 #if defined TECIOMPI
#include <mpi.h> 
 #endif 
#include "ThirdPartyHeadersEnd.h"
#include "AltTecUtil.h"
#include "FileDescription.h"
#include "ItemSetIterator.h"
namespace tecplot { namespace ___3934 { bool ___1386::validIsAscii(___372 ___2001) { return VALID_BOOLEAN(___2001); } bool ___1386::validDataFileType(DataFileType_e ___842) { return VALID_ENUM(___842, DataFileType_e); } bool ___1386::validIJKSubzoneSize(___1843 const& ijkSubzoneSize) { return ijkSubzoneSize.___2066() && ijkSubzoneSize.blockSize()<=ItemAddress64::MAX_ITEM_OFFSET+1; } bool ___1386::validFESubzoneSize(ItemAddress64::ItemOffset_t feSubzoneSize) { return feSubzoneSize>0 && feSubzoneSize<=ItemAddress64::MAX_ITEM_OFFSET+1; } bool ___1386::validFileVersion(uint32_t fileVersion) { return fileVersion >= SZPLT_MIN_READ_VERSION; } ___1386::___1386() { invalidate(); } uint32_t ___1386::surveyZonesForFileVersion( ___37 const& ___36, ___3502            ___4671) { REQUIRE(SZPLT_CUR_WRITE_VERSION == 232); ItemSetIterator zoneIter(___36, ___36.___894() ? ___36.___889() : 0, ___4671); while (zoneIter.hasNext()) { ___1170 const zone = zoneIter.next(); if (___36.___4638(zone+1) && ___36.___4620(zone+1) == ZoneType_FEMixed) return 232; } return 105; } ___1386::___1386( uint32_t                    fileVersion, ___372 const             ___2001, DataFileType_e              ___842, ___1843 const&                  ijkSubzoneSize, ItemAddress64::ItemOffset_t feSubzoneSize) { invalidate(); ___3495(___2001); setDataFileType(___842); setMaxIJKSubzoneSize(ijkSubzoneSize); setMaxFESubzoneSize(feSubzoneSize); setFileVersion(fileVersion); } void ___1386::invalidate() { m_isAscii = ___372(-1); m_dataFileType = ___845; m_maxIJKSubzoneSize.invalidate(); m_maxFESubzoneSize = ItemAddress64::INVALID_ITEM_OFFSET; m_fileVersion = 0; m_codeRevision = 0; } void ___1386::___3495(___372 ___2001) { REQUIRE(validIsAscii(___2001)); m_isAscii = ___2001; } void ___1386::setDataFileType(DataFileType_e ___842) { REQUIRE(validDataFileType(___842)); m_dataFileType = ___842; } void ___1386::setMaxIJKSubzoneSize(___1843 const& maxIJKSubzoneSize) { REQUIRE(validIJKSubzoneSize(maxIJKSubzoneSize)); m_maxIJKSubzoneSize = maxIJKSubzoneSize; } void ___1386::setMaxFESubzoneSize(ItemAddress64::ItemOffset_t maxFESubzoneSize) { REQUIRE(validFESubzoneSize(maxFESubzoneSize)); m_maxFESubzoneSize = maxFESubzoneSize; } void ___1386::setFileVersion(uint32_t fileVersion) { m_fileVersion = fileVersion; } void ___1386::setCodeRevision(uint32_t codeRevision) { m_codeRevision = codeRevision; } ___372 ___1386::___2001() const { ENSURE(VALID_BOOLEAN(m_isAscii)); return m_isAscii; } DataFileType_e ___1386::___842() const { ENSURE(VALID_ENUM(m_dataFileType, DataFileType_e)); return m_dataFileType; } ___1843 const& ___1386::___1756() const { ENSURE(validIJKSubzoneSize(m_maxIJKSubzoneSize)); return m_maxIJKSubzoneSize;
} ItemAddress64::ItemOffset_t ___1386::___1755() const { ENSURE(validFESubzoneSize(m_maxFESubzoneSize)); return m_maxFESubzoneSize; } uint32_t ___1386::getFileVersion() const { ENSURE(validFileVersion(m_fileVersion)); return m_fileVersion; } uint32_t ___1386::getCodeRevision() const { return m_codeRevision; } }}
