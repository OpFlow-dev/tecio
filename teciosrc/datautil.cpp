#include "stdafx.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "CodeContract.h"
#include "Q_UNICODE.h"
#include "SYSTEM.h"
#include "ALLOC.h"
#include "ARRLIST.h"
#include "SET.h"
#include "DATASET.h"
#include "FILESTREAM.h"
#include "DATAIO.h"
#include "DATAIO4.h"
#include "DATAUTIL.h"
#include "STRLIST.h"
#include "Q_MSG.h"
 #if defined MAKEARCHIVE
 #define ___1936
 #endif
#include "INPUT.h"
using namespace tecplot;
 #if defined MAKEARCHIVE
 #define ___58 1.0e-10
void ___1934() { LineThicknessInputSpec.___4237                                = ___1941; LineThicknessInputSpec.___2471                                 = 0.000001; LineThicknessInputSpec.___2347                                 = 1.0; LineThicknessInputSpec.___1977.___3435           = 100.0; LineThicknessInputSpec.___3885                      = NULL; PatternLengthInputSpec.___4237                                = ___1941; PatternLengthInputSpec.___2471                                 = 0.0001; PatternLengthInputSpec.___2347                                 = 1.0; PatternLengthInputSpec.___1977.___3435           = 100.0; PatternLengthInputSpec.___3885                      = NULL; TextBoxMarginInputSpec.___4237                                = ___1941; TextBoxMarginInputSpec.___2471                                 = 0.0; TextBoxMarginInputSpec.___2347                                 = 20.0; TextBoxMarginInputSpec.___1977.___3435           = 100.0; TextBoxMarginInputSpec.___3885                      = NULL; TextLineSpacingInputSpec.___4237                              = ___1941; TextLineSpacingInputSpec.___2471                               = 0.0; TextLineSpacingInputSpec.___2347                               = 5.0; TextLineSpacingInputSpec.___1977.___3435         = 1.0; TextLineSpacingInputSpec.___3885                    = NULL; ArrowheadSizeInputSpec.___4237                                = ___1941; ArrowheadSizeInputSpec.___2471                                 = 0.0; ArrowheadSizeInputSpec.___2347                                 = 0.5; ArrowheadSizeInputSpec.___1977.___3435           = 100.0; ArrowheadSizeInputSpec.___3885                      = NULL; TextAngleInputSpec.___4237                                    = ___1941; TextAngleInputSpec.___2471                                     = -M_PI - ___58; TextAngleInputSpec.___2347                                     =  M_PI + ___58; TextAngleInputSpec.___1977.___3435               = ___952; TextAngleInputSpec.___3885                          = NULL; ArrowheadAngleInputSpec.___4237                               = ___1941; ArrowheadAngleInputSpec.___2471                                = 1.0 / ___952 - ___58; ArrowheadAngleInputSpec.___2347                                = ___3089 + ___58; ArrowheadAngleInputSpec.___1977.___3435          = ___952; ArrowheadAngleInputSpec.___3885                     = NULL; }
 #endif
void LocalReadBlock(___1403   *___1399, double         *CurVPtr, FieldDataType_e ___1365, ___2226       ___2843, ___372      *___2039) { REQUIRE(VALID_REF(___2039) && VALID_BOOLEAN(*___2039)); REQUIRE(!(*___2039) || VALID_REF(___1399)); REQUIRE(!(*___2039) || VALID_FIELD_DATA_TYPE(___1365)); if (*___2039) { ___372 ___1097 = (CurVPtr != NULL); ___372 ReadByBlock = (___1365 == FieldDataType_Double) || !___1097; if (ReadByBlock) { ___3297(___1399, ___1097, (void *)CurVPtr, ___1365, 0, ___2843, ___2039); } else { for (___2226 N = 0; *___2039 && (N < ___2843); N++) { double const D = ___1761(___1399, ___1365, -___2178, ___2178, ___2039); if (___1097) CurVPtr[N] = D; } } } }
 #define READTEC_FREE(___3252,str) ( ((___3252)!=NULL) ? (___1528((___3252),(str)),(___3252)=NULL) : (NULL) )
___372 ___3298( ___372       ___1747, char const*     ___1392, int32_t        *fileVersion, DataFileType_e *___1405, char          **___901, ___1170     *___2848, ___1170     *NumVars, ___3840  *___4366, ___3840  *___4653, int32_t       **zoneVersions, ___2226     **___2831, ___2226     **___2832, ___2226     **___2833, ___2226     **___2806, ZoneType_e    **___4693, ___3840  *___4286, ___264     *___883, ___2226       **neighborCount, int32_t        ***valueLocations, FieldDataType_e***___1370, ___372      ***fieldDataPassive, int32_t        ***varSharing, int32_t         **connectSharing, ___372         RawDataSpaceAllocated, ___2733      ***___2725, double         ***___4395) { REQUIRE(VALID_BOOLEAN(___1747)); REQUIRE(VALID_NON_ZERO_LEN_STR(___1392)); REQUIRE(VALID_REF(fileVersion)); REQUIRE(VALID_REF(___1405)); REQUIRE(VALID_REF(___901) || ___901 == NULL); REQUIRE(VALID_REF(___2848)); REQUIRE(VALID_REF(NumVars)); REQUIRE(___4366  == NULL || VALID_REF(___4366)); REQUIRE(___4653 == NULL || VALID_REF(___4653)); REQUIRE(zoneVersions == NULL || VALID_REF(zoneVersions)); REQUIRE(___2831   == NULL || VALID_REF(___2831)); REQUIRE(___2832   == NULL || VALID_REF(___2832)); REQUIRE(___2833 == NULL || VALID_REF(___2833)); REQUIRE(___2806 == NULL || VALID_REF(___2806)); REQUIRE(___4693 == NULL || VALID_REF(___4693)); REQUIRE(___4286   == NULL || VALID_REF(___4286)); REQUIRE(VALID_REF_OR_NULL(neighborCount) && IMPLICATION(neighborCount, *neighborCount == NULL)); REQUIRE(VALID_REF_OR_NULL(valueLocations) && IMPLICATION(valueLocations, *valueLocations == NULL)); REQUIRE(VALID_REF_OR_NULL(___1370) && IMPLICATION(___1370, *___1370 == NULL)); REQUIRE(VALID_REF_OR_NULL(fieldDataPassive) && IMPLICATION(fieldDataPassive, *fieldDataPassive == NULL)); REQUIRE(VALID_REF_OR_NULL(varSharing) && IMPLICATION(varSharing, *varSharing == NULL)); REQUIRE(VALID_REF_OR_NULL(connectSharing) && IMPLICATION(connectSharing, *connectSharing == NULL)); REQUIRE(VALID_BOOLEAN(RawDataSpaceAllocated)); REQUIRE(IMPLICATION(!___1747 && RawDataSpaceAllocated, VALID_REF(___2725) && VALID_REF(___4395))); ___372     InputIsOk = ___1303; ___134  ___4682 = NULL; ___2226    *___1439 = NULL; ___1403 *ReadTecFileStream = NULL; ___3502       *___2074 = NULL; ___372 const getDataSegmentMetaData = (___1370 || fieldDataPassive || varSharing || connectSharing || neighborCount);
 #if defined MAKEARCHIVE
___1934();
 #endif
InputIsOk  = ___2877(&ReadTecFileStream, ___1392, 0, fileVersion); if (InputIsOk) InputIsOk = ___3280(ReadTecFileStream, short(*fileVersion), ___1303, ___2848, NumVars, (int32_t *)NULL, ___901, (___4119 **)NULL, (___1630 **)NULL, (___3840  **)NULL, ___4286, ___883, 0, &___2074, (___372 *)NULL, (___372 *)NULL, &___4682, ___4366, (___134 *)NULL, (___3502 *)NULL, &___1439, ___1405); if (InputIsOk) { if (*___2848 == 0) *NumVars = 0; else if (*fileVersion > 191) { ___1175(___4218("ReadTec does not yet support version %d " "Tecplot binary data files."), *fileVersion); InputIsOk = ___1303; } else if (!___1747) { for (___1170 Z = 0; Z < *___2848 && InputIsOk; Z++) { InputIsOk = ___2014(___2074[Z]); if (!InputIsOk) ___1175(___4218("Cell centered data not supported by ReadTec.")); } } } if (InputIsOk && ___2074 && valueLocations && *___2848 > 0) { *valueLocations = ___23(*___2848, int32_t*, "valueLocations base array"); InputIsOk = (*valueLocations != NULL); for (___1170 zn = 0; zn < *___2848 && InputIsOk; ++zn) (*valueLocations)[zn] = NULL; for (___1170 zn = 0; zn < *___2848 && InputIsOk; ++zn) { (*valueLocations)[zn] = ___23(*NumVars, int32_t, "valueLocations subarray"); InputIsOk = ((*valueLocations)[zn] != NULL); for (___1170 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { if (___1955(___2074[zn], ___4336)) (*valueLocations)[zn][___4336] = 0; else (*valueLocations)[zn][___4336] = 1; } } } if (InputIsOk && ___1370 && *___2848 > 0) { *___1370 = ___23(*___2848, FieldDataType_e*, "fieldDataTypes base array"); InputIsOk = (*___1370 != NULL); for (___1170 zn = 0; zn < *___2848 && InputIsOk; ++zn) (*___1370)[zn] = NULL; } if (InputIsOk && fieldDataPassive && *___2848 > 0) { *fieldDataPassive = ___23(*___2848, ___372*, "fieldDataPassive base array"); InputIsOk = (*fieldDataPassive != NULL); for (___1170 zn = 0; zn < *___2848 && InputIsOk; ++zn) (*fieldDataPassive)[zn] = NULL; } if (InputIsOk && varSharing && *___2848 > 0) { *varSharing = ___23(*___2848, ___1170*, "varSharing base array"); InputIsOk = (*varSharing != NULL); for (___1170 zn = 0; zn < *___2848 && InputIsOk; ++zn) (*varSharing)[zn] = NULL; } if (InputIsOk && neighborCount && *___2848 > 0) { *neighborCount = ___23(*___2848, ___2226, "neighborCount array"); InputIsOk = (*neighborCount != NULL); for (___1170 zn = 0; zn < *___2848 && InputIsOk; ++zn) (*neighborCount)[zn] = 0; } if (InputIsOk && *___2848 > 0) { if (___4653) *___4653 = ___3822(); if (zoneVersions) *zoneVersions = ___23(*___2848, int32_t, "zoneVersions Array"); if (___2831) *___2831  = ___23(*___2848, ___2226, "numptsi"); if (___2832) *___2832  = ___23(*___2848, ___2226, "numptsj"); if (___2833) *___2833 = ___23(*___2848, ___2226, "numptsk"); if (___2806) *___2806 = ___23(*___2848, ___2226, "NumFaceNodes");
if (___4693) *___4693 = ___23(*___2848, ZoneType_e, "zonetype"); InputIsOk = (IMPLICATION(___4653, *___4653)       && IMPLICATION(zoneVersions, *zoneVersions) && IMPLICATION(___2831, *___2831)           && IMPLICATION(___2832, *___2832)           && IMPLICATION(___2833, *___2833)           && IMPLICATION(___2806, *___2806) && IMPLICATION(___4693, *___4693)); for (___1170 zn = 0; InputIsOk && zn < *___2848; zn++) { ___4683 const* const ___4677 = ___1802(___4682, zn); if (___4677 != NULL) { if (!InputIsOk) break; if (___4653) ___3824(*___4653, ___4677->___2686.c_str()); if (zoneVersions) (*zoneVersions)[zn] = ___4677->tecplotFileZoneVersion; if (___2831) (*___2831)[zn] = ___4677->numIPts(); if (___2832) (*___2832)[zn] = ___4677->numJPts(); if (___2833) (*___2833)[zn] = ___4677->numKPts(); if (___2806) (*___2806)[zn] = ___4677->___2805(); if (___4693) (*___4693)[zn] = ___4677->___4237; } else { if (___4653) ___3824(*___4653, NULL); if (zoneVersions) (*zoneVersions)[zn] = *fileVersion; if (___2831) (*___2831)[zn] = 0; if (___2832) (*___2832)[zn] = 0; if (___2833) (*___2833)[zn] = 0; if (___2806) (*___2806)[zn] = 0; if (___4693) (*___4693)[zn] = ___4703; } } } ___372 const readDataSegment = (*___2848 > 0) && (!___1747 || getDataSegmentMetaData); ___372 const allocateFieldDataAndConnectivity = (*___2848 > 0) && (!___1747 && !RawDataSpaceAllocated); if (readDataSegment && InputIsOk) { ___2226 const numZoneVars = ___2226(*___2848) * ___2226(*NumVars); ___1170      *VarSharesFromZone = NULL; ___372       *___2075               = NULL; ___1170      *ConnectivitySharesFromZone = NULL; FieldDataType_e *VarType = NULL; if (allocateFieldDataAndConnectivity) { *___4395 = ___23(numZoneVars, double *, "vdatabase array"); if (*___4395 == NULL) { ___1175(___4218("Cannot allocate space for field data")); InputIsOk = ___1303; } else { for (___2226 zv = 0; zv < numZoneVars; ++zv) (*___4395)[zv] = NULL; } if (InputIsOk) { *___2725 = ___23(*___2848, ___2733 *, "nodemap array"); if (*___2725 == NULL) { ___1175(___4218("Cannot allocate space for nodemap")); InputIsOk = ___1303; } else { for (___1170 zn = 0; zn < *___2848; ++zn) (*___2725)[zn] = NULL; } } } if (InputIsOk) { VarType           = ___23(*NumVars, FieldDataType_e, "VarType"); VarSharesFromZone = ___23(*NumVars, ___1170, "VarSharesFromZone"); ___2075      = ___23(*NumVars, ___372, "IsVarPassive"); ConnectivitySharesFromZone = ___23(*___2848, ___1170, "ConnectivitySharesFromZone"); InputIsOk = (VarType                    != NULL && VarSharesFromZone          != NULL && ___2075               != NULL && ConnectivitySharesFromZone != NULL); } for (___1170 zone = 0; zone < *___2848 && InputIsOk; ++zone) { double const ___4567 = ___1761(ReadTecFileStream, FieldDataType_Float, 0.0, 1000.0, &InputIsOk);
if (InputIsOk && (___4567 == ZoneMarkerFull32Bit || ___4567 == ZoneMarkerFace64Bit)) { ___4683& zoneSpec = *___1802(___4682, zone); ___372 ZoneIsFinite  = (zoneSpec.___4237 != ___4704); ___372 ZoneIsFEPoly  = (zoneSpec.___4237 == ___4698 || zoneSpec.___4237 == ___4699); ___372 InBlockFormat = zoneSpec.___4647.___2026; for (___1170 ___4336 = 0; ___4336 < *NumVars; ++___4336 ) { VarSharesFromZone[___4336] = -1; VarType[___4336]           = FieldDataType_Float; ___2075[___4336]      = ___1303; } if (*fileVersion > 45 && *fileVersion < 101 && InputIsOk) { ___1170 const numDupVars = ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, *NumVars, &InputIsOk); if ((numDupVars > 0) && (zone == 0)) { ___1175(___4218("Cannot duplicate variables from the first zone since there are " "no previous zones to duplicate from.")); InputIsOk = ___1303; } for (___1170 index = 0; index < numDupVars && InputIsOk; ++index) { ___1170 const ___4336 = ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, *NumVars, &InputIsOk) - 1; VarSharesFromZone[___4336] = zone - 1; } } if (*fileVersion >= 70 && InputIsOk) { for (___1170 ___4336 = 0; ___4336 < *NumVars; ++___4336) { VarType[___4336] = (FieldDataType_e)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___1363, &InputIsOk); if (!InputIsOk) { ___1175(___4218("Invalid data type - binary input file corrupted")); InputIsOk = ___1303; } } } ___2226 const ___2810 = InputIsOk ? zoneSpec.numIPts() : 0; ___2226 const ___2815 = InputIsOk ? zoneSpec.numJPts() : 0; ___2226 const ___2818 = InputIsOk ? zoneSpec.numKPts() : 0; ___2226 const TotalNumPts = (ZoneIsFinite ? ___2810 : ___2810 * ___2815 * ___2818); for (___1170 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { if (allocateFieldDataAndConnectivity && TotalNumPts >= 1) (*___4395)[___4336 + zone*(*NumVars)] = ___23(TotalNumPts, double, "raw data"); } if (*fileVersion >= 105 && InputIsOk) { if ((___372)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk) && InputIsOk) { for (___1170 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { ___2075[___4336] = (___372)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk); } } } if (*fileVersion >= 101 && InputIsOk) { if ((___372)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk) && InputIsOk) { for (___1170 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { ___1170 const SharedZone = ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), -1, ___2383 - 1, &InputIsOk); if (SharedZone != -1 && InputIsOk) VarSharesFromZone[___4336] = SharedZone; } } if (InputIsOk) { ___1170 const SharedZone = ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), -1, ___2383 - 1, &InputIsOk); if (InputIsOk) ConnectivitySharesFromZone[zone] = SharedZone; } } if (*fileVersion >= 103 && InputIsOk) { for (___1170 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { if (VarSharesFromZone[___4336] == -1 && !___2075[___4336])
{ ___1761(ReadTecFileStream, FieldDataType_Double, -___2178, ___2178, &InputIsOk); ___1761(ReadTecFileStream, FieldDataType_Double, -___2178, ___2178, &InputIsOk); } } } if (___1747) { if (InBlockFormat) { for (___1170 ___4336 = 0; InputIsOk && ___4336 < *NumVars; ++___4336) { if (VarSharesFromZone[___4336] == -1 && !___2075[___4336]) { ___2226 numValues = TotalNumPts; if (___1955(___2074[zone], ___4336)) { if (ZoneIsFinite) numValues = ___2815; else if (___2810 > 1 && ___2815 > 1 && ___2818 > 1) numValues = ___2810 * ___2815 * (___2818 - 1); else if (___2810 > 1 && ___2815 > 1) numValues = ___2810 * (___2815 - 1); else if (___2815 > 1 && ___2818 > 1) numValues = ___2815 * (___2818 - 1); else if (___2810 > 1 && ___2818 > 1) numValues = ___2810 * (___2818 - 1); else if (___2810 > 1) numValues = (___2810 - 1); else if (___2815 > 1) numValues = (___2815 - 1); else if (___2818 > 1) numValues = (___2818 - 1); else numValues = 1; } LocalReadBlock( ReadTecFileStream, NULL, VarType[___4336], numValues, &InputIsOk); } } } else { ___1175(___4218("Zone in point format, not all meta data available.")); InputIsOk = ___1303; } } else if (InBlockFormat) { for (___1170 ___4336 = 0; InputIsOk && ___4336 < *NumVars; ++___4336) { if (TotalNumPts > 0) { double *CurVPtr = (*___4395)[___4336 + zone*(*NumVars)]; if (VarSharesFromZone[___4336] != -1) { ___1170 const ___3649 = VarSharesFromZone[___4336]; double *SourceVPtr = (*___4395)[___4336 + ___3649*(*NumVars)]; for (___2226 M = 0; M < TotalNumPts; M++) CurVPtr[M] = SourceVPtr[M]; } else if (!___2075[___4336]) { LocalReadBlock(ReadTecFileStream, CurVPtr, VarType[___4336], TotalNumPts, &InputIsOk); } } } if (!InputIsOk) ___1175(___4218("Invalid raw data section of binary file")); } else if (TotalNumPts > 0) { if (InputIsOk) { ___2226 N; N = 0; while (InputIsOk && (N < TotalNumPts)) { for (___1170 ___716 = 0; InputIsOk && (___716 < *NumVars); ___716++) { double *CurVPtr  = (*___4395)[___716+zone*(*NumVars)]; if (VarSharesFromZone[___716] != -1) { ___1170 ___3649 = VarSharesFromZone[___716]; double *SourceVPtr = (*___4395)[___716+___3649*(*NumVars)]; CurVPtr[N] = SourceVPtr[N]; } else if (!___2075[___716]) { double D = ___1761(ReadTecFileStream, VarType[___716], -___2178, ___2178, &InputIsOk); if (InputIsOk && CurVPtr) CurVPtr[N] = D; } } if (!InputIsOk) ___1175(___4218("Binary datafile corrupted!")); N++; } } } if (InputIsOk && *fileVersion < 101) { if (ZoneIsFinite) { ___372 DupConnectivity; if (*fileVersion > 61) DupConnectivity = (___372)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk); else DupConnectivity = ___1303; if (DupConnectivity) ConnectivitySharesFromZone[zone] = zone - 1; else ConnectivitySharesFromZone[zone] = -1; } else ConnectivitySharesFromZone[zone] = -1; } if (InputIsOk && ZoneIsFinite && !ZoneIsFEPoly) { ___372   SkipNodemap; ___2733  *___2708 = NULL; ___2733  *ONM = NULL; if (allocateFieldDataAndConnectivity && ___2818*___2815 >= 1)
{ (*___2725)[zone] = ___23(___2818 * ___2815, ___2733, "node map"); if ((*___2725)[zone] == NULL) ___1175(___4218("Cannot allocate space for connectivity list", "See the Tecplot User's Manual for a definition of 'connectivity list'")); } if (InputIsOk && ___2725 && *___2725) ___2708 = (*___2725)[zone]; SkipNodemap = (___2708 == NULL); if (InputIsOk && ConnectivitySharesFromZone[zone] != -1) { ___1170 ___3649 = ConnectivitySharesFromZone[zone]; if (___3649 >= zone) { ___1175(___4218("Zone %d is attempting to share connectivity " "with a zone that has not yet been loaded."), zone + 1); InputIsOk = ___1303; } else { ONM = (*___2725)[___3649]; if (ONM == NULL) { ___1175(___4218("Zone %d is attempting to share connectivity " "with a zone that is not finite element."), zone + 1); InputIsOk = ___1303; } } } if (InputIsOk) { if (___1747) { if (ConnectivitySharesFromZone[zone] == -1 && *___1405 != ___846) { LocalReadBlock(ReadTecFileStream, NULL, FieldDataType_Int32, ___2815*___2818, &InputIsOk); } } else { for (___2226 ___2105 = 0; ___2105 < ___2815; ___2105++) for (___2226 ___1831 = 0; ___1831 < ___2818; ___1831++) { ___2226 ___2164 = ___2105 * ___2818 + ___1831; ___2226 M; if (ConnectivitySharesFromZone[zone] != -1) { M = ONM[___2164]; } else { int32_t const nodeShift = *fileVersion < 103 ? 1 : 0; M = ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), ___2750 + nodeShift, ___2181, &InputIsOk) - nodeShift; } if (!SkipNodemap) ___2708[___2164] = M; } } } } if (*fileVersion >= 101 && InputIsOk) { if ( ConnectivitySharesFromZone[zone] == -1 && *___1405 != ___846     && ___1439[zone] != 0 ) { if (InputIsOk && neighborCount && *neighborCount) (*neighborCount)[zone] = ___1439[zone]; ___2226 Connection = 0; while (Connection < ___1439[zone] && InputIsOk) { (void)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), -___2181, ___2181, &InputIsOk); if (!InputIsOk) ___1175(___4218("Unexpected end-of-file while reading face neighbor data.")); (void)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), -___2181, ___2181, &InputIsOk); if (InputIsOk) { ___476(zoneSpec.___1438 == ___1288  || zoneSpec.___1438 == ___1287 || zoneSpec.___1438 == ___1285 || zoneSpec.___1438 == ___1284); if (zoneSpec.___1438 == ___1288) (void)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), ___2750, ___2181, &InputIsOk); else (void)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), -___2181, ___2181, &InputIsOk); if (zoneSpec.___1438 != ___1288 && InputIsOk) { ___2226 NumAssociations = 0; if (zoneSpec.___1438 == ___1287) { NumAssociations = ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2181, &InputIsOk); } else if (zoneSpec.___1438 == ___1285) { (void)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), ___2750, ___2181, &InputIsOk);
} else { ___476(zoneSpec.___1438 == ___1284); NumAssociations = ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2181, &InputIsOk); } if (zoneSpec.___1438 != ___1285 && InputIsOk) { ___2226 Assoc; if (zoneSpec.___1438 == ___1287) { for (Assoc = 0; Assoc < NumAssociations && InputIsOk; Assoc++) (void)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), ___2750, ___2181, &InputIsOk); } else { ___476(zoneSpec.___1438 == ___1284); for (Assoc = 0; Assoc < NumAssociations && InputIsOk; Assoc++) { (void)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), ___2751, ___2383, &InputIsOk); (void)___1749<int32_t>(ReadTecFileStream, short(*fileVersion), ___2750, ___2181, &InputIsOk); } } if (InputIsOk) Connection += NumAssociations; } else if (InputIsOk) Connection += 1; } else if (InputIsOk) Connection += 1; if (!InputIsOk) ___1175(___4218("Corrupt input file: invalid face neighbors.")); } } } } if (InputIsOk                              && ZoneIsFEPoly                           && *fileVersion >= 110                    && ConnectivitySharesFromZone[zone] == -1 && *___1405 != ___846) { if (!InBlockFormat) { ___1175(___4218("Poly zones must be in block format")); InputIsOk = ___1303; } if (InputIsOk) { ___2226 const numIPts = zoneSpec.numIPts(); ___2226 const numJPts = zoneSpec.numJPts(); ___2226 const numKPts = zoneSpec.numKPts(); if (*fileVersion == 110) { zoneSpec.assignMetrics( numIPts, numJPts, numKPts, ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2181, &InputIsOk), ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2181, &InputIsOk), ___1749<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2181, &InputIsOk)); } ___2226 const ___4194  = zoneSpec.___2805(); ___2226 const TotalNumBndryFaces = zoneSpec.numFaceBndryFaces(); ___2226 const TotalNumBndryItems = zoneSpec.numFaceBndryItems(); ___2226 const ___2807 = numKPts; if (zoneSpec.___4237 == ___4699) { int64_t const numFaceMetaDataValues = (zoneSpec.tecplotFileZoneVersion >= 191) ? ___2807  : ___2807 + 1/*offsets*/; ___3293(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, numFaceMetaDataValues, &InputIsOk); } if (InputIsOk) { ___3293(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, ___4194, &InputIsOk); } if (InputIsOk) { ___3293(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, ___2807, &InputIsOk); } if (InputIsOk) { ___3293(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, ___2807, &InputIsOk); } if (TotalNumBndryFaces > 0) { ___476(*fileVersion <= 191); if (InputIsOk && *fileVersion <= 191) ___3293(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, 1, &InputIsOk); if (InputIsOk) ___3293(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, TotalNumBndryFaces + 1, &InputIsOk);
if (InputIsOk) ___3293(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, TotalNumBndryItems, &InputIsOk); if (InputIsOk) { if (*fileVersion >= 112) ___3293(ReadTecFileStream, ___1303/*doRead*/, NULL, 0, TotalNumBndryItems, &InputIsOk); else ___3291(ReadTecFileStream, ___1303 , NULL, 0, TotalNumBndryItems, &InputIsOk); } } if (InputIsOk && neighborCount && *neighborCount) (*neighborCount)[zone] = zoneSpec.numFaceBndryItems(); } } } else { ___1175(___4218("Corrupt input file")); InputIsOk = ___1303; } if (InputIsOk && VarType && ___1370) { (*___1370)[zone] = VarType; VarType = ___23(*NumVars, FieldDataType_e, "VarType array"); InputIsOk = (VarType != NULL); } if (InputIsOk && ___2075 && fieldDataPassive) { (*fieldDataPassive)[zone] = ___2075; ___2075 = ___23(*NumVars, ___372, "IsVarPassive array"); InputIsOk = (___2075 != NULL); } if (InputIsOk && VarSharesFromZone && varSharing) { (*varSharing)[zone] = VarSharesFromZone; VarSharesFromZone = ___23(*NumVars, ___1170, "VarSharesFromZone array"); InputIsOk = (VarSharesFromZone != NULL); } } if (ConnectivitySharesFromZone) { if (connectSharing && InputIsOk) { *connectSharing = ConnectivitySharesFromZone; ConnectivitySharesFromZone = NULL; } else READTEC_FREE(ConnectivitySharesFromZone, "ConnectivitySharesFromZone"); } if (VarType) READTEC_FREE(VarType, "VarType"); if (___2075) READTEC_FREE(___2075, "IsVarPassive"); if (VarSharesFromZone) READTEC_FREE(VarSharesFromZone, "VarSharesFromZone"); if (!InputIsOk) { if (neighborCount) READTEC_FREE(*neighborCount, "neighborCount"); for (___1170 zn = 0; zn < *___2848; ++zn) { if (valueLocations && *valueLocations) READTEC_FREE((*valueLocations)[zn], "valueLocations subarray"); if (___1370 && *___1370) READTEC_FREE((*___1370)[zn], "fieldDataTypes subarray"); if (fieldDataPassive && *fieldDataPassive) READTEC_FREE((*fieldDataPassive)[zn], "fieldDataPassive subarray"); if (varSharing && *varSharing) READTEC_FREE((*varSharing)[zn], "varSharing subarray"); } if (valueLocations) READTEC_FREE(*valueLocations, "valueLocations"); if (___1370) READTEC_FREE(*___1370, "fieldDataTypes"); if (fieldDataPassive) READTEC_FREE(*fieldDataPassive, "fieldDataPassive"); if (varSharing) READTEC_FREE(*varSharing, "varSharing"); if (connectSharing) READTEC_FREE(*connectSharing, "connectSharing"); if (!RawDataSpaceAllocated) { if (___4395 && *___4395) { for (___2226 zv = 0; zv < numZoneVars; ++zv) { if ((*___4395)[zv]) READTEC_FREE((*___4395)[zv], "vdatabase array"); } READTEC_FREE(*___4395, "vdatabase pointer array"); } if (___2725 && *___2725) { for (___1170 zn = 0; zn < *___2848; ++zn) { if ((*___2725)[zn]) READTEC_FREE((*___2725)[zn], "connectivity list"); } READTEC_FREE(*___2725, "connectivity pointer array"); } } } } if (___2074) { for (___1170 zn = 0; zn < *___2848; ++zn) ___937(&___2074[zn]); READTEC_FREE(___2074, "Array of IsVarCellCentered sets");
} if (___1439 != NULL) READTEC_FREE(___1439, "FNNumBndryConns"); if (___4682) ArrayListDealloc(&___4682, ___4681, 0); if (ReadTecFileStream) { ___4196(ReadTecFileStream->File); free(ReadTecFileStream); } ENSURE(VALID_BOOLEAN(InputIsOk)); ENSURE(IMPLICATION(neighborCount, InputIsOk == (*neighborCount != NULL))); ENSURE(IMPLICATION(valueLocations, InputIsOk == (*valueLocations != NULL))); ENSURE(IMPLICATION(___1370, InputIsOk == (*___1370 != NULL))); ENSURE(IMPLICATION(fieldDataPassive, InputIsOk == (*fieldDataPassive != NULL))); ENSURE(IMPLICATION(varSharing, InputIsOk == (*varSharing != NULL))); ENSURE(IMPLICATION(connectSharing, InputIsOk == (*connectSharing != NULL))); return InputIsOk; } void* ___3958(size_t size) { return (void *)___23(size, char, "TecAlloc"); } void ___3969(void *___3252) { char *Tmp = (char *)___3252; READTEC_FREE(Tmp, "TecAlloc"); }
