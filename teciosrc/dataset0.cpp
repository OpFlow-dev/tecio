#include "MASTER.h"
#include "GLOBAL.h"
#include "CodeContract.h"
#include "TASSERT.h"
#include "ALLOC.h"
#include "ARRLIST.h"
#include "DATASET.h"
#include "SET.h"
#include "FILESTREAM.h"
#include "Q_MSG.h"
#include "DATASET0.h"
using namespace tecplot; void ___2890() { ___1175(___4218("Cannot allocate enough memory for this operation.")); } void ___1354(___1359 ___1350) { REQUIRE(VALID_REF(___1350)); { ___1356(___1350); } } ___1360::___1360( ___2226 numIPts, ___2226 numJPts, ___2226 numKPts) : ___814(NULL) , ___1780(NULL) , ___3507(NULL) , ___4692(___4704) , ___4335(___1367) , ___4327(___4329) , iDim(numIPts) , jDim(numJPts) , kDim(numKPts) { } ___1360::~___1360() { ___1354(this); } ___2226 ___1360::numIPts() const { return iDim; } ___2226 ___1360::numJPts() const { return jDim; } ___2226 ___1360::numKPts() const { return kDim; } namespace { ___1359 ___1352( ___2226 numIPts, ___2226 numJPts, ___2226 numKPts) { ___1359 ___3359 = NULL; try { ___3359 = new ___1360(numIPts, numJPts, numKPts); } catch (std::bad_alloc const&) { ENSURE(___3359 == NULL); } ENSURE(VALID_REF(___3359) || ___3359 == NULL); return ___3359; } } namespace { void FieldDataDeallocRawData(___1359 ___1349) { REQUIRE(VALID_REF(___1349)); if (___1719(___1349) != NULL) { char* Tmp = static_cast<char*>(___1719(___1349)); ___1528(Tmp, "FieldData _Data"); ___3488(___1349, NULL); } } } ___2226 ___1716(___1359 ___1350) { ___2226 numIPts = ___1350->numIPts(); ___2226 numJPts = ___1350->numJPts(); ___2226 numKPts = ___1350->numKPts(); if (___1350->___4692 == ___4704) { if (numIPts == -1 || numJPts == -1 || numKPts == -1) { return -1; } else { if (___1350->___4327 == ___4330) { return numIPts * numJPts * numKPts; } else if (numIPts == 0 && numJPts == 0 && numKPts == 0) { return 0; } else { if (numKPts > 1) --numKPts; else if (numJPts > 1) --numJPts; else if (numIPts > 1) --numIPts; return numIPts * numJPts * numKPts; } } } else if (___1350->___4327 == ___4330) { return numIPts; } else { return numJPts; } } void ___1356(___1359 ___1350) { REQUIRE(VALID_REF(___1350)); { FieldDataDeallocRawData(___1350); } ENSURE(___1719(___1350) == NULL); } void ___1355(___1359 *___1350, ___372     ___1101) {
 #ifndef TECPLOTKERNEL
___4279(___1101);
 #endif
REQUIRE(VALID_REF(___1350)); REQUIRE(VALID_REF(*___1350) || *___1350 == NULL); if (*___1350 != NULL) { { delete *___1350; } *___1350 = NULL; } ENSURE(*___1350 == NULL); } template <typename T> static void copyTypedValueArray(void*       ___1120, ___2226   ___1125, void const* ___3658, ___2226   ___3666, ___2226   ___3660) { REQUIRE(VALID_REF(___1120)); REQUIRE(___1125 >= 0); REQUIRE(VALID_REF(___3658)); REQUIRE(0 <= ___3666 && ___3666 <= ___3660+1); REQUIRE(___1120 != ___3658); size_t const ___2780 = sizeof(T) * (___3660 - ___3666 + 1); if (___2780 != 0) { T const* SrcPtr = ((T const*)___3658) + ___3666; T* DstPtr       = ((T*)___1120) + ___1125; if (DstPtr && SrcPtr) memcpy(DstPtr, SrcPtr, ___2780); } } void ___677( FieldDataType_e ___4335, void*           ___1120, ___2226       ___1125, void const*     ___3658, ___2226       ___3666, ___2226       ___3660) { REQUIRE(VALID_FIELD_DATA_TYPE(___4335) && ___4335 != ___1363); REQUIRE(VALID_REF(___1120)); REQUIRE(___1125 >= 0); REQUIRE(VALID_REF(___3658)); REQUIRE(0 <= ___3666 && ___3666 <= ___3660+1); REQUIRE(___1120 != ___3658); switch (___4335) { case ___1366 : ___476(___1303); case FieldDataType_Double : { ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); copyTypedValueArray<uint64_t>(___1120, ___1125, ___3658, ___3666, ___3660); } break; case FieldDataType_Float : case FieldDataType_Int32 : { ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); copyTypedValueArray<uint32_t>(___1120, ___1125, ___3658, ___3666, ___3660); } break; case FieldDataType_Int16 : { ___476(sizeof(uint16_t) == 2); copyTypedValueArray<uint16_t>(___1120, ___1125, ___3658, ___3666, ___3660); } break; case FieldDataType_Byte : { copyTypedValueArray<uint8_t>(___1120, ___1125, ___3658, ___3666, ___3660); } break; default : ___476(___1303); } } void ___3912(FieldDataType_e  ___4335, void            *___3658, ___2226        ___3666, ___2226        ___3660, ___2226        ___3665) { REQUIRE(VALID_FIELD_DATA_TYPE(___4335) && ___4335 != ___1363); REQUIRE(VALID_REF(___3658)); REQUIRE(0 <= ___3666 && ___3666 <= ___3660); REQUIRE(___3665 > 0); switch (___4335) { case ___1366: ___476(___1303); case FieldDataType_Double: { uint64_t *SrcPtr = ((uint64_t *)___3658) + ___3666; uint64_t *SrcPtrEnd = ((uint64_t *)___3658) + ___3660; ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); while (SrcPtr <= SrcPtrEnd) { ___3371(SrcPtr); SrcPtr += ___3665; } } break; case FieldDataType_Float: case FieldDataType_Int32: { uint32_t *SrcPtr = ((uint32_t *)___3658) + ___3666; uint32_t *SrcPtrEnd = ((uint32_t *)___3658) + ___3660; ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); while (SrcPtr <= SrcPtrEnd) { ___3368(SrcPtr); SrcPtr += ___3665; } } break; case FieldDataType_Int16: { uint16_t *SrcPtr = ((uint16_t *)___3658) + ___3666; uint16_t *SrcPtrEnd = ((uint16_t *)___3658) + ___3660;
___476(sizeof(uint16_t) == 2); while (SrcPtr <= SrcPtrEnd) { ___3365(SrcPtr); SrcPtr += ___3665; } } break; case FieldDataType_Byte: case ___1363: { } break; default: ___476(___1303); } } void ___3913(FieldDataType_e  ___4335, void            *___3658, ___2226        ___3666, ___2226        ___3660, ___2226        ___3665) { REQUIRE(VALID_FIELD_DATA_TYPE(___4335) && ___4335 != ___1363); REQUIRE(VALID_REF(___3658)); REQUIRE(0 <= ___3666 && ___3666 <= ___3660); REQUIRE(___3665 > 0); switch (___4335) { case ___1366: ___476(___1303); case FieldDataType_Double: { uint8_t *SrcPtr = ((uint8_t *)___3658) + ___3666 * sizeof(uint64_t); uint8_t *SrcPtrEnd = ((uint8_t *)___3658) + ___3660 * sizeof(uint64_t); size_t byte_skip = ___3665 * sizeof(uint64_t); ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); while (SrcPtr <= SrcPtrEnd) { ___3372(SrcPtr); SrcPtr += byte_skip; } } break; case FieldDataType_Float: case FieldDataType_Int32: { uint8_t *SrcPtr = ((uint8_t *)___3658) + ___3666 * sizeof(uint32_t); uint8_t *SrcPtrEnd = ((uint8_t *)___3658) + ___3660 * sizeof(uint32_t); size_t byte_skip = ___3665 * sizeof(uint32_t); ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); while (SrcPtr <= SrcPtrEnd) { ___3369(SrcPtr); SrcPtr += byte_skip; } } break; case FieldDataType_Int16: { uint8_t *SrcPtr = ((uint8_t *)___3658) + ___3666 * sizeof(uint16_t); uint8_t *SrcPtrEnd = ((uint8_t *)___3658) + ___3660 * sizeof(uint16_t); size_t byte_skip = ___3665 * sizeof(uint16_t); ___476(sizeof(uint16_t) == 2); while (SrcPtr <= SrcPtrEnd) { ___3366(SrcPtr); SrcPtr += byte_skip; } } break; case FieldDataType_Byte: case ___1363: { } break; default: ___476(___1303); } }
 #define DEBUG_FIELDVALUES_BAD_VALUE 0x11
 #if !defined NO_ASSERTS
template <typename T> inline bool IsFieldDataValueInitialized( ___1359 ___1306, ___2226    ___3250) {
 #ifndef TECPLOTKERNEL
___4279(___1306);
 #endif
 #if defined DEBUG_FIELDVALUES
static unsigned char BadValueStr[] = { DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE }; ___476(sizeof(T) <= sizeof(BadValueStr)); ___4279(___3250); return ((sizeof(T) < 4)   || \ memcmp(BadValueStr,((char*)___1719(___1306))+sizeof(T)*(___3250), sizeof(T)) != 0);
 #else
___4279(___1306); ___4279(___3250); return true;
 #endif
}
 #endif
double ___1741(const ___1359 ___1306, ___2226          ___3250) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE(IsFieldDataValueInitialized<float>(___1306, ___3250)); double ___3360 = (double)___1689(___1306)[___3250]; return ___3360; } double ___1740(const ___1359 ___1306, ___2226          ___3250) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE(IsFieldDataValueInitialized<double>(___1306, ___3250)); double ___3360 = ___1683(___1306)[___3250]; return ___3360; } double ___1743(const ___1359 ___1306, ___2226          ___3250) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE(IsFieldDataValueInitialized<int32_t>(___1306, ___3250)); double ___3360 = (double)___1704(___1306)[___3250]; return ___3360; } double ___1742(const ___1359 ___1306, ___2226          ___3250) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE(IsFieldDataValueInitialized<int16_t>(___1306, ___3250)); double ___3360 = (double)___1698(___1306)[___3250]; return ___3360; } double ___1739(const ___1359 ___1306, ___2226          ___3250) { REQUIRE(VALID_REF(___1306)); REQUIRE(___1725(___1306) == FieldDataType_Byte); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE(IsFieldDataValueInitialized<uint8_t>(___1306, ___3250)); double ___3360 = (double)___1680(___1306)[___3250]; return ___3360; } double ___1738(const ___1359 ___1306, ___2226          ___3250) { REQUIRE(VALID_REF(___1306)); REQUIRE(___1725(___1306) == ___1363); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE(IsFieldDataValueInitialized<uint8_t>(___1306, ___3250 / 8)); ___2226 ByteOffset = ___3250 / 8; uint8_t    BitMask    = (01 << (___3250 % 8)); uint8_t *byte_array = ___1680(___1306); double ___3360 = (byte_array[ByteOffset] & BitMask) ? 1.0 : 0.0; return ___3360; } ___1381 DetermineFieldDataGetFunction(___1359 ___1349) { REQUIRE(VALID_REF(___1349)); ___1381 ___3360 = NULL; switch (___1725(___1349)) { case FieldDataType_Float:  ___3360 = ___1741;  break; case FieldDataType_Double: ___3360 = ___1740; break; case FieldDataType_Int32:  ___3360 = ___1743;  break; case FieldDataType_Int16:  ___3360 = ___1742;  break; case FieldDataType_Byte:   ___3360 = ___1739;   break; case ___1363:    ___3360 = ___1738;    break; default: ___476(___1303); break; } return ___3360; } static void SetFieldValueForFloat(___1359 ___1306, ___2226    ___3250, double       ___4299) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE("val can have any value"); ___1689(___1306)[___3250] = ___648(___4299); ENSURE(IsFieldDataValueInitialized<float>(___1306, ___3250)); } static void SetFieldValueForDouble(___1359 ___1306, ___2226    ___3250, double       ___4299) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306));
REQUIRE("val can have any value"); ___1683(___1306)[___3250] = ___487(___4299); ENSURE(IsFieldDataValueInitialized<double>(___1306, ___3250)); } static void SetFieldValueForInt32(___1359 ___1306, ___2226    ___3250, double       ___4299) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE("val can have any value"); ___1704(___1306)[___3250] = ___650(___4299); ENSURE(IsFieldDataValueInitialized<int32_t>(___1306, ___3250)); } static void SetFieldValueForInt16(___1359 ___1306, ___2226    ___3250, double       ___4299) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE("val can have any value"); ___1698(___1306)[___3250] = ___649(___4299); ENSURE(IsFieldDataValueInitialized<int16_t>(___1306, ___3250)); } static void SetFieldValueForByte(___1359 ___1306, ___2226    ___3250, double       ___4299) { REQUIRE(VALID_REF(___1306)); REQUIRE(___1725(___1306) == FieldDataType_Byte); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE("val can have any value"); ___1680(___1306)[___3250] = CONVERT_DOUBLE_TO_UINT8(___4299); ENSURE(IsFieldDataValueInitialized<uint8_t>(___1306, ___3250)); } static void SetFieldValueForBit(___1359 ___1306, ___2226    ___3250, double       ___4299) { REQUIRE(VALID_REF(___1306)); REQUIRE(___1725(___1306) == ___1363); REQUIRE(0 <= ___3250 && ___3250 < ___1716(___1306)); REQUIRE("val can have any value"); ___2226 ByteOffset = ___3250 / 8; uint8_t   BitMask    = (01 << (___3250 % 8)); if (___4299 < 1.0) ___1680(___1306)[ByteOffset] &= ~BitMask; else ___1680(___1306)[ByteOffset] |= BitMask; ENSURE(IsFieldDataValueInitialized<uint8_t>(___1306, ___3250 / 8)); } ___1382 DetermineFieldDataSetFunction(___1359 ___1349) { REQUIRE(VALID_REF(___1349)); ___1382 ___3360 = NULL; switch (___1725(___1349)) { case FieldDataType_Float:  ___3360 = SetFieldValueForFloat;  break; case FieldDataType_Double: ___3360 = SetFieldValueForDouble; break; case FieldDataType_Int32:  ___3360 = SetFieldValueForInt32;  break; case FieldDataType_Int16:  ___3360 = SetFieldValueForInt16;  break; case FieldDataType_Byte:   ___3360 = SetFieldValueForByte;   break; case ___1363:    ___3360 = SetFieldValueForBit;    break; default: ___476(___1303); break; } return ___3360; }
 #if !defined TECPLOTKERNEL
namespace {
 #endif
int64_t ___1357(___2226       ___2843, FieldDataType_e ___905) { int64_t ___3360 = 0; REQUIRE(___2843 >= 0); REQUIRE(VALID_FIELD_DATA_TYPE(___905)); switch (___905) { case FieldDataType_Float:  ___3360 = ((int64_t)___2843)*sizeof(float);         break; case FieldDataType_Double: ___3360 = ((int64_t)___2843)*sizeof(double);        break; case FieldDataType_Int32:  ___3360 = ((int64_t)___2843)*sizeof(int32_t);       break; case FieldDataType_Int16:  ___3360 = ((int64_t)___2843)*sizeof(int16_t);       break; case FieldDataType_Byte:   ___3360 = ((int64_t)___2843)*sizeof(uint8_t);       break; case ___1363:    ___3360 = ((int64_t)(___2843+7)/8)*sizeof(uint8_t); break; default: ___476(___1303); break; } ENSURE(___3360 >= 0); return ___3360; }
 #if !defined TECPLOTKERNEL
}
 #endif
 #if defined ___1994 || defined HPUX || defined ___3894
 # define SIZEOF_LARGEST_OBJECT_TO_ALIGN sizeof(int64_t)
 #else
 # define SIZEOF_LARGEST_OBJECT_TO_ALIGN sizeof(int32_t)
 #endif
void FieldDataReinitializeMetaData( ___1359    ___1349, ZoneType_e      ___4692, FieldDataType_e dataType, ValueLocation_e ___4326, ___372       isReadOnly, ___372       ___2063) { REQUIRE(VALID_REF(___1349)); REQUIRE(VALID_ENUM(___4692, ZoneType_e)); REQUIRE(VALID_FIELD_DATA_TYPE(dataType)); REQUIRE(VALID_ENUM(___4326, ValueLocation_e)); REQUIRE(VALID_BOOLEAN(isReadOnly)); REQUIRE(VALID_BOOLEAN(___2063)); REQUIRE(IMPLICATION(___2063, isReadOnly)); ___1354(___1349); ___1349->___4692      = ___4692; ___1349->___4335     = dataType; ___1349->___4327 = ___4326; { ___4279(isReadOnly); ___4279(___2063); ___1349->___1780 = DetermineFieldDataGetFunction(___1349); ___1349->___3507 = DetermineFieldDataSetFunction(___1349); } ENSURE(___1719(___1349) == NULL); }
 #if !defined TECPLOTKERNEL
namespace {
 #endif
___372 ___2316( ___1359 ___1350, ___372    ___3572) { REQUIRE(VALID_REF(___1350)); REQUIRE(___1725(___1350) != ___1367); REQUIRE(___1719(___1350) == NULL); REQUIRE(VALID_BOOLEAN(___3572)); int64_t ActualBytesNeeded = ___1357(___1716(___1350), ___1725(___1350)); size_t  BytesToAllocate   = (size_t)ActualBytesNeeded; ___476(sizeof(size_t) == 4 || sizeof(size_t) == 8); ___372 ___2039 = (___1716(___1350) <= ___2374 && IMPLICATION(sizeof(size_t) == 4, ActualBytesNeeded <= (int64_t)0xffffffff)); if (___2039) { if (___1716(___1350) > 0) { ___3488(___1350, (void*)___23(BytesToAllocate, char, "FieldData's Data"));
 #if defined DEBUG_FIELDVALUES
{ if (___1719(___1350) != NULL) memset(___1719(___1350), DEBUG_FIELDVALUES_BAD_VALUE, BytesToAllocate); }
 #endif
if (___1725(___1350) == ___1363 && ___1719(___1350) != NULL) ((char*)___1719(___1350))[BytesToAllocate-1] = '\0'; } ___2039 = (___1716(___1350) == 0 || ___1719(___1350) != NULL); if (!___2039 && ___3572) ___2890(); } else if (___3572) { ___1175(___4218("Storage limit (%lld) exceeded for a single variable."), (lldfmt_t)___2374); } ENSURE(VALID_REF(___1719(___1350)) || ___1719(___1350) == NULL); ENSURE(VALID_BOOLEAN(___2039)); return ___2039; }
 #if !defined TECPLOTKERNEL
}
 #endif
___372 ___1353( ___1359 ___1350, ___372    ___3572) { REQUIRE(VALID_REF(___1350)); REQUIRE(___1725(___1350) != ___1367); REQUIRE(___1719(___1350) == NULL); REQUIRE(VALID_BOOLEAN(___3572)); ___372 ___2038 = ___2316(___1350, ___3572); ENSURE(VALID_REF(___1719(___1350)) || ___1719(___1350) == NULL); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #if !defined NO_ASSERTS
 #endif
___1359 ___28(___2226       ___2843, FieldDataType_e ___4237, ___372       ___3572) { REQUIRE(___2843 >= 0); REQUIRE(VALID_FIELD_DATA_TYPE(___4237)); REQUIRE(VALID_BOOLEAN(___3572)); ___1359 ___3360 = ___1352(___2843,1,1); if (___3360 != NULL) { ___372 const isReadOnly = ___1303; ___372 const ___2063  = ___1303; FieldDataReinitializeMetaData(___3360, ___4704, ___4237, ___4330, isReadOnly, ___2063); if (!___1353(___3360, ___3572)) ___1355(&___3360, ___1303); } else if (___3572) { ___2890(); } ENSURE(VALID_REF(___3360) || ___3360 == NULL); ENSURE(IMPLICATION(___3360 != NULL, (___1716(___3360) >= 0                     && IMPLICATION(___1716(___3360) != 0, VALID_REF(___1719(___3360))) && VALID_FIELD_DATA_TYPE(___1725(___3360))))); return ___3360; } void ___936(___1359 *FieldDataRef) { ___1355(FieldDataRef, ___1303); }
 #if 0 
 #endif
void ___673(___1359  ___1119, ___2226     ___1122, ___1359  ___3657, ___2226     ___3662) { REQUIRE(VALID_REF(___1119)); REQUIRE(VALID_REF(___3657)); REQUIRE(___1122 >= 0 && ___1122 < ___1716(___1119) && ___3662 >= 0 && ___3662 < ___1716(___3657)); ___372 DoBruteForceCopy = ___4227; if (___2018(___3657) && ___2018(___1119) && ___1725(___3657) == ___1725(___1119)) { switch (___1725(___3657)) { case ___1366 : ___476(___1303); case FieldDataType_Double : { ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); uint64_t *dst_ptr = ___1677(___1119) + ___1122; uint64_t *src_ptr = ___1677(___3657) + ___3662; *dst_ptr = *src_ptr; DoBruteForceCopy = ___1303; } break; case FieldDataType_Float : case FieldDataType_Int32 : { ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); uint32_t *dst_ptr = ___1674(___1119) + ___1122; uint32_t *src_ptr = ___1674(___3657) + ___3662; *dst_ptr = *src_ptr; DoBruteForceCopy = ___1303; } break; case FieldDataType_Int16 : { ___476(sizeof(uint16_t) == 2); uint16_t *dst_ptr = ___1671(___1119) + ___1122; uint16_t *src_ptr = ___1671(___3657) + ___3662; *dst_ptr = *src_ptr; } break; case FieldDataType_Byte : { ___1680(___1119)[___1122] = ___1680(___3657)[___3662]; DoBruteForceCopy = ___1303; } break; case ___1363 : break; default : ___476(___1303); } } if (DoBruteForceCopy) { ___3491(___1119, ___1122, ___1734(___3657, ___3662)); } } void SetFieldDataArrayBytesToZero(___1359 ___1306) { REQUIRE(VALID_REF(___1306)); ___2226 NumBytesToMemSet = 0; ___2226 const ___2843 = ___1716(___1306); switch (___1725(___1306)) { case ___1366 : ___476(___1303); case FieldDataType_Double : { ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); NumBytesToMemSet = ___2843 * static_cast<___2226>(sizeof(int64_t)); } break; case FieldDataType_Int32 : case FieldDataType_Float : { ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); NumBytesToMemSet = ___2843 * static_cast<___2226>(sizeof(int32_t)); } break; case FieldDataType_Int16 : { ___476(sizeof(uint16_t) == 2); NumBytesToMemSet = ___2843 * static_cast<___2226>(sizeof(int16_t)); } break; case FieldDataType_Byte : { NumBytesToMemSet = ___2843 * static_cast<___2226>(sizeof(uint8_t)); } break; case ___1363 : { NumBytesToMemSet = ((___2843 + 7) / 8) * static_cast<___2226>(sizeof(uint8_t)); } break; default : { ___476(___1303); } break; } memset((char*)___1731(___1306), 0, NumBytesToMemSet); } void ___3487(___1359 ___1306) { REQUIRE(VALID_REF(___1306)); if (___2018(___1306)) { SetFieldDataArrayBytesToZero(___1306); } else { ___2226 const ___2843 = ___1716(___1306); for (___2226 ___1840 = 0; ___1840 < ___2843; ___1840++) ___3491(___1306, ___1840, 0.0); } }
