#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "IJKSubzoneInfo.h"
namespace tecplot { namespace ___3934 { ___372 IJKSubzoneInfo::getSubzonesOnIndexPlane( IJKPlanes_e                              whichPlane, ___81                               planeIndex, ___3270<ItemAddress64::SubzoneAddress>& szAddresses) const { REQUIRE(whichPlane == ___1866 || whichPlane == ___1871 || whichPlane == ___1873); REQUIRE(IMPLICATION(whichPlane == ___1866, planeIndex < m_zoneIJKDim.i()) && IMPLICATION(whichPlane == ___1871, planeIndex < m_zoneIJKDim.___2104()) && IMPLICATION(whichPlane == ___1873, planeIndex < m_zoneIJKDim.___2133())); REQUIRE(szAddresses.empty()); ___372 ___2038 = ___4227; try { switch (whichPlane) { case ___1866: { ___81 const iSzPlane = szIJKAtItemIJK(___1843(planeIndex,0,0)).i(); size_t const ___2813 = m_subzoneTilingIJKDim.___2104()*m_subzoneTilingIJKDim.___2133(); szAddresses.reserve(___2813); szAddresses.___3504(___2813); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 kSz = 0; kSz < m_subzoneTilingIJKDim.___2133(); ++kSz ) { for ( ___81 jSz = 0; jSz < m_subzoneTilingIJKDim.___2104(); ++jSz ) { *szArray = szAddressAtSzIJK(___1843(iSzPlane,jSz,kSz)); ++szArray; } } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; case ___1871: { ___81 const jSzPlane = szIJKAtItemIJK(___1843(0,planeIndex,0)).___2104(); size_t const ___2813 = m_subzoneTilingIJKDim.i()*m_subzoneTilingIJKDim.___2133(); szAddresses.reserve(___2813); szAddresses.___3504(___2813); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 kSz = 0; kSz < m_subzoneTilingIJKDim.___2133(); ++kSz ) { for ( ___81 iSz = 0; iSz < m_subzoneTilingIJKDim.i(); ++iSz ) { *szArray = szAddressAtSzIJK(___1843(iSz,jSzPlane,kSz)); ++szArray; } } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; case ___1873: { ___81 const kSzPlane = szIJKAtItemIJK(___1843(0,0,planeIndex)).___2133(); size_t const ___2813 = m_subzoneTilingIJKDim.i()*m_subzoneTilingIJKDim.___2104(); szAddresses.reserve(___2813); szAddresses.___3504(___2813); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 jSz = 0; jSz < m_subzoneTilingIJKDim.___2104(); ++jSz ) { for ( ___81 iSz = 0; iSz < m_subzoneTilingIJKDim.i(); ++iSz ) { *szArray = szAddressAtSzIJK(___1843(iSz,jSz,kSzPlane)); ++szArray; } } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; default: ___476(___1303); break; } } catch (...) { ___2038 = ___1184("getSubzonesOnIndexPlane failed"); } ENSURE(IMPLICATION(___2038, !szAddresses.empty())); ENSURE(IMPLICATION(___2038, std::is_sorted(szAddresses.begin(), szAddresses.end()))); ENSURE(IMPLICATION(___2038, szAddresses[szAddresses.size()-1].subzoneOffset() < getNumSzs())); return ___2038; } ___372 IJKSubzoneInfo::getSubzonesOnIndexLine( IJKLines_e                               whichLine, ___81                               mIndex, ___81                               nIndex, ___3270<ItemAddress64::SubzoneAddress>& szAddresses) const {
REQUIRE(whichLine == ___1856 || whichLine == ___1858 || whichLine == ___1859); REQUIRE(IMPLICATION(whichLine == ___1856, mIndex < m_zoneIJKDim.___2104() && nIndex < m_zoneIJKDim.___2133()) && IMPLICATION(whichLine == ___1858, mIndex < m_zoneIJKDim.i() && nIndex < m_zoneIJKDim.___2133()) && IMPLICATION(whichLine == ___1859, mIndex < m_zoneIJKDim.i() && nIndex < m_zoneIJKDim.___2104())); REQUIRE(szAddresses.empty()); ___372 ___2038 = ___4227; try { switch (whichLine) { case ___1856: { ___1843 const ijkSzBase(szIJKAtItemIJK(___1843(0,mIndex,nIndex))); ___81 const jSzBase = ijkSzBase.___2104(); ___81 const kSzBase = ijkSzBase.___2133(); size_t const ___2813 = m_subzoneTilingIJKDim.i(); szAddresses.reserve(___2813); szAddresses.___3504(___2813); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 iSz = 0; iSz < m_subzoneTilingIJKDim.i(); ++iSz ) { *szArray = szAddressAtSzIJK(___1843(iSz,jSzBase,kSzBase)); ++szArray; } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; case ___1858: { ___1843 const ijkSzBase(szIJKAtItemIJK(___1843(mIndex,0,nIndex))); ___81 const iSzBase = ijkSzBase.i(); ___81 const kSzBase = ijkSzBase.___2133(); size_t const ___2813 = m_subzoneTilingIJKDim.___2104(); szAddresses.reserve(___2813); szAddresses.___3504(___2813); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 jSz = 0; jSz < m_subzoneTilingIJKDim.___2104(); ++jSz ) { *szArray = szAddressAtSzIJK(___1843(iSzBase,jSz,kSzBase)); ++szArray; } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; case ___1859: { ___1843 const ijkSzBase(szIJKAtItemIJK(___1843(mIndex,nIndex,0))); ___81 const iSzBase = ijkSzBase.i(); ___81 const jSzBase = ijkSzBase.___2104(); size_t const ___2813 = m_subzoneTilingIJKDim.___2133(); szAddresses.reserve(___2813); szAddresses.___3504(___2813); ItemAddress64::SubzoneAddress* szArray = szAddresses.data(); for ( ___81 kSz = 0; kSz < m_subzoneTilingIJKDim.___2133(); ++kSz ) { *szArray = szAddressAtSzIJK(___1843(iSzBase,jSzBase,kSz)); ++szArray; } ___476(static_cast<size_t>(szArray-szAddresses.data())==szAddresses.size()); } break; default: ___476(___1303); break; } } catch (...) { ___2038 = ___1184("getSubzonesOnIndexPlane failed"); } ENSURE(IMPLICATION(___2038, !szAddresses.empty())); ENSURE(IMPLICATION(___2038, std::is_sorted(szAddresses.begin(), szAddresses.end()))); ENSURE(IMPLICATION(___2038, szAddresses[szAddresses.size()-1].___2978()==m_partition)); ENSURE(IMPLICATION(___2038, szAddresses[szAddresses.size()-1].subzoneOffset() < getNumSzs())); return ___2038; } }}
