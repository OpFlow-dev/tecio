#include "SZLFEZoneWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <utility>
#include <boost/assign.hpp>
#include <boost/bind/bind.hpp>
#include <boost/function.hpp>
#include <boost/make_shared.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
 #if !defined TECIOMPI
#include "AtomicMinMax.h"
 #endif
#include "BitArray.h"
#include "checkPercentDone.h"
#include "FECellSubzoneCompressor.h"
#include "FieldData.h"
#include "gatherOffsets.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
#include "NodeMap.h"
#include "writeValueArray.h"
 #define MINMAX_MAX_TASKS_PER_CORE 2 
 #define MINMAX_MIN_CSZ_TASK_SIZE 16 
 #define MINMAX_MIN_NODE_TASK_SIZE 16 
 #define FEWRITER_MIN_CSZS_PER_CHUNK 1000 
 #define FEWRITER_MAX_CSZS_PER_CHUNK 1000 
namespace tecplot { namespace ___3934 { SZLFEZoneWriter::SZLFEZoneWriter( uint32_t                                   fileVersion, ItemSetIterator&                           varIter, ___4636                                zone, ___4636                                ___341, std::vector<___372> const&              ___4564, ___372                                  ___4499, ___37&                                ___36, boost::shared_ptr<___1348 const> const& zoneInfo) : ___4709(fileVersion, varIter, zone, ___341, ___4564, ___4499, ___36) , m_headerWriter(fileVersion, varIter, zone, ___341, ___36, *zoneInfo, (___4499 == ___4227), ___2674, m_secCszConnectivityFileLocs, m_nszConnectivityFileLocs, m_secNumCszs, m_secNumRefNodeSubzones, m_numRefCellSubzones, m_secCszIncludesPartitionOffsetsBitArray, m_nszIncludesPartitionOffsetsBitArray) , m_feZoneInfo(zoneInfo) , m_zoneNumberLabel(SZPLT_ZONE_NUM_DESCRIPTION) { ___4352 const numVarsToWrite = m_varIter.___2813(); if (!___2674.alloc(numVarsToWrite, ___330)) { std::ostringstream ___2893; ___2893 << "Unable to allocate arrays for outputting zone " << zone; throw std::runtime_error(___2893.str()); } } SZLFEZoneWriter::~SZLFEZoneWriter() {} void SZLFEZoneWriter::setZoneNumberLabel(std::string const& zoneNumberLabel) { REQUIRE(!zoneNumberLabel.empty()); m_zoneNumberLabel = zoneNumberLabel; } namespace { template <typename NODE_TYPE> void calculateAndApplyCellMinMaxesUsingNodesOfType( ItemAddress64::SectionOffset_t                                           section, std::pair<ItemAddress64::SubzoneOffset_t,ItemAddress64::SubzoneOffset_t> cellSubzoneRange, ___1348 const&                                                        ___1347, ___2725 const&                                                           ___2724, ___1350 const&                                                         nlFieldData, ___1350 const&                                                         ccFieldData,
 #if defined TECIOMPI
___2482&                                                         cszMinMaxArray, ___2482&                                                         ___2763
 #else
___2241<___225<double> >&                            cszMinMaxArray, ___2241<___225<double> >&                            ___2763
 #endif
) { REQUIRE(___2724.___2066()); REQUIRE(nlFieldData.___2066()); int32_t const numNodesPerCell = ___1347.getNumNodesPerCell(section); boost::array<NODE_TYPE,MAX_NODES_PER_ELEM> elemNodes; ___81 const baseCell = ccFieldData.___2066() ? ___1347.baseCellAtSection(section) : 0; for (ItemAddress64::SubzoneOffset_t ___467 = cellSubzoneRange.first; ___467 < cellSubzoneRange.second; ++___467) { ItemAddress64::ItemOffset_t const ___2783 = ___1347.___2783(section, ___467); for (ItemAddress64::ItemOffset_t cszOffset = 0; cszOffset < ___2783; cszOffset++) { ItemAddress64 const ___686(ItemAddress64::UNKNOWN_PARTITION, section, ___467, cszOffset); ___463 const zoneCell = ___1347.cellAtItemAddress(___686); ___2724.getElemNodes<NODE_TYPE>(section+1, zoneCell+1, 1, elemNodes.data()); ___2480 cellMinMax; for (int32_t nOffset = 0; nOffset < numNodesPerCell; ++nOffset) cellMinMax.include(nlFieldData.___1779(elemNodes[nOffset])); for (int32_t nOffset = 0; nOffset < numNodesPerCell; ++nOffset) { ItemAddress64 const& ___2760 = ___1347.itemAddressAtNode(elemNodes[nOffset]-1); ItemAddress64::___2981 const ___2978 = ___2760.___2978(); if (___2978 == ___1347.getPartition()) { ItemAddress64::SubzoneOffset_t const ___2735 = ___2760.subzoneOffset(); ___2763[___2735].include(cellMinMax); } } if ( ccFieldData.___2066() ) cellMinMax.include(ccFieldData.___1779(baseCell + zoneCell + 1)); cszMinMaxArray[___467].include(cellMinMax); } } } } namespace { void calculateAndApplyCellMinMaxes( ItemAddress64::SectionOffset_t                                           section, std::pair<ItemAddress64::SubzoneOffset_t,ItemAddress64::SubzoneOffset_t> cellSubzoneRange, ___1348 const&                                                        ___1347, ___2725 const&                                                           ___2724, ___1350 const&                                                         nlFieldData, ___1350 const&                                                         ccFieldData,
 #if defined TECIOMPI
___2482&                                                         cszMinMaxArray, ___2482&                                                         ___2763
 #else
___2241<___225<double> >&                            cszMinMaxArray, ___2241<___225<double> >&                            ___2763
 #endif
) { if (___2724.getOffsetDataType() == OffsetDataType_32Bit) calculateAndApplyCellMinMaxesUsingNodesOfType<int32_t>( section, cellSubzoneRange, ___1347, ___2724, nlFieldData, ccFieldData, cszMinMaxArray, ___2763); else calculateAndApplyCellMinMaxesUsingNodesOfType<int64_t>( section, cellSubzoneRange, ___1347, ___2724, nlFieldData, ccFieldData, cszMinMaxArray, ___2763); } } namespace {
 #if !defined TECIOMPI
void applyNodalValuesToNodeSubzoneMinMaxes( ___2719 nodeStart, ___2719 nodeEnd, ___1350 const& ___1349, ___1348 const& ___1347, boost::unordered_set<___2719> const& ghostNodeSet,
 #if defined TECIOMPI
___2482& ___2763
 #else
___2241<___225<double> >& ___2763
 #endif
) { REQUIRE(___1349.___2066()); for (___2719 ___4656 = nodeStart; ___4656 < nodeEnd; ++___4656) { if (ghostNodeSet.find(___4656) == ghostNodeSet.end()) { double const ___4299 = ___1349.___1779(___4656 + 1); ItemAddress64 const& ___2760 = ___1347.itemAddressAtNode(___4656); ___476 (___2760.___2978() == ___1347.getPartition()); ItemAddress64::SubzoneOffset_t const ___2758 = ___2760.subzoneOffset(); ___2763[___2758].include(___4299); } } } typedef boost::function<void(void)> VoidFunction; void threadPoolJob(___90 ___2122) { VoidFunction* voidFunction = reinterpret_cast<VoidFunction*>(___2122); (*voidFunction)(); delete voidFunction; } ___372 calculateAndApplyCellMinMaxesMultithreaded( ___37&                     ___36, ___1348 const&               ___1347, ___4636                     zone, ___2725&                        ___2724, ___1350 const&                nlFieldData, ___1350 const&                ccFieldData, ___2241<___2482>& secCszMinMaxArray, ___2482&                    ___2763) { ___2241<___2241<___225<double> > > atomicSecCszMinMaxArray; ___2241<___225<double> > atomicNszMinMaxArray; ItemAddress64::SubzoneOffset_t const ___2824 = ___1347.___2824(); ___372 ___2038 = atomicNszMinMaxArray.alloc(___2824); ___2038 = ___2038 && atomicSecCszMinMaxArray.alloc(___1347.getNumSections()); for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < ___1347.getNumSections(); ++section) ___2038 = atomicSecCszMinMaxArray[section].alloc(___1347.numCszsInSection(section)); if (___2038) { size_t const maxNumTasks = static_cast<size_t>(___36.___4158() * MINMAX_MAX_TASKS_PER_CORE); ___2119 ___2118 = ___36.___4159(); for (ItemAddress64::SectionOffset_t section = 0; section < ___1347.getNumSections(); ++section) { ItemAddress64::SubzoneOffset_t const ___2784 = ___1347.numCszsInSection(section); size_t const numCszTasksAtMinJobSize = static_cast<size_t>(___2784 + MINMAX_MIN_CSZ_TASK_SIZE - 1) / MINMAX_MIN_CSZ_TASK_SIZE; size_t const numCszTasks = std::min(numCszTasksAtMinJobSize, maxNumTasks); ItemAddress64::SubzoneOffset_t cellSubzoneStart = 0; for (size_t task = 1; task <= numCszTasks; ++task) { ItemAddress64::SubzoneOffset_t const cellSubzoneEnd = static_cast<ItemAddress64::SubzoneOffset_t>(___2784 * task / numCszTasks); ___476(cellSubzoneStart < cellSubzoneEnd); VoidFunction* voidFunction = new VoidFunction(boost::bind( &calculateAndApplyCellMinMaxes, section, std::make_pair(cellSubzoneStart,cellSubzoneEnd), boost::ref(___1347), boost::ref(___2724), boost::ref(nlFieldData), boost::ref(ccFieldData), boost::ref(atomicSecCszMinMaxArray[section]), boost::ref(atomicNszMinMaxArray))); ___36.___4157(threadPoolJob, (___90)voidFunction, ___2118); cellSubzoneStart = cellSubzoneEnd; } } ___2719 const ___2822 = ___1347.___1767();
size_t const numNodesTasksAtMinJobSize = static_cast<size_t>(___2822 + MINMAX_MIN_NODE_TASK_SIZE - 1) / MINMAX_MIN_NODE_TASK_SIZE; size_t const numNodeTasks = std::min(numNodesTasksAtMinJobSize, maxNumTasks); boost::unordered_set<___2719> ghostNodeSet; GhostInfo_pa ghostNodeInfo = ___36.zoneGhostNodeInfoGetRef(zone + 1); if (ghostNodeInfo) { for (___81 i = 0; i < ___36.ghostInfoGetNumItemsByRef(ghostNodeInfo,1 ); ++i) ghostNodeSet.insert(static_cast<___2719>(___36.ghostInfoGetItemByRef(ghostNodeInfo,1 ,i+1) - 1)); } ___2719 nodeStart = 0; for (size_t task = 1; task <= numNodeTasks; ++task) { ___2719 const nodeEnd = static_cast<___2719>(___2822 * task / numNodeTasks); ___476(nodeStart < nodeEnd); VoidFunction *voidFunction = new VoidFunction(boost::bind( applyNodalValuesToNodeSubzoneMinMaxes, nodeStart, nodeEnd, nlFieldData, boost::ref(___1347), boost::ref(ghostNodeSet), boost::ref(atomicNszMinMaxArray))); ___36.___4157(threadPoolJob, (___90)voidFunction, ___2118); nodeStart = nodeEnd; } ___36.___4162(___2118); ___36.___4160(&___2118); if (___2038) { for (ItemAddress64::SectionOffset_t section = 0; section < ___1347.getNumSections(); ++section) { ItemAddress64::SubzoneOffset_t const ___2784 = ___1347.numCszsInSection(section); for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___2784; ++___467) { ___476(atomicSecCszMinMaxArray[section][___467].___2066()); secCszMinMaxArray[section][___467].include(atomicSecCszMinMaxArray[section][___467].minValue()); secCszMinMaxArray[section][___467].include(atomicSecCszMinMaxArray[section][___467].maxValue()); } } atomicSecCszMinMaxArray.___935(); for (ItemAddress64::SubzoneOffset_t ___2735 = 0; ___2038 && ___2735 < ___2824; ++___2735) { ___476(atomicNszMinMaxArray[___2735].___2066()); ___2763[___2735].include(atomicNszMinMaxArray[___2735].minValue()); ___2763[___2735].include(atomicNszMinMaxArray[___2735].maxValue()); } atomicNszMinMaxArray.___935(); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #endif 
___372 ___1666( ___37&                     ___36, ___1348 const&               ___1347, ___4636                     zone, ___4352                      fileVar, ___1350 const&                nlFieldData, ___1350 const&                ccFieldData, ___2241<___2482>& secCszMinMaxArray, ___2482&                    ___2763) { REQUIRE(zone >= 0); REQUIRE(fileVar >= 0); REQUIRE(nlFieldData.___2066()); REQUIRE("ccFieldData might be invalid if not CC data"); ___372 ___2038 = ___4227; ___2730 ___2724 = boost::make_shared<___2725>(&___36, zone + 1); if (!___2724->___2066()) ___2038 = ___1303; if (___2038) {
 #ifndef NO_ASSERTS
ItemAddress64::SubzoneOffset_t const ___2824 = ___1347.___2824(); for (ItemAddress64::SubzoneOffset_t ___2735 = 0; ___2735 < ___2824; ___2735++) ___476(!___2763[___2735].___2066()); for (ItemAddress64::SectionOffset_t section = 0; section < ___1347.getNumSections(); ++section) for (ItemAddress64::SubzoneOffset_t ___467 = 0; ___467 < ___1347.numCszsInSection(section); ___467++) ___476(!secCszMinMaxArray[section][___467].___2066());
 #endif
___1348::NszMinMaxMap const& nszMinMaxes = ___1347.getNszMinMaxes(); for (___1348::NszMinMaxMap::const_iterator valuePair = nszMinMaxes.begin(); valuePair != nszMinMaxes.end(); ++valuePair) { ___2763[valuePair->first].include(valuePair->second[fileVar]); }
 #if defined TECIOMPI
for (ItemAddress64::SectionOffset_t section = 0; section < ___1347.getNumSections(); ++section) calculateAndApplyCellMinMaxes( section, std::make_pair(0,___1347.numCszsInSection(section)), ___1347, *___2724, nlFieldData, ccFieldData, secCszMinMaxArray[section], ___2763);
 #else
___2038 = calculateAndApplyCellMinMaxesMultithreaded( ___36, ___1347, zone, *___2724, nlFieldData, ccFieldData, secCszMinMaxArray, ___2763);
 #endif
} ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } ___372 SZLFEZoneWriter::calculateVarSubzoneMinMaxes( ___4352                      datasetVar, ___2482&                    ___2763, ___2241<___2482>& secCszMinMaxArray) { REQUIRE(secCszMinMaxArray.empty()); REQUIRE(___2763.empty()); REQUIRE(m_writeVariables[datasetVar - m_varIter.baseItem()]); ___372 ___2038 = ___4227; ___2038 = ___2038 && ___2763.alloc(m_feZoneInfo->___2824(), ___2480()); ___2038 = ___2038 && secCszMinMaxArray.alloc(m_feZoneInfo->getNumSections()); for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < m_feZoneInfo->getNumSections(); ++section) ___2038 = secCszMinMaxArray[section].alloc(m_feZoneInfo->numCszsInSection(section), ___2480()); if (___2038) { if (___2338.___908(___2678 + 1, datasetVar + 1) == ___4330) { ___1350 nlFieldData(&___2338, ___2678 + 1, datasetVar + 1, false , false/*___962*/); ___1350 ccFieldData; ___2038 = nlFieldData.___2066() && ___1666(___2338, *m_feZoneInfo, ___2678, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, secCszMinMaxArray, ___2763); } else { ___1350 nlFieldData(&___2338, ___2678 + 1, datasetVar + 1, false , true/*___962*/); ___1350 ccFieldData(&___2338, ___2678 + 1, datasetVar + 1, false , false/*___962*/); ___2038 = nlFieldData.___2066() && ccFieldData.___2066() && ___1666(___2338, *m_feZoneInfo, ___2678, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, secCszMinMaxArray, ___2763); } } return ___2038; } ___372 SZLFEZoneWriter::___4501( FileWriterInterface&           file, ItemAddress64::SubzoneOffset_t ___467) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); if (file.___2001()) { ___2038 = writeValue<uint32_t, false, 0>(file, "cszConnectivityMarker*", SZPLT_CSZ_CONNECTIVITY_MARKER) && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2678 - m_baseZone + 1)) && writeValue<uint64_t, false, 0>(file, "subzoneNum*", ___467 + 1); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } uint64_t SZLFEZoneWriter::cszConnectivityHeaderFileSize(bool ___2001) { uint64_t ___3359 = 0; if (___2001) { ___3359 += 2 * valueSizeInFile<uint32_t, false>(___2001) + valueSizeInFile<uint64_t, false>(___2001); } return ___3359; } ___372 SZLFEZoneWriter::___4500( FileWriterInterface&             file, ItemAddress64::SectionOffset_t   section, ___1337 const&   compressor, bool                             outputPartitionIndices) { REQUIRE(file.___2040()); ___372 ___2038 = ___4227; if (outputPartitionIndices) { if (compressor.numRefPartitions() <= MAX_REFS_FOR_2_BIT_COMPRESSION) { uint8_t const* refPtn2BitOffsets = compressor.refPtn2BitOffsets(); ___2038 = ___2038 && ___4563<uint8_t, true, 0>(file, "refPtn2BitOffsets", ___2746, compressor.refPtnOffsetsNumBytes(), refPtn2BitOffsets, ___944 / 4); } else if (compressor.numRefPartitions() <= MAX_REFS_FOR_4_BIT_COMPRESSION)
{ uint8_t const* refPtn4BitOffsets = compressor.refPtn4BitOffsets(); ___2038 = ___2038 && ___4563<uint8_t, true, 0>(file, "refPtn4BitOffsets", ___2746, compressor.refPtnOffsetsNumBytes(), refPtn4BitOffsets, ___944 / 2); } else if (compressor.numRefPartitions() <= MAX_REFS_FOR_8_BIT_COMPRESSION) { uint8_t const* refPtn8BitOffsets = compressor.refPtn8BitOffsets(); ___2038 = ___2038 && ___4563<uint8_t, true, 0>(file, "refPtn8BitOffsets", ___2746, compressor.refPtnOffsetsNumBytes(), refPtn8BitOffsets); } else { ___476(compressor.refPtnOffsetsNumBytes() == 0); uint16_t const* refPtn16BitOffsets = compressor.refPtn16BitOffsets(); ___2038 = ___2038 && ___4563<uint16_t, true, 0>(file, "refPtn16BitOffsets", ___2746, compressor.numRefNszs(), refPtn16BitOffsets); } } ___2038 = ___2038 && ___4563<uint32_t, false, 1>(file, CSZ_CONNECT_REF_NSZ_ARRAY_DESCRIPTION, ___2746, compressor.numRefNszs(), &compressor.___3320()[0]); size_t ___2796 = static_cast<size_t>(compressor.___2783() * m_feZoneInfo->getNumNodesPerCell(section)); if (compressor.numRefNszs() <= MAX_REFS_FOR_2_BIT_COMPRESSION) { uint8_t const* refNsz2BitOffsets = compressor.refNsz2BitOffsets(); ___2038 = ___2038 && ___4563<uint8_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_2BIT_ARRAY_DESCRIPTION, ___2746, compressor.refNszOffsetsNumBytes(), refNsz2BitOffsets, m_feZoneInfo->getNumNodesPerCell(section)/4); } else if (compressor.numRefNszs() <= MAX_REFS_FOR_4_BIT_COMPRESSION) { uint8_t const* ___3322 = compressor.___3322(); ___2038 = ___2038 && ___4563<uint8_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_4BIT_ARRAY_DESCRIPTION, ___2746, compressor.refNszOffsetsNumBytes(), ___3322, m_feZoneInfo->getNumNodesPerCell(section)/2); } else if (compressor.numRefNszs() <= MAX_REFS_FOR_8_BIT_COMPRESSION) { uint8_t const* ___3323 = compressor.___3323(); ___2038 = ___2038 && ___4563<uint8_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_8BIT_ARRAY_DESCRIPTION, ___2746, compressor.refNszOffsetsNumBytes(), ___3323, m_feZoneInfo->getNumNodesPerCell(section)); } else { ___476(compressor.refNszOffsetsNumBytes() == 0); uint16_t const* ___3321 = compressor.___3321(); ___2038 = ___2038 && ___4563<uint16_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_16BIT_ARRAY_DESCRIPTION, ___2746, ___2796, ___3321, m_feZoneInfo->getNumNodesPerCell(section)); } uint8_t const* ___2765 = compressor.___2765(); ___2038 = ___2038 && ___4563<uint8_t, false, 0>(file, CSZ_CONNECT_NSZ_OFFSET_ARRAY_DESCRIPTION, ___2746, ___2796, ___2765, m_feZoneInfo->getNumNodesPerCell(section)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } uint64_t SZLFEZoneWriter::cszConnectivityDataFileSize( bool ___2001, size_t totalNumCellNodes, size_t numRefNszs, ItemAddress64::___2981 numRefPartitions, bool outputPartitionIndices) { uint64_t ___3359 = 0; if (outputPartitionIndices)
{ if (numRefPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) ___3359 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,2>::byteArraySize(numRefNszs), ___2001); else if (numRefPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) ___3359 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,4>::byteArraySize(numRefNszs), ___2001); else if (numRefPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION) ___3359 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,8>::byteArraySize(numRefNszs), ___2001); else ___3359 += arraySizeInFile<uint16_t, true  >(numRefNszs, ___2001); } ___3359 += arraySizeInFile<uint32_t, false>(numRefNszs, ___2001); if (numRefNszs <= MAX_REFS_FOR_2_BIT_COMPRESSION) ___3359 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,2>::byteArraySize(totalNumCellNodes), ___2001); else if (numRefNszs <= MAX_REFS_FOR_4_BIT_COMPRESSION) ___3359 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,4>::byteArraySize(totalNumCellNodes), ___2001); else if (numRefNszs <= MAX_REFS_FOR_8_BIT_COMPRESSION) ___3359 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,8>::byteArraySize(totalNumCellNodes), ___2001); else ___3359 += arraySizeInFile<uint16_t, true  >(totalNumCellNodes, ___2001); ___3359 += arraySizeInFile<uint8_t, false>(totalNumCellNodes, ___2001); return ___3359; } struct CompressSubzoneJobData { ___2241<___1337>* m_compressorVector; ___2730 ___2498; ___1348 const* m_feZoneInfo; ItemAddress64::SectionOffset_t m_section; ItemAddress64::SubzoneOffset_t m_compressorBegin; ItemAddress64::SubzoneOffset_t m_subzoneBegin; ItemAddress64::SubzoneOffset_t m_subzoneCount; }; template <typename NODE_TYPE> void compressSubzoneJob(___90 ___2122) { CompressSubzoneJobData* compressSubzoneJobData = reinterpret_cast<CompressSubzoneJobData*>(___2122); ___2241<___1337>& compressorVector = *compressSubzoneJobData->m_compressorVector; ___2730 ___2724 = compressSubzoneJobData->___2498; ___1348 const& ___1347 = *compressSubzoneJobData->m_feZoneInfo; ItemAddress64::SectionOffset_t const section = compressSubzoneJobData->m_section; ItemAddress64::SubzoneOffset_t const compressorBegin = compressSubzoneJobData->m_compressorBegin; ItemAddress64::SubzoneOffset_t const subzoneBegin = compressSubzoneJobData->m_subzoneBegin; ItemAddress64::SubzoneOffset_t const subzoneCount = compressSubzoneJobData->m_subzoneCount; for (ItemAddress64::SubzoneOffset_t i = 0; i < subzoneCount; ++i) { ItemAddress64::SubzoneOffset_t const whichCompressor = compressorBegin + i; ItemAddress64::SubzoneOffset_t const ___3881 = subzoneBegin + i; ___1337& feCellSubzoneCompressor = compressorVector[whichCompressor]; feCellSubzoneCompressor.___534<NODE_TYPE>(___2724, ___1347, section, ___3881); } } ___372 SZLFEZoneWriter::writeCszConnectivity( FileWriterInterface&    szpltFile, ___2730              ___2724, SubzoneAddressSetArray& nszRefPtnCszSets) { REQUIRE(szpltFile.___2040()); REQUIRE(___2724->___2066()); REQUIRE(nszRefPtnCszSets.size() == size_t(m_feZoneInfo->___2824()));
___372 ___2038 = ___4227; ___2119 ___2118 = ___2338.___4159();
 #if defined OUTPUT_TIMES
uint64_t compressTime = 0; uint64_t ___4549 = 0; uint64_t ___3688 = ___715();
 #endif
for (ItemAddress64::SectionOffset_t section = 0; section < m_feZoneInfo->getNumSections(); ++section) { size_t const ___2784 = checked_numeric_cast<size_t>(m_feZoneInfo->numCszsInSection(section)); if (___2784 == 0) continue; size_t const ___2828 = size_t(___2338.___4158()); size_t const numChunks = 1 + (___2784-1)/FEWRITER_MIN_CSZS_PER_CHUNK; size_t const numTasks = std::min(___2828, numChunks); size_t const subzonesPerTask = std::min<size_t>(static_cast<size_t>(FEWRITER_MAX_CSZS_PER_CHUNK), 1 + (___2784-1)/numTasks); size_t const subzonesPerChunk = numTasks * subzonesPerTask; ___2241<CompressSubzoneJobData> compressSubzoneJobDataVector; if (!compressSubzoneJobDataVector.alloc(numTasks)) throw std::bad_alloc(); for (size_t task = 0; task < numTasks; ++task) { compressSubzoneJobDataVector[task].___2498 = ___2724; compressSubzoneJobDataVector[task].m_feZoneInfo = m_feZoneInfo.get(); } ___2241<___1337> compressorVector; if (!compressorVector.alloc(subzonesPerChunk)) throw std::bad_alloc(); for (size_t chunkSubzoneBegin = 0; ___2038 && chunkSubzoneBegin < ___2784; chunkSubzoneBegin += subzonesPerChunk) { size_t const chunkSubzoneEnd = std::min(chunkSubzoneBegin + subzonesPerChunk, static_cast<size_t>(___2784)); size_t const numCszsThisChunk = chunkSubzoneEnd-chunkSubzoneBegin; size_t const subzonesPerTaskThisChunk = 1 + (numCszsThisChunk-1)/numTasks; size_t const numTasksThisChunk = 1 + (numCszsThisChunk-1)/subzonesPerTaskThisChunk; for(size_t task = 0; task < numTasksThisChunk; ++task) { size_t const threadSubzoneBegin = chunkSubzoneBegin + task * subzonesPerTaskThisChunk; size_t const threadSubzoneEnd = std::min(threadSubzoneBegin + subzonesPerTaskThisChunk, static_cast<size_t>(___2784)); CompressSubzoneJobData* compressSubzoneJobData = &compressSubzoneJobDataVector[task]; compressSubzoneJobData->m_compressorVector = &compressorVector; compressSubzoneJobData->m_section = section; compressSubzoneJobData->m_subzoneBegin = ItemAddress64::SubzoneOffset_t(threadSubzoneBegin); compressSubzoneJobData->m_subzoneCount = ItemAddress64::SubzoneOffset_t(threadSubzoneEnd - threadSubzoneBegin); compressSubzoneJobData->m_compressorBegin = ItemAddress64::SubzoneOffset_t(threadSubzoneBegin - chunkSubzoneBegin); if (___2724->getOffsetDataType() == OffsetDataType_32Bit) ___2338.___4157(compressSubzoneJob<int32_t>, (___90)compressSubzoneJobData, ___2118); else ___2338.___4157(compressSubzoneJob<int64_t>, (___90)compressSubzoneJobData, ___2118); } ___2338.___4162(___2118);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); compressTime += (___1165 - ___3688); ___3688 = ___1165;
 #endif
___4636 const fileZone = ___2678 - m_baseZone; for(ItemAddress64::SubzoneOffset_t ___684 = ItemAddress64::SubzoneOffset_t(chunkSubzoneBegin); ___2038 && ___684 < ItemAddress64::SubzoneOffset_t(chunkSubzoneEnd); ++___684) { m_secCszConnectivityFileLocs[section][___684] = szpltFile.fileLoc(); ___1337& feCellSubzoneCompressor = compressorVector[___684 - chunkSubzoneBegin]; ItemAddress64::SubzoneOffset_t const numRefNszs = feCellSubzoneCompressor.numRefNszs(); bool outputPartitionIndices = false; for(ItemAddress64::SubzoneOffset_t ___3324 = 0; ___3324 < numRefNszs; ++___3324) { ItemAddress64::___2981 ___2978 = feCellSubzoneCompressor.refPtnNszs()[___3324].___2978(); if (___2978 == ItemAddress64::INVALID_PARTITION || static_cast<___4636>(___2978) == fileZone) { ItemAddress64::SubzoneOffset_t const ___2758 = feCellSubzoneCompressor.refPtnNszs()[___3324].subzoneOffset(); ItemAddress64::SubzoneAddress const ptnCsz(fileZone, section, ___684); nszRefPtnCszSets[___2758].insert(ptnCsz); } else { outputPartitionIndices = true; } } ___2038 = ___2038 && ___4501(szpltFile, ___684); ___2038 = ___2038 && ___4500(szpltFile, section, compressorVector[___684 - chunkSubzoneBegin], outputPartitionIndices); if (outputPartitionIndices) setBit(m_secCszIncludesPartitionOffsetsBitArray[section], ___684); m_secNumRefNodeSubzones[section][___684] = compressorVector[___684 - chunkSubzoneBegin].numRefNszs(); }
 #if defined OUTPUT_TIMES
___1165 = ___715(); ___4549 += (___1165 - ___3688); ___3688 = ___1165;
 #endif
} }
 #if defined OUTPUT_TIMES
___1930(NULL, "%g seconds compressing cell subzones.", (double)(compressTime) / 1000.0); ___1930(NULL, "%g seconds writing cell subzones.", (double)(___4549) / 1000.0);
 #endif
___2338.___4160(&___2118); return ___2038; } template <typename NODE_TYPE> uint64_t SZLFEZoneWriter::cszConnectivityFileSize( ___2725 const&          ___2724, bool                    ___2001, SubzoneAddressSetArray& nszRefPtnCszSets) { uint64_t ___3359 = m_feZoneInfo->___2784() * cszConnectivityHeaderFileSize(___2001); boost::array<NODE_TYPE,MAX_NODES_PER_ELEM> elemNodes; ItemAddress64::SectionOffset_t const numSections = m_feZoneInfo->getNumSections(); for (ItemAddress64::SectionOffset_t section = 0; section < numSections; ++section) { int32_t const numNodesPerCell = m_feZoneInfo->getNumNodesPerCell(section); ___4636 const fileZone = ___2678 - m_baseZone; for(ItemAddress64::SubzoneOffset_t ___684 = 0; ___684 < m_feZoneInfo->numCszsInSection(section); ++___684) { SubzoneAddressUnorderedSet refPtnNszSet; bool outputPartitionIndices = false; for(ItemAddress64::ItemOffset_t off = 0; off < m_feZoneInfo->___2783(section, ___684); ++off) { ItemAddress64 const cellCoordinate(ItemAddress64::UNKNOWN_PARTITION, section, ___684, off); ___463 ___447 = m_feZoneInfo->cellAtItemAddress(cellCoordinate); ___2724.getElemNodes<NODE_TYPE>(section+1, ___447+1, 1, elemNodes.data()); for (int32_t nOffset = 0; nOffset < numNodesPerCell; ++nOffset) { int64_t ___2710 = elemNodes[nOffset]; ItemAddress64 const& nodeCoordinate = m_feZoneInfo->itemAddressAtNode(___2710 - 1); ItemAddress64::___2981 ___2978 = nodeCoordinate.___2978(); ItemAddress64::SubzoneOffset_t ___2758 = nodeCoordinate.subzoneOffset(); if (___2978 == ItemAddress64::INVALID_PARTITION || static_cast<___4636>(___2978) == fileZone) { refPtnNszSet.insert(ItemAddress64::SubzoneAddress(fileZone, 0 , ___2758)); nszRefPtnCszSets[___2758].insert(ItemAddress64::SubzoneAddress(fileZone, section, ___684)); } else { refPtnNszSet.insert(ItemAddress64::SubzoneAddress(___2978, 0 , ___2758)); outputPartitionIndices = true; } } } size_t totalNumCellNodes = static_cast<size_t>(m_feZoneInfo->___2783(section, ___684)) * numNodesPerCell; uint64_t cszDataFileSize = cszConnectivityDataFileSize( ___2001, totalNumCellNodes, refPtnNszSet.size(), m_feZoneInfo->getNumReferencedPartitions(), outputPartitionIndices); ___3359 += cszDataFileSize; } } return ___3359; } uint64_t SZLFEZoneWriter::cszConnectivityFileSize(bool ___2001, SubzoneAddressSetArray& nszRefPtnCszSets) { ___2725 ___2724(&___2338, ___2678 + 1); return ___2724.getOffsetDataType() == OffsetDataType_32Bit ? cszConnectivityFileSize<int32_t>(___2724, ___2001, nszRefPtnCszSets) : cszConnectivityFileSize<int64_t>(___2724, ___2001, nszRefPtnCszSets); } ___372 SZLFEZoneWriter::___4537( FileWriterInterface&           file, ItemAddress64::SubzoneOffset_t ___2735) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); if (file.___2001()) { ___2038 = writeValue<uint32_t, false, 0>(file, "nszConnectivityMarker*", SZPLT_NSZ_CONNECTIVITY_MARKER) && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2678 - m_baseZone + 1)) &&
writeValue<uint64_t, false, 0>(file, "subzoneNum*", ___2735 + 1); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } uint64_t SZLFEZoneWriter::nszConnectivityHeaderFileSize(bool ___2001) { uint64_t ___3359 = 0; if (___2001) ___3359 += 2 * valueSizeInFile<uint32_t, false>(___2001) + valueSizeInFile<uint64_t, false>(___2001); return ___3359; } namespace { inline ___372 ___4536( FileWriterInterface&       file, ZoneType_e                 ___4692, char const*                ___970, SubzoneAddressSet const&   refPtnCszSet, PartitionArray const&      referencedPartitions, ItemAddress64::___2981 numReferencedPartitions, bool                       outputPartitionIndices) { ___4279(___970); if (refPtnCszSet.size() > uint16_t(-1)) { std::cerr << "Overflow while writing Node subzone. Too many cells use the same node (> 65536)." << std::endl; return ___1303; } UInt32Array refPtnArray; UInt32Array refCszArray; uint16_t const numRefCszs = uint16_t(refPtnCszSet.size()); ___372 ___2038 = ___4227; if (___2038 && numRefCszs > 0) { ___2038 = refPtnArray.alloc(numRefCszs) && refCszArray.alloc(numRefCszs); if ( ___2038 ) { BitArray<ItemAddress64::SectionOffset_t,4> refCszSec4BitOffsets(numRefCszs, 0); ItemAddress64::SubzoneOffset_t refCszIndex = 0; for (SubzoneAddressSet::const_iterator iter = refPtnCszSet.begin(); iter != refPtnCszSet.end(); iter++) { refPtnArray[refCszIndex] = iter->___2978(); if (___2038 && ___4692 == ZoneType_FEMixed) { ___476(SZPLT_CUR_WRITE_VERSION > 105); refCszSec4BitOffsets[refCszIndex] = iter->sectionOffset(); } refCszArray[refCszIndex] = iter->subzoneOffset(); refCszIndex++; } ___476(refCszIndex==numRefCszs); if (outputPartitionIndices) { typedef uint16_t OffsetType; if (numReferencedPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) { UInt8Array refPtn2BitOffsets; ___2038 = refPtn2BitOffsets.alloc(BitArray<OffsetType,2>::byteArraySize(numRefCszs)); if (___2038) { size_t const ___2780 = gatherCompressedOffsets<uint32_t,OffsetType,2>(refPtnArray.data(), numRefCszs, referencedPartitions.data(), numReferencedPartitions, refPtn2BitOffsets.data()); ___2038 = ___2038 && ___4563<uint8_t, true, 0>(file, "refPtn2BitOffsets", ___2746, ___2780, refPtn2BitOffsets.data(), ___944 / 4); } } else if (numReferencedPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) { UInt8Array refPtn4BitOffsets; ___2038 = refPtn4BitOffsets.alloc(BitArray<OffsetType,4>::byteArraySize(numRefCszs)); if (___2038) { size_t const ___2780 = gatherCompressedOffsets<uint32_t,OffsetType,4>(refPtnArray.data(), numRefCszs, referencedPartitions.data(), numReferencedPartitions, refPtn4BitOffsets.data()); ___2038 = ___2038 && ___4563<uint8_t, true, 0>(file, "refPtn4BitOffsets", ___2746, ___2780, refPtn4BitOffsets.data(), ___944 / 2); } } else if (numReferencedPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION) { UInt8Array refPtn8BitOffsets; ___2038 = refPtn8BitOffsets.alloc(BitArray<OffsetType,8>::byteArraySize(numRefCszs)); if (___2038) { size_t const ___2780 = gatherCompressedOffsets<uint32_t,OffsetType,8>(refPtnArray.data(), numRefCszs,
referencedPartitions.data(), numReferencedPartitions, refPtn8BitOffsets.data()); ___2038 = ___2038 && ___4563<uint8_t, true, 0>(file, "refPtn8BitOffsets", ___2746, ___2780, refPtn8BitOffsets.data()); } } else { UInt16Array refPtn16BitOffsets; ___2038 = refPtn16BitOffsets.alloc(numRefCszs); if (___2038) { gatherOffsets(refPtnArray.data(), numRefCszs, referencedPartitions.data(), numReferencedPartitions, refPtn16BitOffsets.data()); ___2038 = ___2038 && ___4563<OffsetType, true, 0>(file, "refPtn16BitOffsets", ___2746, numRefCszs, refPtn16BitOffsets.data()); } } } ___2038 = ___2038 && ___4563<uint32_t, false, 1>(file, NSZ_CONNECT_REF_CSZS, ___2746, numRefCszs, refCszArray.data()); if (___2038 && ___4692 == ZoneType_FEMixed) { ___476(SZPLT_CUR_WRITE_VERSION > 105); ___2038 = ___2038 && ___4563<uint8_t, false, 0>(file, "refCszSec4BitOffsets", ___2746, refCszSec4BitOffsets.byteSize(), static_cast<uint8_t*>(refCszSec4BitOffsets.data())); } } refPtnArray.___935(); refCszArray.___935(); } ENSURE(refPtnArray.empty()); ENSURE(refCszArray.empty()); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace { uint64_t nszConnectivityDataFileSize( bool                       ___2001, ZoneType_e                 ___4692, ItemAddress64::___2981 numReferencedPartitions, bool                       outputPartitionIndices, SubzoneAddressSet const&   refPtnCszSet) { uint64_t ___3359 = 0; size_t const numRefCszs = refPtnCszSet.size(); if (outputPartitionIndices) { if (numReferencedPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) ___3359 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,2>::byteArraySize(numRefCszs), ___2001); else if (numReferencedPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) ___3359 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,4>::byteArraySize(numRefCszs), ___2001); else if (numReferencedPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION) ___3359 += arraySizeInFile<uint8_t, true  >( BitArray<uint16_t,8>::byteArraySize(numRefCszs), ___2001); else ___3359 += arraySizeInFile<uint16_t, true  >(numRefCszs, ___2001); } ___3359 += arraySizeInFile<uint32_t, false>(numRefCszs, ___2001); if (___4692 == ZoneType_FEMixed) { ___3359 += arraySizeInFile<uint8_t, false >( BitArray<ItemAddress64::SectionOffset_t,4>::byteArraySize(numRefCszs), ___2001); } return ___3359; } } ___372 SZLFEZoneWriter::___4535( FileWriterInterface&      szpltFile, SubzoneAddressSetArray& nszRefPtnCszSets) { ___372 ___2038 = ___4227; for (___1348::NeighborCszRefMap::const_iterator entryIt = m_feZoneInfo->getNeighborCszRefs().begin(); entryIt != m_feZoneInfo->getNeighborCszRefs().end(); ++entryIt) { ___1348::NeighborCszRefMap::value_type const& entry = *entryIt; ItemAddress64::SubzoneOffset_t ___2758 = entry.first; for (SubzoneAddressUnorderedSet::iterator ptnCszIt = entry.second.begin(); ptnCszIt != entry.second.end(); ++ptnCszIt) { ItemAddress64::SubzoneAddress const& ptnCsz = *ptnCszIt; nszRefPtnCszSets[___2758].insert(ptnCsz); } } ___4636 const fileZone = ___2678 - m_baseZone;
for (ItemAddress64::SubzoneOffset_t ___2758 = 0; ___2038 && ___2758 < m_feZoneInfo->___2824(); ___2758++) { m_nszConnectivityFileLocs[___2758] = szpltFile.fileLoc(); m_numRefCellSubzones[___2758] = static_cast<uint16_t>(nszRefPtnCszSets[___2758].size()); bool outputPartitionIndices = false; for (SubzoneAddressSet::iterator partitionSubzoneIt = nszRefPtnCszSets[___2758].begin(); partitionSubzoneIt != nszRefPtnCszSets[___2758].end(); ++partitionSubzoneIt) { ItemAddress64::SubzoneAddress const& partitionSubzone = *partitionSubzoneIt; ItemAddress64::___2981 ptnIndex = partitionSubzone.___2978(); if (ptnIndex != ItemAddress64::INVALID_PARTITION && static_cast<___4636>(ptnIndex) != fileZone) { outputPartitionIndices = true; } } if (outputPartitionIndices) setBit(m_nszIncludesPartitionOffsetsBitArray, ___2758); ___2038 = ___2038 && ___4537(szpltFile, ___2758); ___2038 = ___2038 && ___4536( szpltFile, ___2338.___4620(___2678 + 1), "nszConnectivity", nszRefPtnCszSets[___2758], m_feZoneInfo->getReferencedPartitions(), m_feZoneInfo->getNumReferencedPartitions(), outputPartitionIndices); } return ___2038; } uint64_t SZLFEZoneWriter::nszConnectivityFileSize(bool ___2001, SubzoneAddressSetArray& nszRefPtnCszSets) { uint64_t ___3359 = m_feZoneInfo->___2824() * nszConnectivityHeaderFileSize(___2001); for (___1348::NeighborCszRefMap::const_iterator entry = m_feZoneInfo->getNeighborCszRefs().begin(); entry != m_feZoneInfo->getNeighborCszRefs().end(); ++entry) { ItemAddress64::SubzoneOffset_t ___2758 = entry->first; for (SubzoneAddressUnorderedSet::const_iterator ptnCsz = entry->second.begin(); ptnCsz != entry->second.end(); ++ptnCsz) { nszRefPtnCszSets[___2758].insert(*ptnCsz); } } ___4636 const fileZone = ___2678 - m_baseZone; for(ItemAddress64::SubzoneOffset_t ___2758 = 0; ___2758 < m_feZoneInfo->___2824(); ++___2758) { bool outputPartitionIndices = false; for (SubzoneAddressSet::iterator partitionSubzone = nszRefPtnCszSets[___2758].begin(); partitionSubzone != nszRefPtnCszSets[___2758].end(); ++partitionSubzone) { ItemAddress64::___2981 ptnIndex = partitionSubzone->___2978(); if (ptnIndex != ItemAddress64::INVALID_PARTITION && static_cast<___4636>(ptnIndex) != fileZone) outputPartitionIndices = true; } ___3359 += nszConnectivityDataFileSize(___2001, ___2338.___4620(___2678 + 1), m_feZoneInfo->getNumReferencedPartitions(), outputPartitionIndices, nszRefPtnCszSets[___2758]); } return ___3359; } ___372 SZLFEZoneWriter::writeZoneConnectivity(FileWriterInterface& szpltFile) { ___372 ___2038 = ___4227; if (m_writeConnectivity) { ___2338.___856(); SubzoneAddressSetArray nszRefPtnCszSets;
 #if defined OUTPUT_TIMES
uint64_t ___3688 = ___715();
 #endif
___2038 = ___2038 && ___483(SzPltWriteOperation_WriteConnectivity, ___2338, 0 , ___2678); ___2038 = ___2038 && nszRefPtnCszSets.alloc(m_feZoneInfo->___2824()); ItemAddress64::SectionOffset_t const numSections = m_feZoneInfo->getNumSections(); ___2038 = ___2038 && m_secCszConnectivityFileLocs.alloc(numSections); ___2038 = ___2038 && m_secNumCszs.alloc(numSections, 0); ___2038 = ___2038 && m_secNumRefNodeSubzones.alloc(numSections); ___2038 = ___2038 && m_secCszIncludesPartitionOffsetsBitArray.alloc(numSections); for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < numSections; ++section) { if (___2038) m_secNumCszs[section] = m_feZoneInfo->numCszsInSection(section); ___2038 = ___2038 && m_secCszConnectivityFileLocs[section].alloc(m_secNumCszs[section], ___330); ___2038 = ___2038 && m_secNumRefNodeSubzones[section].alloc(m_secNumCszs[section], 0); ___2038 = ___2038 && m_secCszIncludesPartitionOffsetsBitArray[section].alloc(numBytesForNumBits(m_secNumCszs[section]), 0); } ___2038 = ___2038 && m_numRefCellSubzones.alloc(m_feZoneInfo->___2824(), 0); ___2038 = ___2038 && m_nszIncludesPartitionOffsetsBitArray.alloc(numBytesForNumBits(m_feZoneInfo->___2824()), 0); ___2730 ___2724 = boost::make_shared<___2725>(&___2338, ___2678 + 1); if (!___2724->___2066()) ___2038 = ___1303; try { ___2038 = ___2038 && writeCszConnectivity(szpltFile, ___2724, nszRefPtnCszSets);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1930(NULL, "%g seconds writing cell subzone connectivity.", (double)(___1165 - ___3688) / 1000.0); ___3688 = ___1165;
 #endif
} catch (___1337::Error const& e) { std::cerr << "Error compressing node map: " << e.what() << std::endl; ___2038 = ___1303; } ___2038 = ___2038 && m_nszConnectivityFileLocs.alloc(m_feZoneInfo->___2824(), ___330); ___2038 = ___2038 && ___4535(szpltFile, nszRefPtnCszSets);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1930(NULL, "%g seconds writing node subzone connectivity.", (double)(___1165 - ___3688) / 1000.0);
 #endif
___2338.___857(); } return ___2038; } uint64_t SZLFEZoneWriter::zoneConnectivityFileSize(bool ___2001) { uint64_t ___3359 = 0; if (m_writeConnectivity) { SubzoneAddressSetArray nszRefPtnCszSets; if (nszRefPtnCszSets.alloc(m_feZoneInfo->___2824())) { ___3359 += cszConnectivityFileSize(___2001, nszRefPtnCszSets); ___3359 += nszConnectivityFileSize(___2001, nszRefPtnCszSets); } } return ___3359; } ___372 SZLFEZoneWriter::___4512( FileWriterInterface&           file, ValueLocation_e                ___4326, ___4352                     datasetVar, ItemAddress64::SubzoneOffset_t ___3881) { ___372 ___2038 = ___4227; REQUIRE(file.___2040()); REQUIRE(___4326 == ___4328 || ___4326 == ___4330); if (file.___2001()) { if ( ___4326 == ___4328 ) ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, "cszFieldDataMarker*", SZPLT_CSZ_FIELD_DATA_MARKER); else ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, "nszFieldDataMarker*", SZPLT_NSZ_FIELD_DATA_MARKER); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, "variableNum*", (datasetVar - m_varIter.baseItem() + 1)); ___2038 = ___2038 && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2678 - m_baseZone + 1)); ___2038 = ___2038 && writeValue<uint64_t, false, 0>(file, "subzoneNum*", ___3881 + 1); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } uint64_t SZLFEZoneWriter::fieldDataSubzoneHeaderFileSize(bool ___2001) { uint64_t ___3359 = 0; if (___2001) { ___3359 += 3 * valueSizeInFile<uint32_t, false>(___2001) + valueSizeInFile<uint64_t, false>(___2001); } return ___3359; } template <typename T, bool isBitArray> uint64_t SZLFEZoneWriter::cellSubzoneFieldDataFileSize(bool ___2001, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) const { size_t ___2783 = static_cast<size_t>(m_feZoneInfo->___2783(section, ___467)); return arraySizeInFile<T, false>(___2783, ___2001); } template <> uint64_t SZLFEZoneWriter::cellSubzoneFieldDataFileSize<uint8_t, true>(bool ___2001, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) const { size_t ___2783 = static_cast<size_t>(m_feZoneInfo->___2783(section, ___467)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2783), ___2001); } template <typename T, bool isBitArray> uint64_t SZLFEZoneWriter::nodeSubzoneFieldDataFileSize(bool ___2001, ItemAddress64::SubzoneOffset_t ___2735) const { size_t ___2823 = static_cast<size_t>(m_feZoneInfo->___2823(___2735)); return arraySizeInFile<T, false>(___2823, ___2001); } template <> uint64_t SZLFEZoneWriter::nodeSubzoneFieldDataFileSize<uint8_t, true>(bool ___2001, ItemAddress64::SubzoneOffset_t ___2735) const { size_t ___2823 = static_cast<size_t>(m_feZoneInfo->___2823(___2735)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2823), ___2001);
} template <typename T, bool isBitArray  > uint64_t SZLFEZoneWriter::subzoneFieldDataFileSize(bool ___2001, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___3881, ValueLocation_e ___4326) const { if (___4326 == ___4328) return cellSubzoneFieldDataFileSize<T, isBitArray>(___2001, section, ___3881); else return nodeSubzoneFieldDataFileSize<T, isBitArray>(___2001, ___3881); } template <typename T, bool isBitArray  > uint64_t SZLFEZoneWriter::variableFileSize(bool ___2001, ValueLocation_e ___4326) { uint64_t ___3359 = 0; ItemAddress64::SubzoneOffset_t const ___2824 = m_feZoneInfo->___2824(); ___3359 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2824), ___2001); for (ItemAddress64::SectionOffset_t section = 0; section < m_feZoneInfo->getNumSections(); ++section) { ItemAddress64::SubzoneOffset_t const ___2784 = m_feZoneInfo->numCszsInSection(section); ___3359 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2784), ___2001); } if (___4326 == ___4328) { for (ItemAddress64::SectionOffset_t section = 0; section < m_feZoneInfo->getNumSections(); ++section) { ItemAddress64::SubzoneOffset_t const ___2784 = m_feZoneInfo->numCszsInSection(section); for (ItemAddress64::SubzoneOffset_t ___3924 = 0; ___3924 < ___2784; ++___3924) { ___3359 += fieldDataSubzoneHeaderFileSize(___2001); ___3359 += subzoneFieldDataFileSize<T, isBitArray>(___2001, section, ___3924, ___4326); } } } else { for (ItemAddress64::SubzoneOffset_t ___3924 = 0; ___3924 < ___2824; ++___3924) { ___3359 += fieldDataSubzoneHeaderFileSize(___2001); ___3359 += subzoneFieldDataFileSize<T, isBitArray>(___2001, 0 , ___3924, ___4326); } } return ___3359; } uint64_t SZLFEZoneWriter::zoneDataFileSize(bool ___2001) { uint64_t ___3359 = 0; m_varIter.reset(); ___4352 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4352 const datasetVar = m_varIter.next(); ___4352 const fileVar = datasetVar - baseVar; if (!m_writeVariables[fileVar]) continue; FieldDataType_e const ___1361 = ___2338.___921(___2678 + 1, fileVar + 1); ValueLocation_e const ___4326 = ___2338.___908(___2678 + 1, fileVar + 1); switch (___1361) { case FieldDataType_Float: ___3359 += variableFileSize<float, false>(___2001, ___4326); break; case FieldDataType_Double: ___3359 += variableFileSize<double, false>(___2001, ___4326); break; case FieldDataType_Int32: ___3359 += variableFileSize<int32_t, false>(___2001, ___4326); break; case FieldDataType_Int16: ___3359 += variableFileSize<int16_t, false>(___2001, ___4326); break; case FieldDataType_Byte: ___3359 += variableFileSize<uint8_t, false>(___2001, ___4326); break; case ___1363: ___3359 += variableFileSize<uint8_t, true>(___2001, ___4326); break; default: ___476(___1303); break; } } return ___3359; } template <typename T, bool isBitArray  >
___372 SZLFEZoneWriter::___4496( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) { ___372 ___2038 = ___4227; REQUIRE(szpltFile.___2040()); REQUIRE(___1349.___2066()); REQUIRE(___1349.___1785() == ___4328); ___2241<T> valueArray; ItemAddress64::SubzoneOffset_t ___2783 = m_feZoneInfo->___2783(section, ___467); ___2038 = ___2038 && valueArray.alloc(___2783); T* rawPointer = static_cast<T*>(___1349.getRawPointer()); if (___2038) { ___81 const baseCell = m_feZoneInfo->baseCellAtSection(section); for (ItemAddress64::ItemOffset_t cszOffset = 0; cszOffset < ___2783; cszOffset++) { ItemAddress64 const ___686(ItemAddress64::UNKNOWN_PARTITION, section, ___467, cszOffset); ___463 const globalCell = baseCell + m_feZoneInfo->cellAtItemAddress(___686); if (rawPointer) valueArray[cszOffset] = rawPointer[globalCell]; else valueArray[cszOffset] = static_cast<T>(___1349.___1779(globalCell + 1)); } } ___2038 = ___2038 && ___4563<T, false, 0>(szpltFile, "cszFieldData", ___2746, ___2783, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <> ___372 SZLFEZoneWriter::___4496<uint8_t, true>( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SectionOffset_t section, ItemAddress64::SubzoneOffset_t ___467) { ___372 ___2038 = ___4227; REQUIRE(szpltFile.___2040()); REQUIRE(___1349.___2066()); REQUIRE(___1349.___1785() == ___4328); ___2241<uint8_t> valueArray; ItemAddress64::SubzoneOffset_t ___2783 = m_feZoneInfo->___2783(section, ___467); uint64_t arraySize = numBytesForNumBits(___2783); ___2038 = ___2038 && valueArray.alloc(arraySize); if (___2038) { ___81 const baseCell = m_feZoneInfo->baseCellAtSection(section); for (ItemAddress64::ItemOffset_t cszItemOffset = 0; cszItemOffset < ___2783; cszItemOffset++) { ItemAddress64 const ___686(ItemAddress64::UNKNOWN_PARTITION, section, ___467, cszItemOffset); ___463 const globalCell = baseCell + m_feZoneInfo->cellAtItemAddress(___686); double const ___4299 = ___1349.___1779(globalCell + 1); if (___4299 < 1.0) clearBit(valueArray, cszItemOffset); else setBit(valueArray, cszItemOffset); } } ___2038 = ___2038 && ___4563<uint8_t, false, 0>(szpltFile, "cszFieldData", ___2746, arraySize, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <typename T, bool isBitArray  > ___372 SZLFEZoneWriter::___4531( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SubzoneOffset_t ___2735) { ___372 ___2038 = ___4227;
REQUIRE(szpltFile.___2040()); REQUIRE(___1349.___2066()); REQUIRE(___1349.___1785() == ___4330); ___2241<T> valueArray; ItemAddress64::ItemOffset_t ___2823 = m_feZoneInfo->___2823(___2735); ___2038 = ___2038 && valueArray.alloc(___2823); T* rawPointer = static_cast<T*>(___1349.getRawPointer()); if (___2038) { for (ItemAddress64::ItemOffset_t nszItemOffset = 0; nszItemOffset < ___2823; nszItemOffset++) { ItemAddress64 const ___2760(ItemAddress64::UNKNOWN_PARTITION, 0 , ___2735, nszItemOffset); ___2719 const ___2710 = m_feZoneInfo->nodeAtItemAddress(___2760); if (rawPointer) valueArray[nszItemOffset] = rawPointer[___2710]; else valueArray[nszItemOffset] = static_cast<T>(___1349.___1779(___2710 + 1)); } } ___2038 = ___2038 && ___4563<T, false, 0>(szpltFile, "nszFieldData", ___2746, ___2823, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <> ___372 SZLFEZoneWriter::___4531<uint8_t, true>( FileWriterInterface&           szpltFile, ___1350 const&               ___1349, ItemAddress64::SubzoneOffset_t ___2735) { ___372 ___2038 = ___4227; REQUIRE(szpltFile.___2040()); REQUIRE(___1349.___2066()); REQUIRE(___1349.___1785() == ___4330); ___2241<uint8_t> valueArray; ItemAddress64::ItemOffset_t ___2823 = m_feZoneInfo->___2823(___2735); uint64_t arraySize = numBytesForNumBits(___2823); ___2038 = ___2038 && valueArray.alloc(arraySize); if (___2038) { for (ItemAddress64::ItemOffset_t ___2764 = 0; ___2764 < ___2823; ___2764++) { ItemAddress64 const ___2760(ItemAddress64::UNKNOWN_PARTITION, 0 , ___2735, ___2764); ___2719 const ___2710 = m_feZoneInfo->nodeAtItemAddress(___2760); double const ___4299 = ___1349.___1779(___2710 + 1); if (___4299 < 1.0) clearBit(valueArray, ___2764); else setBit(valueArray, ___2764); } } ___2038 = ___2038 && ___4563<uint8_t, false, 0>(szpltFile, "nszFieldData", ___2746, arraySize, valueArray.data()); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <typename T, bool isBitArray  > ___372 SZLFEZoneWriter::writeVariable( FileWriterInterface&                  szpltFile, ___4352 const                      datasetVar, ___2482 const&                    nszDataMinMax, ___2241<___2482> const& secCszDataMinMax) { ___4352 const fileVar = datasetVar - m_varIter.baseItem(); ItemAddress64::SubzoneOffset_t const ___2824 = m_feZoneInfo->___2824(); ___372 ___2038 = ___4528<T>(szpltFile, NODE_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar, ___2824, nszDataMinMax.data(), ___944 / 2); for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < m_feZoneInfo->getNumSections(); ++section) ___2038 = ___4528<T>(szpltFile, CELL_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar,
m_feZoneInfo->numCszsInSection(section), secCszDataMinMax[section].data(), ___944 / 2); ___1350 ___1349(&___2338, ___2678 + 1, datasetVar + 1); ___2038 = ___2038 && ___1349.___2066(); ValueLocation_e const ___4326 = ___1349.___1785(); if (___4326 == ___4328) { for (ItemAddress64::SectionOffset_t section = 0; ___2038 && section < m_feZoneInfo->getNumSections(); ++section) for (ItemAddress64::SubzoneOffset_t ___3924 = 0; ___2038 && ___3924 < m_feZoneInfo->numCszsInSection(section); ++___3924) ___2038 = (___4512(szpltFile, ___4326, datasetVar, ___3924) && ___4496<T, isBitArray>(szpltFile, ___1349, section, ___3924)); } else { for (ItemAddress64::SubzoneOffset_t ___3924 = 0; ___2038 && ___3924 < ___2824; ++___3924) ___2038 = (___4512(szpltFile, ___4326, datasetVar, ___3924) && ___4531<T, isBitArray>(szpltFile, ___1349, ___3924)); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 SZLFEZoneWriter::writeZoneData(FileWriterInterface& szpltFile) {
 #if defined OUTPUT_TIMES
uint64_t ___3688 = ___715(); uint64_t minMaxTime = 0; uint64_t ___4549 = 0;
 #endif
___372 ___2038 = ___4227; ___2482 ___2763; ___2241<___2482> secCszMinMaxArray; m_varIter.reset(); ___4352 const baseVar = m_varIter.baseItem(); while (___2038 && m_varIter.hasNext()) { ___4352 const datasetVar = m_varIter.next(); ___4352 const fileVar = datasetVar - baseVar; if (!m_writeVariables[fileVar]) continue; ___2338.___856(); ___2038 = ___483(SzPltWriteOperation_WriteFieldData, ___2338, datasetVar, ___2678); ___2038 = ___2038 && calculateVarSubzoneMinMaxes(datasetVar, ___2763, secCszMinMaxArray);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); minMaxTime += (___1165 - ___3688); ___3688 = ___1165;
 #endif
___2674[fileVar] = szpltFile.fileLoc(); if (___2038) { switch (___2338.___921(___2678 + 1, datasetVar + 1)) { case FieldDataType_Float: ___2038 = writeVariable<float, false>(szpltFile, datasetVar, ___2763, secCszMinMaxArray); break; case FieldDataType_Double: ___2038 = writeVariable<double, false>(szpltFile, datasetVar, ___2763, secCszMinMaxArray); break; case FieldDataType_Int32: ___2038 = writeVariable<int32_t, false>(szpltFile, datasetVar, ___2763, secCszMinMaxArray); break; case FieldDataType_Int16: ___2038 = writeVariable<int16_t, false>(szpltFile, datasetVar, ___2763, secCszMinMaxArray); break; case FieldDataType_Byte: ___2038 = writeVariable<uint8_t, false>(szpltFile, datasetVar, ___2763, secCszMinMaxArray); break; case ___1363: ___2038 = writeVariable<uint8_t, true>(szpltFile, datasetVar, ___2763, secCszMinMaxArray); break; default: ___476(___1303); ___2038 = ___1303; break; } } ___2763.___935(); secCszMinMaxArray.___935();
 #if defined OUTPUT_TIMES
___1165 = ___715(); ___4549 += (___1165 - ___3688); ___3688 = ___1165;
 #endif
___2338.___857(); }
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1930(NULL, "%g seconds calculating variable ranges.", (double)(minMaxTime) / 1000.0); ___1930(NULL, "%g seconds writing zone data.", (double)(___4549) / 1000.0);
 #endif
ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 SZLFEZoneWriter::writeZoneHeader(FileWriterInterface& szpltFile) { REQUIRE(szpltFile.___2040()); return m_headerWriter.write(szpltFile); } uint64_t SZLFEZoneWriter::zoneHeaderFileSize(bool ___2001) { return m_headerWriter.sizeInFile(___2001); } }}
