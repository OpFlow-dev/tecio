 #pragma once
#include "ThirdPartyHeadersBegin.h"
#   include <algorithm>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "IJK.h"
namespace tecplot { namespace ___3934 { class IJKSubzoneInfo { private: ___1843 m_zoneIJKDim; ___1843 m_zoneLastIJKIndex; ___1843 m_subzoneItemsMaxIJKDim; ItemAddress64::___2981 m_partition; ___1843 m_subzoneTilingIJKDim; ___1843 m_subzoneTilingIJKShift; ItemAddress64::SubzoneOffset_t m_numSubzones;
 #if !defined NO_ASSERTS
bool ___2493;
 #endif
public: IJKSubzoneInfo( ___1843 const&               zoneIJKDim, ___1843 const&               subzoneMaxIJKDim, ItemAddress64::___2981 ___2978, bool                     minimizeNumSubzones) : m_zoneIJKDim(zoneIJKDim) , m_zoneLastIJKIndex(zoneIJKDim.maxOp(1)-1) , m_subzoneItemsMaxIJKDim(subzoneMaxIJKDim) , m_partition(___2978) , m_subzoneTilingIJKDim(numSubzonesForDirection(zoneIJKDim.i(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.i()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKDim.___2104(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.___2104()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKDim.___2133(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.___2133()), minimizeNumSubzones)) , m_subzoneTilingIJKShift(subzoneShiftForDirection(zoneIJKDim.i(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.i()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKDim.___2104(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.___2104()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKDim.___2133(), ItemAddress64::ItemOffset_t(subzoneMaxIJKDim.___2133()), minimizeNumSubzones)) , m_numSubzones( ItemAddress64::SubzoneOffset_t(m_subzoneTilingIJKDim.blockSize()) )
 #if !defined NO_ASSERTS
, ___2493(minimizeNumSubzones)
 #endif
{ REQUIRE(zoneIJKDim>0); REQUIRE(subzoneMaxIJKDim>0); } IJKSubzoneInfo() : m_zoneIJKDim(0,0,0) , m_zoneLastIJKIndex(0,0,0) , m_subzoneItemsMaxIJKDim(0,0,0) , m_partition(0) , m_subzoneTilingIJKDim(0,0,0) , m_subzoneTilingIJKShift(0,0,0) , m_numSubzones(0)
 #if !defined NO_ASSERTS
, ___2493(0)
 #endif
{} ~IJKSubzoneInfo() {} inline void swap(IJKSubzoneInfo& ___2889) { using std::swap; swap(m_zoneIJKDim, ___2889.m_zoneIJKDim); swap(m_zoneLastIJKIndex, ___2889.m_zoneLastIJKIndex); swap(m_subzoneItemsMaxIJKDim, ___2889.m_subzoneItemsMaxIJKDim); swap(m_partition, ___2889.m_partition); swap(m_subzoneTilingIJKDim, ___2889.m_subzoneTilingIJKDim); swap(m_subzoneTilingIJKShift, ___2889.m_subzoneTilingIJKShift); swap(m_numSubzones, ___2889.m_numSubzones);
 #if !defined NO_ASSERTS
swap(___2493, ___2889.___2493);
 #endif
} inline void reset( ___1843 const& zoneIJKSize, ___1843 const& subzoneIJKMax, bool       minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(zoneIJKSize>0); REQUIRE(subzoneIJKMax>0); REQUIRE(minimizeNumSubzones==DEFAULT_MINIMIZE_IJK_NUM_SUBZONES); m_zoneIJKDim = zoneIJKSize; m_zoneLastIJKIndex = zoneIJKSize.maxOp(1)-1; m_subzoneItemsMaxIJKDim = subzoneIJKMax; m_subzoneTilingIJKDim = ___1843( numSubzonesForDirection(zoneIJKSize.i(), ItemAddress64::ItemOffset_t(subzoneIJKMax.i()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKSize.___2104(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2104()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKSize.___2133(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2133()), minimizeNumSubzones) ); m_subzoneTilingIJKShift = ___1843( subzoneShiftForDirection(zoneIJKSize.i(), ItemAddress64::ItemOffset_t(subzoneIJKMax.i()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKSize.___2104(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2104()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKSize.___2133(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2133()), minimizeNumSubzones) ); m_numSubzones = ItemAddress64::SubzoneOffset_t(m_subzoneTilingIJKDim.blockSize()); } inline bool ___2066() const { return m_zoneIJKDim > 0 && m_subzoneItemsMaxIJKDim > 0; } inline bool validSubzone(ItemAddress64::SubzoneOffset_t ___3881) const { return ___3881 < getNumSzs(); } inline bool validSzAddress(ItemAddress64::SubzoneAddress const& szAddress) const { return validSubzone(szAddress.subzoneOffset()) && szAddress.___2978() == m_partition; } inline bool validItemAddress(ItemAddress64 const& ___2088) const { return validSzAddress(___2088.subzoneAddress()) && ___2088.itemOffset() < numItemsInSz(___2088.subzoneOffset()); } ___81 getNumItems(void) const { return m_zoneIJKDim.blockSize(); } ___1843 const& ijkDim(void) const { return m_zoneIJKDim; } ___1843 const& ijkLastIndex(void) const { ___476(m_zoneLastIJKIndex == m_zoneIJKDim.maxOp(1)-1); return m_zoneLastIJKIndex; } ItemAddress64::SubzoneOffset_t getNumSzs(void) const { ENSURE(m_numSubzones == ItemAddress64::SubzoneOffset_t(m_subzoneTilingIJKDim.blockSize())); ENSURE(m_numSubzones == calcNumSubzones(m_zoneIJKDim, m_subzoneItemsMaxIJKDim, ___2493)); return m_numSubzones; } static inline ItemAddress64::SubzoneOffset_t numSubzonesForDirection( ___81                  itemIndexDim, ItemAddress64::ItemOffset_t subzoneIndexMax, bool                        minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(itemIndexDim>0); REQUIRE(subzoneIndexMax<=ItemAddress64::MAX_ITEM_OFFSET+1); ItemAddress64::SubzoneOffset_t numSubzonesForDir; if ( minimizeNumSubzones ) { numSubzonesForDir = ItemAddress64::SubzoneOffset_t( (itemIndexDim+subzoneIndexMax-1)/subzoneIndexMax ); } else { numSubzonesForDir = ItemAddress64::SubzoneOffset_t( 1+(itemIndexDim/subzoneIndexMax) ); } ENSURE(numSubzonesForDir>0); ENSURE((___81)numSubzonesForDir*subzoneIndexMax>=itemIndexDim); ENSURE( IMPLICATION(minimizeNumSubzones, ___81(numSubzonesForDir-1)*subzoneIndexMax<itemIndexDim) );
return numSubzonesForDir; } static ItemAddress64::SubzoneOffset_t calcNumSubzones( ___1843 const& zoneIJKDim, ___1843 const& subzoneIJKMax, bool       minimizeIJKNumSubzones) { REQUIRE(zoneIJKDim>0); REQUIRE(subzoneIJKMax>0); ___1843 const subzoneTilingIJK( numSubzonesForDirection(zoneIJKDim.i(), ItemAddress64::ItemOffset_t(subzoneIJKMax.i()), minimizeIJKNumSubzones), numSubzonesForDirection(zoneIJKDim.___2104(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2104()), minimizeIJKNumSubzones), numSubzonesForDirection(zoneIJKDim.___2133(), ItemAddress64::ItemOffset_t(subzoneIJKMax.___2133()), minimizeIJKNumSubzones)); ItemAddress64::SubzoneOffset_t const numSubzones = ItemAddress64::SubzoneOffset_t(subzoneTilingIJK.blockSize()); ENSURE(numSubzones>0 && numSubzones <= zoneIJKDim.blockSize()); return numSubzones; } static inline ItemAddress64::ItemOffset_t subzoneShiftForDirection( ___81                  itemIndexDim, ItemAddress64::ItemOffset_t subzoneIndexMax, bool                        minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(itemIndexDim>0); REQUIRE(subzoneIndexMax>=3 && subzoneIndexMax<=ItemAddress64::MAX_ITEM_OFFSET+1); ItemAddress64::ItemOffset_t const remainder = ItemAddress64::ItemOffset_t(itemIndexDim % subzoneIndexMax); ItemAddress64::ItemOffset_t subzoneShift = (subzoneIndexMax-remainder)/2; if ( minimizeNumSubzones && remainder == 0 ) subzoneShift = 0; ENSURE(subzoneShift<subzoneIndexMax); return subzoneShift; } ___1843 itemIJKStart(___1843 const& szIJK) const { INVARIANT(m_subzoneTilingIJKShift<m_subzoneItemsMaxIJKDim); ___1843 const indexStart = m_subzoneTilingIJKShift.maxOp(szIJK*m_subzoneItemsMaxIJKDim) - m_subzoneTilingIJKShift; ENSURE(indexStart >= 0); return indexStart; } ___1843 itemIJKEnd(___1843 const& szIJK) const { INVARIANT(m_subzoneTilingIJKShift < m_subzoneItemsMaxIJKDim); ___1843 const indexEnd = m_zoneIJKDim.minOp((szIJK + 1)*m_subzoneItemsMaxIJKDim - m_subzoneTilingIJKShift) - 1; ENSURE(indexEnd<m_zoneIJKDim); return indexEnd; } ___1843 szIJKAtSzIndex(ItemAddress64::SubzoneOffset_t ___3881) const { REQUIRE(validSubzone(___3881)); ___1843 const subzoneIJK = m_subzoneTilingIJKDim.ijkAtOffset(___3881); ENSURE(subzoneIJK<m_subzoneTilingIJKDim); return subzoneIJK; } ItemAddress64::SubzoneAddress szAddressAtSzIJK(___1843 const& szIJK) const { REQUIRE(szIJK<m_subzoneTilingIJKDim); size_t const section = 0; ItemAddress64::SubzoneAddress const szAddress(m_partition, section, static_cast<ItemAddress64::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(szIJK))); ENSURE(validSzAddress(szAddress)); ENSURE(szIJKAtSzIndex(szAddress.subzoneOffset())==szIJK); return szAddress; } void subzoneIJKStartAndEnd( ItemAddress64::SubzoneOffset_t ___3881, ___1843&                           ___1879, ___1843&                           ___1851) const { REQUIRE(___3881 < getNumSzs()); ___1843 const szIJK = szIJKAtSzIndex(___3881); ___1879 = itemIJKStart(szIJK); ___1851 = itemIJKEnd(szIJK); ENSURE(___1879<m_zoneIJKDim); ENSURE(___1851<m_zoneIJKDim); ENSURE(szAddressAtItemIJK(___1879).subzoneOffset() == ___3881);
ENSURE(szAddressAtItemIJK(___1851).subzoneOffset()==___3881); } ___1843 subzoneIJKStart(ItemAddress64::SubzoneOffset_t ___3881) const { REQUIRE(___3881 < getNumSzs()); ___1843 const szIJK = szIJKAtSzIndex(___3881); ___1843 const ___1879 = itemIJKStart(szIJK); ENSURE(___1879<m_zoneIJKDim); ENSURE(szAddressAtItemIJK(___1879).subzoneOffset() == ___3881); return ___1879; } ___1843 subzoneIJKEnd(ItemAddress64::SubzoneOffset_t ___3881) const { REQUIRE(___3881 < getNumSzs()); ___1843 const szIJK = szIJKAtSzIndex(___3881); ___1843 const ___1851 = itemIJKEnd(szIJK); ENSURE(___1851 < m_zoneIJKDim); ENSURE(szAddressAtItemIJK(___1851).subzoneOffset() == ___3881); return ___1851; } ___1843 szIJKAtItemIJK(___1843 const& itemIJK) const { REQUIRE(itemIJK < m_zoneIJKDim); ___1843 const szIJK = (itemIJK+m_subzoneTilingIJKShift) / m_subzoneItemsMaxIJKDim; ENSURE(szIJK < m_subzoneTilingIJKDim); return szIJK; } ItemAddress64::SubzoneAddress szAddressAtItemIJK(___1843 const& itemIJK) const { REQUIRE(itemIJK<m_zoneIJKDim); size_t const section = 0; ___1843 const subzoneIJK = szIJKAtItemIJK(itemIJK); ItemAddress64::SubzoneAddress const szAddress(m_partition, section, static_cast<ItemAddress64::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(subzoneIJK))); ENSURE(validSzAddress(szAddress)); return szAddress; } ItemAddress64::SubzoneAddress szAddressAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex<getNumItems()); ___1843 const itemIJK = m_zoneIJKDim.ijkAtOffset(itemIndex); ItemAddress64::SubzoneAddress const szAddress = szAddressAtItemIJK(itemIJK); ENSURE(validSzAddress(szAddress)); return szAddress; } ItemAddress64 itemAddressAtItemIJK( ___1843 const& itemIJK, ___1843 const& szIJK) const { REQUIRE(itemIJK<m_zoneIJKDim); REQUIRE(szIJK<m_subzoneTilingIJKDim); size_t const section = 0; ItemAddress64::SubzoneOffset_t const szOffset = static_cast<ItemAddress64::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(szIJK)); ___1843 const ___1879 = itemIJKStart(szIJK); ___1843 const ___1851   = itemIJKEnd(szIJK); ___1843 const localMax = ___1851-___1879+1; ___1843 const localIJK = itemIJK-___1879; ___476(localIJK<=localMax); ItemAddress64::ItemOffset_t const itemOffset = ItemAddress64::ItemOffset_t(localMax.offsetAtIJK(localIJK)); ENSURE(itemOffset<localMax.blockSize()); return ItemAddress64(m_partition,section,szOffset,itemOffset); } ___1843 subzoneIJKDim(ItemAddress64::SubzoneOffset_t ___3881) const { REQUIRE(validSubzone(___3881)); ___1843 szIJKStart, szIJKEnd; subzoneIJKStartAndEnd(___3881, szIJKStart, szIJKEnd); ___1843 const szIJKDim = szIJKEnd-szIJKStart+1; return szIJKDim; } ItemAddress64::ItemOffset_t numItemsInSz(ItemAddress64::SubzoneOffset_t ___3881) const { REQUIRE(validSubzone(___3881)); return ItemAddress64::ItemOffset_t(subzoneIJKDim(___3881).blockSize()); } ItemAddress64 itemAddressAtItemIJK(___1843 const& itemIJK) const { REQUIRE(itemIJK<m_zoneIJKDim); ___1843 const szIJK = szIJKAtItemIJK(itemIJK); return itemAddressAtItemIJK(itemIJK, szIJK); } ___1843 itemIJKAtItemAddress(ItemAddress64 ___2088) const { REQUIRE(validItemAddress(___2088));
ItemAddress64::SubzoneOffset_t const ___3881 = ___2088.subzoneOffset(); ___1843 ___1879, ___1851; subzoneIJKStartAndEnd(___3881, ___1879, ___1851); ItemAddress64::ItemOffset_t const ___2866 = ___2088.itemOffset(); ___1843 const ijkRange = ___1851-___1879+1; ___1843 const ___1861 = ijkRange.ijkAtOffset(___2866); ___1843 const itemIJK = ___1879 + ___1861; ENSURE(itemIJK<m_zoneIJKDim); ENSURE(itemAddressAtItemIJK(itemIJK)==___2088); return itemIJK; } inline ItemAddress64 itemAddressAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex<getNumItems()); ___1843 const itemIJK = itemIJKAtItemIndex(itemIndex); ItemAddress64 const ___2088 = itemAddressAtItemIJK(itemIJK); return ___2088; } inline ___81 itemIndexAtItemAddress(ItemAddress64 ___2088) const { REQUIRE(validItemAddress(___2088)); ___1843 const itemIJK = itemIJKAtItemAddress(___2088); ___81 const itemIndex = itemIndexAtItemIJK(itemIJK); ENSURE(itemIndex<getNumItems()); ENSURE(itemAddressAtItemIndex(itemIndex)==___2088); return itemIndex; } inline ___81 itemIndexAtItemIJK(___1843 const& itemIJK) const { REQUIRE(itemIJK < m_zoneIJKDim); ___81 const itemIndex = m_zoneIJKDim.offsetAtIJK(itemIJK); ENSURE(itemIndex<getNumItems()); return itemIndex; } ___1843 itemIJKAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex<getNumItems()); ___1843 const itemIJK = m_zoneIJKDim.ijkAtOffset(itemIndex); ENSURE(itemIJK < m_zoneIJKDim); ENSURE(itemIndexAtItemIJK(itemIJK)==itemIndex); return itemIJK; } ItemAddress64::SubzoneOffset_t subzoneOffsetAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex < getNumItems()); ___1843 const itemIJK = itemIJKAtItemIndex(itemIndex); ___1843 const szIJK = szIJKAtItemIJK(itemIJK); ItemAddress64::SubzoneOffset_t const szOffset = static_cast<ItemAddress64::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(szIJK)); ENSURE(validSubzone(szOffset)); return szOffset; } ___372 getSubzonesOnIndexPlane( IJKPlanes_e                              whichPlane, ___81                               planeIndex, ___3270<ItemAddress64::SubzoneAddress>& szAddresses) const; ___372 getSubzonesOnIndexLine( IJKLines_e                               whichLine, ___81                               mIndex, ___81                               nIndex, ___3270<ItemAddress64::SubzoneAddress>& szAddresses) const; }; }}
