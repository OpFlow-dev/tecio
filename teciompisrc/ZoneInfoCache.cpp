#include "ZoneInfoCache.h"
#include "ThirdPartyHeadersBegin.h"
#include <functional>
#include <boost/foreach.hpp>
#include <boost/make_shared.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FEZoneInfo.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
#include "OrbFESubzonePartitioner.h"
#include "NoOpFESubzonePartitioner.h"
#include "PartitionTecUtilDecorator.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3934 { ZoneInfoCache::ZoneInfoCache( ___37*                 ___36, ___1843 const&                  maxIJKSubzoneSize, ItemAddress64::ItemOffset_t feSubzoneSize) : ___2338(___36) , m_maxIJKSubzoneSize(maxIJKSubzoneSize) , m_feSubzoneSize(feSubzoneSize) {} template<typename ZoneInfoType> void ZoneInfoCache::storeForSharedZones( boost::unordered_map<___4636, boost::shared_ptr<ZoneInfoType> >& zoneInfos, boost::shared_ptr<ZoneInfoType>                                      zoneInfo, ___4636                                                          zone) { ___3502 sharedZoneSet = ___2338->___543(zone + 1); if (sharedZoneSet) { for (___3494 sharedZone = ___2338->___3492(sharedZoneSet, zone + 1); sharedZone != 0; sharedZone = ___2338->___3492(sharedZoneSet, sharedZone)) { zoneInfos[static_cast<___4636>(sharedZone - 1)] = zoneInfo; } ___2338->___3485(&sharedZoneSet); } } template <typename ZoneInfoType> void ZoneInfoCache::storeForSharedPartitions( boost::unordered_map<___4636, boost::unordered_map<___4636, boost::shared_ptr<ZoneInfoType> > >& zoneInfos, boost::shared_ptr<ZoneInfoType> zoneInfo, ___4636 zone, ___4636 ___2978) { ___3502 sharedZoneSet = ___2338->___543(zone + 1); if (sharedZoneSet) { for (___3494 sharedZone = ___2338->___3492(sharedZoneSet, zone + 1); sharedZone != ___4040; sharedZone = ___2338->___3492(sharedZoneSet, sharedZone)) { zoneInfos[static_cast<___4636>(sharedZone - 1)][___2978] = zoneInfo; } ___2338->___3485(&sharedZoneSet); } } boost::shared_ptr<___1880> ZoneInfoCache::getIJKZoneInfo(___4636 zone) { REQUIRE(___4641(*___2338, zone) && !zoneIsPartitioned(*___2338, zone)); boost::shared_ptr<___1880> zoneInfo = m_ijkZoneInfos[zone]; if (!zoneInfo) { ___1843 ___4633; ___2338->___4615(zone + 1, ___4633); zoneInfo = boost::make_shared<___1880>(___4633, m_maxIJKSubzoneSize, DEFAULT_MINIMIZE_IJK_NUM_SUBZONES); m_ijkZoneInfos[zone] = zoneInfo; storeForSharedZones(m_ijkZoneInfos, zoneInfo, zone); } zoneInfo->resetNeighborInfo(); return zoneInfo; } boost::shared_ptr<___1880> ZoneInfoCache::getIJKZonePartitionInfo( ___4636 zone, ___4636 ___2978) { REQUIRE(0 <= zone && ___2338->___4638(zone + 1)); REQUIRE(___4641(*___2338, zone) && zoneIsPartitioned(*___2338, zone)); REQUIRE(0 <= ___2978 && ___2978 < ___2338->zoneGetNumPartitions(zone + 1)); boost::shared_ptr<___1880> zoneInfo = m_ijkZonePartitionInfos[zone][___2978]; if (!zoneInfo) { ___1843 ___1842; ___2338->zonePartitionGetIJK(zone + 1, ___2978 + 1, ___1842); ___1843 partitionOffset; ___2338->zonePartitionGetIJKOffset(zone + 1, ___2978 + 1, partitionOffset); ___1843 partitionMaxCorner = ___1842 + partitionOffset; ___1843 ___4632; ___2338->___4615(zone + 1, ___4632); zoneInfo = boost::make_shared<___1880>
(___1842, m_maxIJKSubzoneSize, ___2978, true, partitionMaxCorner.i() == ___4632.i(), partitionMaxCorner.___2104() == ___4632.___2104(), partitionMaxCorner.___2133() == ___4632.___2133()); m_ijkZonePartitionInfos[zone][___2978] = zoneInfo; storeForSharedPartitions(m_ijkZonePartitionInfos, zoneInfo, zone, ___2978); } zoneInfo->resetNeighborInfo(); return zoneInfo; } namespace { typedef std::function<___372( ___4265             dataSetID, ___4636            ___4658, ___4636            partitionNum, ___1170             section, FECellShape_e*         cellShape, ___1170*            gridOrder, FECellBasisFunction_e* basisFn, ___2226*             numElements, ___1170*            numNodesPerElem, ___1170*            numCornersPerElem) > GetSectionMetrics; } namespace { void zoneGetAllSectionMetrics( GetSectionMetrics const&            getSectionMetrics, ___37 const&                   ___36, ___1170                          zone, ___1170                          ___2978, ___1170                          numSections, std::vector<FECellShape_e>&         cellShape, std::vector<___1170>&            gridOrder, std::vector<FECellBasisFunction_e>& basisFn, std::vector<___2226>&             numElements, std::vector<CellNodeIndex_t>&       numLinearNodesPerCell, std::vector<CellNodeIndex_t>&       numHighOrderNodesPerCell) { REQUIRE(getSectionMetrics); REQUIRE(1 <= numSections && numSections <= checked_numeric_cast<___1170>(MAX_NUM_SECTIONS)); ___4265 const datasetID = ___36.datasetGetUniqueID(); cellShape.resize(numSections); gridOrder.resize(numSections); basisFn.resize(numSections); numElements.resize(numSections); numLinearNodesPerCell.resize(numSections); numHighOrderNodesPerCell.resize(numSections); ___1170 numNodesPerElem{0}; for (___1170 section = 0; section < numSections; ++section) { if (!getSectionMetrics(datasetID, zone + 1, ___2978 + 1, section + 1, &cellShape[section], &gridOrder[section], &basisFn[section], &numElements[section], &numLinearNodesPerCell[section], &numNodesPerElem)) throw std::runtime_error("failed to get zone section information"); numHighOrderNodesPerCell[section] = numNodesPerElem - numLinearNodesPerCell[section]; } } } boost::shared_ptr<___1348> ZoneInfoCache::getFEZoneInfo(___4636 zone) { REQUIRE(0 <= zone && ___2338->___4638(zone + 1)); REQUIRE(!___4641(*___2338, zone) && !___4643(*___2338, zone) && !zoneIsPartitioned(*___2338, zone)); boost::shared_ptr<___1348> zoneInfo = m_feZoneInfos[zone]; if (!zoneInfo) { ___1843 ___1842; ___2338->___4615(zone + 1, ___1842); ___2719 const ___2822 = static_cast<___2719>(___1842.i()); ___1170 numSections = 1; if (___2338->___4620(zone + 1) == ZoneType_FEMixed) { ___4265 const datasetID = ___2338->datasetGetUniqueID(); if (!___2338->zoneGetNumSections(datasetID, zone + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); } std::vector<FECellShape_e>         cellShape;
std::vector<___1170>            gridOrder; std::vector<FECellBasisFunction_e> basisFn; std::vector<___2226>             numElements; std::vector<CellNodeIndex_t>       numLinearNodesPerCell; std::vector<CellNodeIndex_t>       numHighOrderNodesPerCell; using namespace std::placeholders; zoneGetAllSectionMetrics(std::bind(&___37::zoneGetSectionMetrics, ___2338, _1, _2, _4, _5, _6, _7, _8, _9, _10), *___2338, zone, 0 , numSections, cellShape, gridOrder, basisFn, numElements, numLinearNodesPerCell, numHighOrderNodesPerCell); bool isSubzonedZoneType = ___3895(___2338->___4620(zone + 1), ___2338->zoneGetDimension(___2338->datasetGetUniqueID(),zone + 1)); boost::shared_ptr<FESubzonePartitionerInterface> nszPartitioner; if (isSubzonedZoneType) nszPartitioner = boost::make_shared<OrbFESubzonePartitioner>( std::ref(*___2338), zone, 0 , OrthogonalBisection::BisectionType_ZoneNodes, m_feSubzoneSize); else nszPartitioner = boost::make_shared<NoOpFESubzonePartitioner>( std::ref(*___2338), zone, 0 , OrthogonalBisection::BisectionType_ZoneNodes); std::vector<boost::shared_ptr<FESubzonePartitionerInterface> > secCszPartitioners; secCszPartitioners.reserve(numSections); for (___1170 section = 0; section < numSections; ++section) { if (isSubzonedZoneType) secCszPartitioners.push_back(boost::make_shared<OrbFESubzonePartitioner>( std::ref(*___2338), zone, section, OrthogonalBisection::BisectionType_ZoneCells, m_feSubzoneSize)); else secCszPartitioners.push_back(boost::make_shared<NoOpFESubzonePartitioner>( std::ref(*___2338), zone, section, OrthogonalBisection::BisectionType_ZoneCells)); } zoneInfo = boost::make_shared<___1348>( ___2822, numLinearNodesPerCell, numHighOrderNodesPerCell, nszPartitioner, secCszPartitioners, checked_numeric_cast<ItemAddress64::___2981>(zone)); m_feZoneInfos[zone] = zoneInfo; storeForSharedZones(m_feZoneInfos, zoneInfo, zone); } zoneInfo->resetNeighborInfo(); return zoneInfo; } boost::shared_ptr<___1348> ZoneInfoCache::getFEZonePartitionInfo( ___4636 zone, ___4636 ___2978, PartitionTecUtilDecorator& partitionTecUtilDecorator) { REQUIRE(0 <= zone && ___2338->___4638(zone + 1)); REQUIRE(!___4641(*___2338, zone) && !___4643(*___2338, zone) && zoneIsPartitioned(*___2338, zone)); REQUIRE(0 <= ___2978 && ___2978 < ___2338->zoneGetNumPartitions(zone + 1)); boost::shared_ptr<___1348> zoneInfo = m_feZonePartitionInfos[zone][___2978]; if (!zoneInfo) { ___1843 ___1842; ___2338->zonePartitionGetIJK(zone + 1, ___2978 + 1, ___1842); ___2719 ___2822 = static_cast<___2719>(___1842.i()); ___1170 numSections = 1; if (___2338->___4620(zone + 1) == ZoneType_FEMixed) { ___4265 const datasetID = ___2338->datasetGetUniqueID(); if (!___2338->zoneGetNumSections(datasetID, zone + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); } std::vector<___463> secNumGhostCells(numSections, 0);
GhostInfo_pa ghostCellInfo = ___2338->zonePartitionGhostCellInfoGetRef(zone + 1, ___2978 + 1); if (ghostCellInfo) { for (___1170 section = 0; section < numSections; ++section) secNumGhostCells[section] = static_cast<___463>( ___2338->ghostInfoGetNumItemsByRef(ghostCellInfo, section+1)); } ___2719 numGhostNodes = 0; GhostInfo_pa ghostNodeInfo = ___2338->zonePartitionGhostNodeInfoGetRef(zone + 1, ___2978 + 1); if (ghostNodeInfo) numGhostNodes = static_cast<___463>(___2338->ghostInfoGetNumItemsByRef(ghostNodeInfo, 1 )); std::vector<FECellShape_e>         cellShape; std::vector<___1170>            gridOrder; std::vector<FECellBasisFunction_e> basisFn; std::vector<___2226>             numElements; std::vector<CellNodeIndex_t>       numLinearNodesPerCell; std::vector<CellNodeIndex_t>       numHighOrderNodesPerCell; using namespace std::placeholders; zoneGetAllSectionMetrics(std::bind(&___37::zonePartitionGetSectionMetrics, ___2338, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10), *___2338, zone, ___2978, numSections, cellShape, gridOrder, basisFn, numElements, numLinearNodesPerCell, numHighOrderNodesPerCell); boost::shared_ptr<FESubzonePartitionerInterface> nszPartitioner = boost::make_shared<OrbFESubzonePartitioner>( std::ref(partitionTecUtilDecorator), ___2978, 0 , OrthogonalBisection::BisectionType_ZoneNodes, m_feSubzoneSize); std::vector<boost::shared_ptr<FESubzonePartitionerInterface> > secCszPartitioners; secCszPartitioners.reserve(numSections); for (___1170 section = 0; section < numSections; ++section) secCszPartitioners.push_back(boost::make_shared<OrbFESubzonePartitioner>( std::ref(partitionTecUtilDecorator), ___2978, section, OrthogonalBisection::BisectionType_ZoneCells, m_feSubzoneSize)); zoneInfo = boost::make_shared<___1348>( ___2822, numLinearNodesPerCell, numHighOrderNodesPerCell, nszPartitioner, secCszPartitioners, checked_numeric_cast<ItemAddress64::___2981>(___2978), secNumGhostCells, numGhostNodes); m_feZonePartitionInfos[zone][___2978] = zoneInfo; storeForSharedPartitions(m_feZonePartitionInfos, zoneInfo, zone, ___2978); } zoneInfo->resetNeighborInfo(); return zoneInfo; } void ZoneInfoCache::remove(___4636 zone) { m_ijkZoneInfos.erase(zone); m_feZoneInfos.erase(zone); m_ijkZonePartitionInfos.erase(zone); m_feZonePartitionInfos.erase(zone); } void ZoneInfoCache::clear() { m_ijkZoneInfos.clear(); m_feZoneInfos.clear(); m_ijkZonePartitionInfos.clear(); m_feZonePartitionInfos.clear(); } template <typename MapType> void shareZoneInfosInMap(___3502 zonesToWrite, MapType& map, ___37& tecUtil) { REQUIRE(VALID_REF(zonesToWrite)); if (!map.empty()) { ___3502 cachedZoneSet = tecUtil.setAlloc(___1303); BOOST_FOREACH(typename MapType::value_type const& zoneIndexAndZoneInfoPair, map) tecUtil.setAddMember(cachedZoneSet, zoneIndexAndZoneInfoPair.first + 1, ___1303); ___3494 zone; for (zone = tecUtil.___3492(zonesToWrite, ___4040); zone != ___4040;
zone = tecUtil.___3492(zonesToWrite, zone)) { ___4636 sharedZone = (___4636)tecUtil.___542(cachedZoneSet, (___4636)zone); if (sharedZone != ___4036) map[(___4636)zone - 1] = map[sharedZone - 1]; } tecUtil.___3485(&cachedZoneSet); } } template <typename MapType> void shareZonePartitionInfosInMap(___3502 zonesToWrite, MapType& map, ___37& tecUtil) { if (!map.empty()) { ___3502 cachedZoneSet = tecUtil.setAlloc(___1303); BOOST_FOREACH(typename MapType::value_type const& valuePair, map) tecUtil.setAddMember(cachedZoneSet, valuePair.first + 1, ___1303); ___3494 zone; for (zone = tecUtil.___3492(zonesToWrite, ___4040); zone != ___4040; zone = tecUtil.___3492(zonesToWrite, zone)) { ___4636 sharedZone = (___4636)tecUtil.___542(cachedZoneSet, (___4636)zone); if (sharedZone != ___4036) { typename MapType::mapped_type const& partitionMap = map[sharedZone - 1]; BOOST_FOREACH(typename MapType::mapped_type::value_type const& partitionInfoPair, partitionMap) map[(___4636)zone - 1][partitionInfoPair.first] = map[sharedZone - 1][partitionInfoPair.first]; } } tecUtil.___3485(&cachedZoneSet); } } void ZoneInfoCache::replaceDataSource(___37* ___36, ___3502 zonesToWrite) { ___2338 = ___36; if (zonesToWrite) { shareZoneInfosInMap(zonesToWrite, m_ijkZoneInfos, *___2338); shareZoneInfosInMap(zonesToWrite, m_feZoneInfos, *___2338); shareZonePartitionInfosInMap(zonesToWrite, m_ijkZonePartitionInfos, *___2338); shareZonePartitionInfosInMap(zonesToWrite, m_feZonePartitionInfos, *___2338); } } }}
