 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cfloat>
 #define _USE_MATH_DEFINES
#include <cmath> 
 #if defined MSWIN
 #define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
 #pragma warning (disable:4996) 
 #endif
#include <cstdarg>
#include <cstdlib>
#include <cstring>
#include <set>
#include <string>
#include <utility>
#include <vector>
#include <boost/functional/hash.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "ClassMacros.h"
#include "MinMax.h"
#include "basicTypes.h"
#include "IJK.h"
#include "ItemAddress.h"
#include "LightweightVector.h"
#include "AnyTypeLightweightVector.h"
#include "RawArray.h"
#include "showMessage.h"
#include "xyz.h"
namespace tecplot { namespace ___3934 { class CszConnectivity;
 #define MAX_ERROR_MESSAGE_SIZE 500
 #define countOf(staticArray) ( sizeof((staticArray))/sizeof((staticArray)[0]) )
 #define numItemsOf(someArray) ( sizeof((someArray))/sizeof(*(someArray)) )
static ItemAddress64::ItemOffset_t const DEFAULT_SUBZONE_MAX_I_DIM = 6; static ItemAddress64::ItemOffset_t const DEFAULT_SUBZONE_MAX_J_DIM = 6; static ItemAddress64::ItemOffset_t const DEFAULT_SUBZONE_MAX_K_DIM = 6;
 #define DEFAULT_SUBZONE_MAX_IJK_DIM ___1843(DEFAULT_SUBZONE_MAX_I_DIM, DEFAULT_SUBZONE_MAX_J_DIM, DEFAULT_SUBZONE_MAX_K_DIM)
static ItemAddress64::ItemOffset_t const DEFAULT_SUBZONE_MAX_FE_SIZE = 256; static bool const DEFAULT_MINIMIZE_IJK_NUM_SUBZONES = false; static bool const DEFAULT_MINIMIZE_SYNTHETIC_FE_NUM_SUBZONES = false; static ___4636 const NOT_SHARED = static_cast<___4636>(-1); static ItemAddress64::SectionOffset_t const MAX_NUM_SECTIONS = ItemAddress64::MAX_SECTION_OFFSET+1; typedef ___2241<ItemAddress64>                 ItemAddressArray; typedef ___2241<ItemAddress64::SubzoneAddress> SubzoneAddressArray; template<typename T> inline bool reserveVectorSpace(std::vector<T>& vectorToReserve, size_t newSize) { REQUIRE(newSize>0); bool ___2038 = false; try { vectorToReserve.reserve(newSize); ___2038 = true; } catch (...) { ___2038 = ___1303; } ENSURE(IMPLICATION(___2038, vectorToReserve.capacity()>=newSize)); return ___2038; } template<typename T> inline bool resizeVector(std::vector<T>& vectorToResize, size_t newSize) { REQUIRE(newSize>0); bool ___2038 = false; try { vectorToResize.resize(newSize); ___2038 = true; } catch (...) { ___2038 = ___1303; } ENSURE(IMPLICATION(___2038, vectorToResize.size()==newSize)); return ___2038; } template<typename T> inline bool resizeVector(std::vector<T>& vectorToSize, size_t newSize, T padValue) { REQUIRE(newSize>0); bool ___2038 = false; try { vectorToSize.resize(newSize, padValue); ___2038 = true; } catch (...) { ___2038 = ___1303; } ENSURE(IMPLICATION(___2038, vectorToSize.size()==newSize)); return ___2038; } template<typename T> inline bool resize2DVector(std::vector<std::vector<T> >& vector2D, size_t newDim1, size_t newDim2) { REQUIRE(newDim1>0); REQUIRE(newDim2>0); bool ___2038 = false; try { vector2D.resize(newDim1); for ( size_t ___1840 = 0; ___1840 < newDim1; ___1840++ ) vector2D[___1840].resize(newDim2); ___2038 = true; } catch (...) { ___2038 = ___1303; } ENSURE(IMPLICATION(___2038, vector2D.size()==newDim1)); ENSURE(IMPLICATION(___2038, vector2D[0].size()==newDim2)); ENSURE(IMPLICATION(___2038, vector2D[newDim1/2].size()==newDim2)); ENSURE(IMPLICATION(___2038, vector2D[newDim1-1].size()==newDim2)); return ___2038; } template<typename T> inline bool resize2DVector(std::vector<std::vector<T> >& vector2D, size_t newDim1, size_t newDim2, T padValue) { REQUIRE(newDim1>0); REQUIRE(newDim2>0); bool ___2038 = false; try { vector2D.resize(newDim1); for ( size_t ___1840 = 0; ___1840 < newDim1; ___1840++ ) vector2D[___1840].resize(newDim2, padValue); ___2038 = true; } catch (...) { ___2038 = ___1303; } ENSURE(IMPLICATION(___2038, vector2D.size()==newDim1)); ENSURE(IMPLICATION(___2038, vector2D[0].size()==newDim2)); ENSURE(IMPLICATION(___2038, vector2D[newDim1/2].size()==newDim2)); ENSURE(IMPLICATION(___2038, vector2D[newDim1-1].size()==newDim2)); return ___2038; } template<typename T> inline void clearAndDeallocStdSet(std::set<T>& setToClear) { std::set<T>().swap(setToClear); } typedef ___2241<char>     ___471; typedef ___2241<uint8_t>  UInt8Array; typedef ___2241<uint16_t> UInt16Array; typedef ___2241<uint32_t> UInt32Array; typedef ___2241<uint64_t> UInt64Array; typedef ___2241<int32_t>  ___1964;
typedef ___2241<int64_t>  Int64Array; typedef ___2241<double>   ___1103; typedef ___2241<float>    ___1433; typedef ___2241<___463>                    ___462; typedef ___2241<___2719>                    ___2718; typedef ___2241<___4636>                    ___4635; typedef ___2241<ItemAddress64::SubzoneOffset_t> SubzoneOffsetArray; typedef ___2241<ItemAddress64::ItemOffset_t>    ItemOffsetArray; typedef ___2241<___372>                      BooleanArray; typedef ___2241<std::string>                    ___3817; typedef std::set<ItemAddress64::SubzoneAddress> SubzoneAddressSet; typedef ___2241<SubzoneAddressSet>  SubzoneAddressSetArray; struct SubzoneAddressHasher { inline std::size_t operator()(ItemAddress64::SubzoneAddress const& ___3881) const { std::size_t seed = 0; boost::hash_combine(seed, ___3881.___2978()); boost::hash_combine(seed, ___3881.sectionOffset()); boost::hash_combine(seed, ___3881.subzoneOffset()); return seed; } }; struct SubzoneAddressPredicate { inline bool operator()( ItemAddress64::SubzoneAddress const& ___2228, ItemAddress64::SubzoneAddress const& ___3393) const { return ___2228 == ___3393; } }; typedef boost::unordered_set< ItemAddress64::SubzoneAddress, SubzoneAddressHasher, SubzoneAddressPredicate> SubzoneAddressUnorderedSet; typedef std::set<ItemAddress64::SubzoneOffset_t> SubzoneOffsetSet; typedef ___2241<SubzoneOffsetSet>    SubzoneOffsetSetArray; typedef ___2241<UInt8Array>       VarZoneUInt8Array; typedef ___2241<___1391>        ___1390; typedef ___2241<___1390>     FileLoc2DArray; typedef ___2241<FileLoc2DArray>   FileLoc3DArray; typedef ___2241<FileLoc3DArray>   FileLoc4DArray; typedef ___2241<FileLoc4DArray>   FileLoc5DArray;
 #if 0
typedef ___1390                             SzFileLocArray; typedef ___2241<SzFileLocArray>        PtnSzFileLocArray; typedef ___2241<PtnSzFileLocArray>     ZonePtnSzFileLocArray; typedef ___2241<ZonePtnSzFileLocArray> VarZonePtnSzFileLocArray; typedef ___1390                             PtnFileLocArray; typedef ___2241<PtnFileLocArray>       ZnPtnFileLocArray; typedef ___1390                             VarFileLocArray; typedef ___2241<VarFileLocArray>       PtnVarFileLocArray; typedef ___2241<PtnVarFileLocArray>    ZonePtnVarFileLocArray; typedef ___1390                             ZoneFileLocArray; typedef ___2241<ZoneFileLocArray>      VarZoneFileLocArray;
 #endif
typedef AnyTypeLightweightVector                 FieldDataArray; typedef ___2241<FieldDataArray>        SzFieldData; typedef ___2241<SzFieldData>           PtnSzFieldData; typedef ___2241<PtnSzFieldData>        SecPtnSzFieldData; typedef ___2241<SecPtnSzFieldData>     ZoneSecPtnSzFieldData; typedef ___2241<ZoneSecPtnSzFieldData> VarZoneSecPtnSzFieldData; typedef uint16_t InterpCount_t; static InterpCount_t const MAX_INTERP_COUNT = InterpCount_t(-1); typedef ___2241<InterpCount_t>                InterpCountArray; typedef ___2241<InterpCountArray>             SzInterpCountArray; typedef ___2241<SzInterpCountArray>           PtnSzInterpCountArray; typedef ___2241<PtnSzInterpCountArray>        SecPtnSzInterpCountArray; typedef ___2241<SecPtnSzInterpCountArray>     ZoneSecPtnSzInterpCountArray; typedef ___2241<ZoneSecPtnSzInterpCountArray> VarZoneSecPtnSzInterpCountArray; typedef ___2241<BooleanArray>            PtnBooleanArray; typedef ___2241<PtnBooleanArray>         SecPtnBooleanArray; typedef ___2241<SecPtnBooleanArray>      ZoneSecPtnBooleanArray; typedef ___2241<ZoneSecPtnBooleanArray>  VarZoneSecPtnBooleanArray; typedef ___2241<uint8_t>                ValueLocationArray; typedef ___2241<ValueLocationArray>     ___4391; typedef ___2241<uint8_t>                FieldDataTypeArray; typedef ___2241<FieldDataTypeArray>     ___4382; typedef ___2241<uint8_t>        IsPassiveArray; typedef ___2241<IsPassiveArray> ___4385; typedef ___2241<___4635> ___4388; typedef ___2241<___1103> VarZoneDoubleArray; typedef ___2241<ItemAddress64::___2981> PartitionArray; struct ___230 { std::string ___2496; std::string ___2668; AuxDataLocation_e m_location; ___1170 m_entity; AuxDataType_e m_type; ___230() {} ___230( std::string const& ___2686, std::string const& value, AuxDataLocation_e location, ___1170 entity, AuxDataType_e type) : ___2496(___2686) , ___2668(value) , m_location(location) , m_entity(entity) , m_type(type) {} }; struct ___1554 { double ___2618[3]; CoordSys_e ___2617; ___372 ___2485; ___1170 ___2678; ___514 ___2396; ___514 ___2463; ___372 ___2487; GeomType_e ___2467; LinePattern_e ___2490; double ___2616; double ___2491; uint16_t ___2503; ArrowheadStyle_e ___2344; ArrowheadAttachment_e ___2342; double ___2343; double ___2341; Scope_e ___2620; Clipping_e ___2395; std::vector<std::vector<class ___4580> > ___2465; std::string ___2492; ___1554() {} ___1554( double ___4574, double ___4591, double ___4715, CoordSys_e ___3160, ___372 ___2003, ___1170 zone, ___514 color, ___514 ___1409, ___372 ___2021,
GeomType_e ___1650, LinePattern_e ___2264, double ___2987, double ___2290, uint16_t ___2794, ArrowheadStyle_e arrowheadStyle, ArrowheadAttachment_e arrowheadAttachment, double arrowheadSize, double arrowheadAngle, Scope_e ___3443, Clipping_e ___493, std::vector<std::vector<___4580> > const& ___1570, std::string const& ___2331) : ___2617(___3160) , ___2485(___2003) , ___2678(zone) , ___2396(color) , ___2463(___1409) , ___2487(___2021) , ___2467(___1650) , ___2490(___2264) , ___2616(___2987) , ___2491(___2290) , ___2503(___2794) , ___2344(arrowheadStyle) , ___2342(arrowheadAttachment) , ___2343(arrowheadSize) , ___2341(arrowheadAngle) , ___2620(___3443) , ___2395(___493) , ___2465(___1570) , ___2492(___2331) { ___2618[0] = ___4574; ___2618[1] = ___4591; ___2618[2] = ___4715; } }; struct Text { ___514 ___2629; ___514 ___2630; double ___2631; double ___2632; TextBox_e ___2633; TextAnchor_e ___2626; double ___2627[3]; double ___2628; Clipping_e ___2634; ___514 ___2635; double ___2636; double ___2638; std::string ___2639; CoordSys_e ___2640; Scope_e ___2642; Units_e ___2643; std::string ___2644; std::string ___2645; ___372 ___2646; ___372 ___2647; ___1170 ___2648; ___372 ___2637; Text() {} Text( double ___4574, double ___4591, double ___4713, ___514 ___4060, ___514 ___4062, double ___4072, double ___4074, TextBox_e ___4079, TextAnchor_e ___4044, double ___4057, Clipping_e ___4080, ___514 ___4081, double ___4104, double ___4108, std::string ___4110, CoordSys_e ___4116, Scope_e ___4120, Units_e ___4125, std::string ___4127, std::string ___4130, ___372 ___4133, ___372 ___4135, ___1170 ___4139, ___372 ___4106) : ___2629(___4060) , ___2630(___4062) , ___2631(___4072) , ___2632(___4074) , ___2633(___4079) , ___2626(___4044) , ___2628(___4057) , ___2634(___4080) , ___2635(___4081) , ___2636(___4104) , ___2638(___4108) , ___2639(___4110) , ___2640(___4116) , ___2642(___4120) , ___2643(___4125) , ___2644(___4127) , ___2645(___4130) , ___2646(___4133) , ___2647(___4135) , ___2648(___4139) , ___2637(___4106) { ___2627[0] = ___4574;
___2627[1] = ___4591; ___2627[2] = ___4713; } }; struct CustomLabelSet { uint32_t m_numLabels; ___3817 m_labels; }; typedef ___2241<___230> AuxDataArray; typedef ___2241<___1554> GeomArray; typedef ___2241<Text> TextArray; typedef ___2241<CustomLabelSet> CustomLabelsArray; typedef ___2241<RefSubzoneOffset_t>    RefSubzoneOffsetArray; class NszConnectivity { UNCOPYABLE_CLASS(NszConnectivity); public: SubzoneAddressArray m_refCszs; RefSubzoneOffset_t   m_numRefCszs; NszConnectivity() : m_numRefCszs(0) { } ~NszConnectivity() { ___935(); } uint64_t numBytesAllocated(void) const { return m_refCszs.numBytesAllocated(m_numRefCszs); } void ___935() { m_numRefCszs = 0; m_refCszs.___935(); ENSURE(empty()); } bool setNumRszs(RefSubzoneOffset_t numRszs) { REQUIRE(___2066()); REQUIRE(numRszs != BAD_REFSZ_INDEX); bool ___2038; if ( numRszs == 0 ) { m_numRefCszs = numRszs; ___476(m_refCszs.empty()); ___2038 = true; } else { ___2038 = m_refCszs.alloc(numRszs); if ( ___2038 ) m_numRefCszs = numRszs; else ___935(); } ENSURE(___2066()); return ___2038; } inline bool ___2066() const { ___476(EQUIVALENCE(m_refCszs.empty(), m_numRefCszs == 0)); ___476(IMPLICATION(!m_refCszs.empty(), m_refCszs.size() == size_t(m_numRefCszs))); return true; } inline bool empty() const { REQUIRE(___2066()); return m_numRefCszs==0; } inline RefSubzoneOffset_t getNumRszs() const { REQUIRE(___2066()); return m_numRefCszs; } inline ItemAddress64::SubzoneAddress const& getRszAddress(RefSubzoneOffset_t refSubzoneOffset) const { REQUIRE(___2066()); REQUIRE(refSubzoneOffset<getNumRszs()); return m_refCszs[refSubzoneOffset]; } inline bool getRszAddresses(___3270<ItemAddress64::SubzoneAddress>& rszAddresses) const { REQUIRE(___2066()); REQUIRE(rszAddresses.empty()); bool ___2038 = true; try { ___476(m_numRefCszs>0); rszAddresses.reserve(m_numRefCszs); rszAddresses.___3504(m_numRefCszs); memcpy(rszAddresses.data(), m_refCszs.data(), m_numRefCszs*sizeof(ItemAddress64::SubzoneAddress)); } catch (...) { ___2038 = ___1184("Out of memory in getRefCszAddresses"); } return ___2038; } }; typedef ___2241<CszConnectivity>             CszConnectivityArray; typedef ___2241<CszConnectivityArray>        PtnCszConnectivity; typedef ___2241<PtnCszConnectivity>          SecPtnCszConnectivity; typedef ___2241<SecPtnCszConnectivity>       ZoneSecPtnCszConnectivity; typedef ___2241<RefSubzoneOffsetArray>       PtnRefSubzoneOffsetArray; typedef ___2241<PtnRefSubzoneOffsetArray>    SecPtnRefSubzoneOffsetArray; typedef ___2241<SecPtnRefSubzoneOffsetArray> ZoneSecPtnRefSubzoneOffsetArray; typedef ___2241<NszConnectivity>             NszConnectivityArray; typedef ___2241<NszConnectivityArray>        PtnNszConnectivity; typedef ___2241<PtnNszConnectivity>          ZonePtnNszConnectivity; typedef ___2241<ItemOffsetArray>             ZoneSzSizeArray; typedef ___2241<___463>                 CellSubzoneFirstItemArray;
typedef ___2241<CellSubzoneFirstItemArray>   ZoneCszFirstItemArray; typedef ___2241<___2719>                 NodeSubzoneFirstItemArray; typedef ___2241<NodeSubzoneFirstItemArray>   ZoneNszFirstItemArray; typedef ___2241<___81>                  AnySzFirstItemArray; typedef ___2241<AnySzFirstItemArray>         ZoneAnySzFirstItemArray; typedef ___2241<___2480>                      ___2482; typedef ___2241<___2482>                 VarZoneMinMaxArray; }}
