 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <type_traits>
#include "ThirdPartyHeadersEnd.h"
#include "CodeContract.h"
#include "StandardIntegralTypes.h"
namespace tecplot {
 #define SIZE_IN_BITS(___1836) (sizeof(___1836)*8u)
 #define VALID_ITEM_ADDRESS_PARTITION(itemAddressPartition) \
 ((itemAddressPartition) != tecplot::ItemAddress64::INVALID_PARTITION && \
 (SIZE_IN_BITS(tecplot::ItemAddress64::___2981) == tecplot::ItemAddress64::PartitionBitSize || \
 (SIZE_IN_BITS(tecplot::ItemAddress64::___2981) > tecplot::ItemAddress64::PartitionBitSize && \
 uint64_t(itemAddressPartition) >> tecplot::ItemAddress64::PartitionBitSize == uint64_t(0))))
 #define VALID_ITEM_ADDRESS_SECTION_OFFSET(itemAddressSectionOffset) \
 ((itemAddressSectionOffset) != tecplot::ItemAddress64::INVALID_SECTION_OFFSET && \
 (SIZE_IN_BITS(tecplot::ItemAddress64::SectionOffset_t) == tecplot::ItemAddress64::SectionOffsetBitSize || \
 (SIZE_IN_BITS(tecplot::ItemAddress64::SectionOffset_t) > tecplot::ItemAddress64::SectionOffsetBitSize && \
 uint64_t(itemAddressSectionOffset) >> tecplot::ItemAddress64::SectionOffsetBitSize == uint64_t(0))))
 #define VALID_ITEM_ADDRESS_SUBZONE_OFFSET(itemAddressSubzoneOffset) \
 ((itemAddressSubzoneOffset) != tecplot::ItemAddress64::INVALID_SUBZONE_OFFSET && \
 (SIZE_IN_BITS(tecplot::ItemAddress64::SubzoneOffset_t) == tecplot::ItemAddress64::SubzoneOffsetBitSize || \
 (SIZE_IN_BITS(tecplot::ItemAddress64::SubzoneOffset_t) > tecplot::ItemAddress64::SubzoneOffsetBitSize && \
 uint64_t(itemAddressSubzoneOffset) >> tecplot::ItemAddress64::SubzoneOffsetBitSize == uint64_t(0))))
 #define VALID_ITEM_ADDRESS_ITEM_OFFSET(itemAddressItemOffset) \
 ((itemAddressItemOffset) != tecplot::ItemAddress64::INVALID_ITEM_OFFSET && \
 (SIZE_IN_BITS(tecplot::ItemAddress64::ItemOffset_t) == tecplot::ItemAddress64::ItemOffsetBitSize || \
 (SIZE_IN_BITS(tecplot::ItemAddress64::ItemOffset_t) > tecplot::ItemAddress64::ItemOffsetBitSize && \
 uint64_t(itemAddressItemOffset) >> tecplot::ItemAddress64::ItemOffsetBitSize == uint64_t(0))))
 #define VALID_UNIFORM_ITEM_ADDRESS(___2088) \
 ((___2088).___2064())
 #define VALID_SZL_ITEM_ADDRESS(___2088) \
 ((___2088).isSzlItem() && \
 VALID_ITEM_ADDRESS_PARTITION((___2088).___2978()) && \
 VALID_ITEM_ADDRESS_SECTION_OFFSET((___2088).sectionOffset()) && \
 VALID_ITEM_ADDRESS_SUBZONE_OFFSET((___2088).subzoneOffset()) && \
 VALID_ITEM_ADDRESS_ITEM_OFFSET((___2088).itemOffset()))
 #define VALID_ITEM_ADDRESS(___2088) \
 (VALID_UNIFORM_ITEM_ADDRESS(___2088) || \
 VALID_SZL_ITEM_ADDRESS(___2088))
 #define VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(subzoneAddress) \
 (VALID_ITEM_ADDRESS_PARTITION((subzoneAddress).___2978()) && \
 VALID_ITEM_ADDRESS_SECTION_OFFSET((subzoneAddress).sectionOffset()) && \
 VALID_ITEM_ADDRESS_SUBZONE_OFFSET((subzoneAddress).subzoneOffset()))
template <typename ITEM_TYPE> class ___2089 { public: static_assert(std::is_same<ITEM_TYPE,int32_t>::value || std::is_same<ITEM_TYPE,int64_t>::value, "ITEM_TYPE must be a signed int32_t or int64_t type"); using SIGNED_INTEGER = ITEM_TYPE; using UNSIGNED_INTEGER = typename std::make_unsigned<SIGNED_INTEGER>::type; using ___2981 = uint32_t; using SectionOffset_t = uint32_t; using SubzoneIndex_t = uint64_t; using SubzoneOffset_t = uint32_t; using ItemOffset_t = uint16_t; using ___4262 = SIGNED_INTEGER; static constexpr uint32_t ___15 = 1u; static constexpr uint32_t SectionOffsetBitSize = 4u; static constexpr uint32_t ItemOffsetBitSize = 8u; static_assert(SIZE_IN_BITS(UNSIGNED_INTEGER)/2u > SectionOffsetBitSize, "Not sufficient bits available for subzones."); static constexpr uint32_t SubzoneOffsetBitSize = SIZE_IN_BITS(UNSIGNED_INTEGER)/2u - SectionOffsetBitSize; static_assert(SIZE_IN_BITS(UNSIGNED_INTEGER) > ___15 + SectionOffsetBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize, "Not sufficient bits available for partitions."); static constexpr uint32_t PartitionBitSize = SIZE_IN_BITS(UNSIGNED_INTEGER) - (___15 + SectionOffsetBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize); static_assert(SIZE_IN_BITS(UNSIGNED_INTEGER) > ___15 + SectionOffsetBitSize, "Not sufficient bits available for uniform offsets."); static constexpr uint32_t ___4260 = SIZE_IN_BITS(UNSIGNED_INTEGER) - (___15 + SectionOffsetBitSize); static constexpr uint32_t SzlAddressType     = 0u; static constexpr uint32_t UniformAddressType = 1u; static constexpr SectionOffset_t INVALID_SECTION_OFFSET = static_cast<SectionOffset_t>((uint64_t(1) << SectionOffsetBitSize)); static constexpr SectionOffset_t MAX_SECTION_OFFSET = INVALID_SECTION_OFFSET - static_cast<SectionOffset_t>(1); static constexpr ItemOffset_t INVALID_ITEM_OFFSET = static_cast<ItemOffset_t>((uint64_t(1) << ItemOffsetBitSize)); static constexpr ItemOffset_t MAX_ITEM_OFFSET = INVALID_ITEM_OFFSET - static_cast<ItemOffset_t>(1); static constexpr ___2981 INVALID_PARTITION = static_cast<___2981>((uint64_t(1) << PartitionBitSize) - uint64_t(1)); static constexpr ___2981 UNKNOWN_PARTITION = 0u; static constexpr ___2981 MAX_PARTITION = INVALID_PARTITION - static_cast<___2981>(1); static constexpr SubzoneOffset_t INVALID_SUBZONE_OFFSET = static_cast<SubzoneOffset_t>((uint64_t(1) << SubzoneOffsetBitSize) - uint64_t(1)); static constexpr SubzoneOffset_t MAX_SUBZONE_OFFSET = INVALID_SUBZONE_OFFSET - static_cast<SubzoneOffset_t>(1); static constexpr ___4262 INVALID_UNIFORM_OFFSET = static_cast<___4262>((uint64_t(1) << (___4260 - 1u))); static constexpr ___4262 MAX_UNIFORM_OFFSET = INVALID_UNIFORM_OFFSET - static_cast<___4262>(1); private: struct BaseAddress_s { UNSIGNED_INTEGER ___14:___15; UNSIGNED_INTEGER sectionOffset:SectionOffsetBitSize; }; struct SzlItemAddress_s
{ UNSIGNED_INTEGER ___14:___15; UNSIGNED_INTEGER sectionOffset:SectionOffsetBitSize; UNSIGNED_INTEGER ___2978:PartitionBitSize; UNSIGNED_INTEGER subzoneOffset:SubzoneOffsetBitSize; UNSIGNED_INTEGER itemOffset:ItemOffsetBitSize; }; struct ___4258 { UNSIGNED_INTEGER ___14:___15; UNSIGNED_INTEGER sectionOffset:SectionOffsetBitSize; SIGNED_INTEGER   ___2866:___4260; }; public: class SubzoneAddress { public: SubzoneAddress(); SubzoneAddress( ___2981     ___2978, SectionOffset_t sectionOffset, SubzoneOffset_t subzoneOffset); ___2981 ___2978() const; SectionOffset_t sectionOffset() const; SubzoneOffset_t subzoneOffset() const; bool operator==(SubzoneAddress const& ___2889) const; bool operator!=(SubzoneAddress const& ___2889) const; bool operator<(SubzoneAddress const& ___2889) const; bool operator<=(SubzoneAddress const& ___2889) const; bool operator>(SubzoneAddress const& ___2889) const; bool operator>=(SubzoneAddress const& ___2889) const; UNSIGNED_INTEGER toRawBits() const; static SubzoneAddress fromRawBits(UNSIGNED_INTEGER ___3271); private: union { BaseAddress_s    baseAddress; SzlItemAddress_s szlItemAddress; UNSIGNED_INTEGER ___3271; } m; }; ___2089(); ___2089(___2089<int32_t> const& ___2889); ___2089(___2089<int64_t> const& ___2889); ___2089(___2089&& ___2889) = default; ___2089( ___2981     ___2978, SectionOffset_t sectionOffset, SubzoneOffset_t subzoneOffset, ItemOffset_t    itemOffset); ___2089( SubzoneAddress subzoneAddress, ItemOffset_t   itemOffset); explicit ___2089(___4262 ___4259); ___2089( SectionOffset_t sectionOffset, ___4262 ___4259); bool ___2064() const; bool isSzlItem() const; uint32_t ___14() const; SubzoneAddress subzoneAddress() const; ___2981 ___2978() const; SectionOffset_t sectionOffset() const; SubzoneOffset_t subzoneOffset() const; ItemOffset_t itemOffset() const; ___4262 ___4259() const; UNSIGNED_INTEGER toRawBits() const; static ___2089 fromRawBits(UNSIGNED_INTEGER ___3271); ___2089& operator=(___2089 const& ___2889) = default; ___2089& operator=(___2089&& ___2889) = default; bool operator==(___2089 const& ___2889) const; bool operator!=(___2089 const& ___2889) const; bool operator<(___2089 const& ___2889) const; bool operator<=(___2089 const& ___2889) const; bool operator>(___2089 const& ___2889) const; bool operator>=(___2089 const& ___2889) const; private:
 #if !defined NO_ASSERTS
static bool ___4307();
 #endif
union { BaseAddress_s    baseAddress; SzlItemAddress_s szlItemAddress; ___4258 ___4257; UNSIGNED_INTEGER ___3271; } m; }; using ItemAddress32 = ___2089<int32_t>; using ItemAddress64 = ___2089<int64_t>; static_assert(sizeof(ItemAddress32) == sizeof(ItemAddress32::SIGNED_INTEGER) && sizeof(ItemAddress64) == sizeof(ItemAddress64::SIGNED_INTEGER), "The size of the ItemAddress union must be the same size as the ITEM_TYPE."); template <typename ITEM_TYPE> inline ___2089<ITEM_TYPE>::___2089() { INVARIANT(___4307()); } template <> inline ___2089<int64_t>::___2089(___2089<int32_t> const& ___2889) { m.baseAddress.___14   = ___2889.___14(); m.baseAddress.sectionOffset = ___2889.sectionOffset(); if (___2889.isSzlItem()) { m.szlItemAddress.___2978     = ___2889.___2978(); m.szlItemAddress.subzoneOffset = ___2889.subzoneOffset(); m.szlItemAddress.itemOffset    = ___2889.itemOffset(); } else { m.___4257.___2866 = ___2889.___4259(); } } template <> inline ___2089<int32_t>::___2089(___2089<int64_t> const& ___2889) { REQUIRE(IMPLICATION(___2889.isSzlItem() && sizeof(___2089) < sizeof(___2889), ___2889.___2978()     <= MAX_PARTITION && ___2889.sectionOffset() <= MAX_SECTION_OFFSET && ___2889.subzoneOffset() <= MAX_SUBZONE_OFFSET && ___2889.itemOffset()    <= MAX_ITEM_OFFSET)); REQUIRE(IMPLICATION(___2889.___2064() && sizeof(___2089) < sizeof(___2889), ___2889.sectionOffset() <= MAX_SECTION_OFFSET && ___2889.___4259() <= MAX_UNIFORM_OFFSET)); m.baseAddress.___14   = ___2889.___14(); m.baseAddress.sectionOffset = ___2889.sectionOffset(); if (___2889.isSzlItem()) { m.szlItemAddress.___2978     = ___2889.___2978(); m.szlItemAddress.subzoneOffset = ___2889.subzoneOffset(); m.szlItemAddress.itemOffset    = ___2889.itemOffset(); } else { m.___4257.___2866 = ___2889.___4259(); } } template <> inline ___2089<int32_t>::___2089(___2089<int32_t> const&) = default; template <> inline ___2089<int64_t>::___2089(___2089<int64_t> const&) = default; template <typename ITEM_TYPE> inline ___2089<ITEM_TYPE>::___2089( ___2981     ___2978, SectionOffset_t sectionOffset, SubzoneOffset_t subzoneOffset, ItemOffset_t    itemOffset) { INVARIANT(___4307()); REQUIRE(SIZE_IN_BITS(ITEM_TYPE) == 64u); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2978)); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(subzoneOffset)); REQUIRE(VALID_ITEM_ADDRESS_ITEM_OFFSET(itemOffset)); m.baseAddress.___14   = SzlAddressType; m.baseAddress.sectionOffset = sectionOffset; m.szlItemAddress.___2978     = ___2978; m.szlItemAddress.subzoneOffset = subzoneOffset; m.szlItemAddress.itemOffset    = itemOffset; } template <typename ITEM_TYPE> inline ___2089<ITEM_TYPE>::___2089( SubzoneAddress subzoneAddress, ItemOffset_t   itemOffset) { INVARIANT(___4307()); REQUIRE(SIZE_IN_BITS(ITEM_TYPE) == 64u); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(subzoneAddress));
REQUIRE(VALID_ITEM_ADDRESS_ITEM_OFFSET(itemOffset)); m.baseAddress.___14   = SzlAddressType; m.baseAddress.sectionOffset = subzoneAddress.sectionOffset(); m.szlItemAddress.___2978     = subzoneAddress.___2978(); m.szlItemAddress.subzoneOffset = subzoneAddress.subzoneOffset(); m.szlItemAddress.itemOffset    = itemOffset; } template <typename ITEM_TYPE> inline ___2089<ITEM_TYPE>::___2089(___4262 ___4259) { INVARIANT(___4307()); REQUIRE(SIZE_IN_BITS(ITEM_TYPE) == 32u || SIZE_IN_BITS(ITEM_TYPE) == 64u); m.baseAddress.___14   = UniformAddressType; m.baseAddress.sectionOffset = 0u; m.___4257.___2866 = ___4259; } template <typename ITEM_TYPE> inline ___2089<ITEM_TYPE>::___2089( SectionOffset_t sectionOffset, ___4262 ___4259) { INVARIANT(___4307()); REQUIRE(SIZE_IN_BITS(ITEM_TYPE) == 32u || SIZE_IN_BITS(ITEM_TYPE) == 64u); m.baseAddress.___14   = UniformAddressType; m.baseAddress.sectionOffset = sectionOffset; m.___4257.___2866 = ___4259; } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::___2064() const { ENSURE(m.baseAddress.___14 == SzlAddressType || m.baseAddress.___14 == UniformAddressType); return m.baseAddress.___14 == UniformAddressType; } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::isSzlItem() const { ENSURE(m.baseAddress.___14 == SzlAddressType || m.baseAddress.___14 == UniformAddressType); return m.baseAddress.___14 == SzlAddressType; } template <typename ITEM_TYPE> inline uint32_t ___2089<ITEM_TYPE>::___14() const { REQUIRE(isSzlItem() || ___2064()); return m.baseAddress.___14; } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::SubzoneAddress ___2089<ITEM_TYPE>::subzoneAddress() const { REQUIRE(isSzlItem()); return SubzoneAddress( m.szlItemAddress.___2978, m.baseAddress.sectionOffset, m.szlItemAddress.subzoneOffset); } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::___2981 ___2089<ITEM_TYPE>::___2978() const { REQUIRE(isSzlItem()); ENSURE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2978)); return m.szlItemAddress.___2978; } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::SectionOffset_t ___2089<ITEM_TYPE>::sectionOffset() const { REQUIRE(isSzlItem() || ___2064()); ENSURE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); return m.baseAddress.sectionOffset; } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::SubzoneOffset_t ___2089<ITEM_TYPE>::subzoneOffset() const { REQUIRE(isSzlItem()); ENSURE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); return m.szlItemAddress.subzoneOffset; } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::ItemOffset_t ___2089<ITEM_TYPE>::itemOffset() const { REQUIRE(isSzlItem()); ENSURE(VALID_ITEM_ADDRESS_ITEM_OFFSET(m.szlItemAddress.itemOffset));
return m.szlItemAddress.itemOffset; } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::___4262 ___2089<ITEM_TYPE>::___4259() const { REQUIRE(___2064()); return m.___4257.___2866; } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::UNSIGNED_INTEGER ___2089<ITEM_TYPE>::toRawBits() const { return m.___3271; } template <typename ITEM_TYPE> inline typename tecplot::___2089<ITEM_TYPE> ___2089<ITEM_TYPE>::fromRawBits(___2089<ITEM_TYPE>::UNSIGNED_INTEGER ___3271) { ___2089<ITEM_TYPE> ___3359; ___3359.m.___3271 = ___3271; ENSURE(VALID_ITEM_ADDRESS(___3359)); return ___3359; } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::operator==(___2089 const& ___2889) const { REQUIRE(VALID_ITEM_ADDRESS(___2889));
 #if defined LINUX
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
return m.___3271 == ___2889.m.___3271;
 #if defined LINUX
 #pragma GCC diagnostic pop
 #endif
} template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::operator!=(___2089 const& ___2889) const { return !(*this == ___2889); } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::operator<(___2089 const& ___2889) const { REQUIRE(VALID_ITEM_ADDRESS(___2889)); uint32_t const thisType = ___14(); uint32_t const otherType = ___2889.___14(); if (thisType != otherType) { return thisType < otherType; } else if (thisType == tecplot::___2089<ITEM_TYPE>::UniformAddressType) { if (sectionOffset() == ___2889.sectionOffset()) return ___4259() < ___2889.___4259(); else return sectionOffset() < ___2889.sectionOffset(); } else if (___2978() == ___2889.___2978()) { if (sectionOffset() == ___2889.sectionOffset()) { if (subzoneOffset() == ___2889.subzoneOffset()) return itemOffset() < ___2889.itemOffset(); else return subzoneOffset() < ___2889.subzoneOffset(); } else { return sectionOffset() < ___2889.sectionOffset(); } } else { return ___2978() < ___2889.___2978(); } } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::operator<=(___2089 const& ___2889) const { return *this < ___2889 || *this == ___2889; } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::operator>(___2089 const& ___2889) const { return !(*this <= ___2889); } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::operator>=(___2089 const& ___2889) const { return !(*this < ___2889); }
 #if !defined NO_ASSERTS
template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::___4307() { return (SIZE_IN_BITS(___2981)     >= PartitionBitSize     && SIZE_IN_BITS(SectionOffset_t) >  SectionOffsetBitSize && SIZE_IN_BITS(SubzoneOffset_t) >= SubzoneOffsetBitSize && SIZE_IN_BITS(ItemOffset_t)    >  ItemOffsetBitSize    && SIZE_IN_BITS(___4262) >= ___4260 && ___15 + SectionOffsetBitSize + ___4260 == SIZE_IN_BITS(___2089) && ___15 + PartitionBitSize + SectionOffsetBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize == SIZE_IN_BITS(___2089)); }
 #endif
template <typename ITEM_TYPE> inline ___2089<ITEM_TYPE>::SubzoneAddress::SubzoneAddress() { INVARIANT(SIZE_IN_BITS(ITEM_TYPE) == 64u); } template <typename ITEM_TYPE> inline ___2089<ITEM_TYPE>::SubzoneAddress::SubzoneAddress( ___2981     ___2978, SectionOffset_t sectionOffset, SubzoneOffset_t subzoneOffset) { INVARIANT(SIZE_IN_BITS(ITEM_TYPE) == 64u); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2978) || ___2978 == ___2089<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(subzoneOffset)); m.baseAddress.___14   = SzlAddressType; m.baseAddress.sectionOffset = sectionOffset; m.szlItemAddress.___2978     = ___2978; m.szlItemAddress.subzoneOffset = subzoneOffset; m.szlItemAddress.itemOffset    = 0u; } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::___2981 ___2089<ITEM_TYPE>::SubzoneAddress::___2978() const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2978) || m.szlItemAddress.___2978 == ___2089<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); return m.szlItemAddress.___2978; } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::SectionOffset_t ___2089<ITEM_TYPE>::SubzoneAddress::sectionOffset() const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2978) || m.szlItemAddress.___2978 == ___2089<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); return m.baseAddress.sectionOffset; } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::SubzoneOffset_t ___2089<ITEM_TYPE>::SubzoneAddress::subzoneOffset() const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2978) || m.szlItemAddress.___2978 == ___2089<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); return m.szlItemAddress.subzoneOffset; } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::SubzoneAddress::operator==(SubzoneAddress const& ___2889) const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2978) || m.szlItemAddress.___2978 == ___2089<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset));
 #if defined LINUX
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
return m.___3271 == ___2889.m.___3271;
 #if defined LINUX
 #pragma GCC diagnostic pop
 #endif
} template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::SubzoneAddress::operator!=(SubzoneAddress const& ___2889) const { return !(*this == ___2889); } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::SubzoneAddress::operator<(SubzoneAddress const& ___2889) const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2978) || m.szlItemAddress.___2978 == ___2089<ITEM_TYPE>::INVALID_PARTITION); REQUIRE(VALID_ITEM_ADDRESS_SECTION_OFFSET(m.baseAddress.sectionOffset)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); if (___2978() == ___2889.___2978()) { if (sectionOffset() == ___2889.sectionOffset()) return subzoneOffset() < ___2889.subzoneOffset(); else return sectionOffset() < ___2889.sectionOffset(); } else { return ___2978() < ___2889.___2978(); } } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::SubzoneAddress::operator<=(SubzoneAddress const& ___2889) const { return *this < ___2889 || *this == ___2889; } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::SubzoneAddress::operator>(SubzoneAddress const& ___2889) const { return !(*this <= ___2889); } template <typename ITEM_TYPE> inline bool ___2089<ITEM_TYPE>::SubzoneAddress::operator>=(SubzoneAddress const& ___2889) const { return !(*this < ___2889); } template <typename ITEM_TYPE> inline typename ___2089<ITEM_TYPE>::UNSIGNED_INTEGER ___2089<ITEM_TYPE>::SubzoneAddress::toRawBits() const { return m.___3271; } template <typename ITEM_TYPE> inline typename tecplot::___2089<ITEM_TYPE>::SubzoneAddress ___2089<ITEM_TYPE>::SubzoneAddress::fromRawBits(___2089<ITEM_TYPE>::UNSIGNED_INTEGER ___3271) { ___2089<ITEM_TYPE>::SubzoneAddress ___3359; ___3359.m.___3271 = ___3271; ENSURE(VALID_ITEM_ADDRESS_PARTITION(___3359.m.szlItemAddress.___2978) || ___3359.m.szlItemAddress.___2978 == ___2089<ITEM_TYPE>::INVALID_PARTITION); ENSURE(VALID_ITEM_ADDRESS_SECTION_OFFSET(___3359.m.baseAddress.sectionOffset)); ENSURE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(___3359.m.szlItemAddress.subzoneOffset)); return ___3359; } }
