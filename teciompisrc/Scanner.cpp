#include <stdlib.h>
#include <string.h>
#include "CodeContract.h"
#include "Scanner.h"
using std::string;
 #if defined MSWIN
 #define STRTOLL _strtoi64
 #else
 #define STRTOLL strtoll
 #endif
namespace tecplot { string const ___3442::noDelimiters(""); string const ___3442::whitespaceDelimiters(" \t\n\r"); string const ___3442::newlineDelimiters("\n\r"); void ___3442::___1931( string const& source, string const& delimiters) { m_sourceStr         = source; m_sourcePos         = 0; m_defaultDelimiters = delimiters; } ___3442::___3442() { ___1931("", whitespaceDelimiters); } ___3442::___3442(const ___3442& ___2889) { m_sourceStr         = ___2889.m_sourceStr; m_sourcePos         = ___2889.m_sourcePos; m_defaultDelimiters = ___2889.m_defaultDelimiters; m_savedPositions    = ___2889.m_savedPositions; } ___3442::___3442(string const& source) { ___1931(source, whitespaceDelimiters); } ___3442::___3442( string const& source, char          delimiter) { string delimiterString; delimiterString += delimiter; ___1931(source, delimiterString); } ___3442::___3442( string const& source, string const& delimiters) { ___1931(source, delimiters); } ___3442::~___3442() { REQUIRE(m_savedPositions.empty()); } ___3442& ___3442::operator=(___3442 const& ___2889) { if (this != &___2889) { m_sourceStr         = ___2889.m_sourceStr; m_sourcePos         = ___2889.m_sourcePos; m_defaultDelimiters = ___2889.m_defaultDelimiters; m_savedPositions    = ___2889.m_savedPositions; } return *this; } void ___3442::append(string const& source) { m_sourceStr.append(source); } void ___3442::reset() { REQUIRE(m_savedPositions.empty()); m_sourcePos = 0; } void ___3442::reset(string const& source) { REQUIRE(m_savedPositions.empty()); ___1931(source, m_defaultDelimiters); } void ___3442::reset( string const& source, string const& delimiters) { REQUIRE(m_savedPositions.empty()); ___1931(source, delimiters); } string const& ___3442::source() const { return m_sourceStr; } string::size_type ___3442::position() const { return m_sourcePos; } void ___3442::savePosition() { m_savedPositions.push(m_sourcePos); ENSURE(!m_savedPositions.empty()); } void ___3442::forgetPosition() { REQUIRE(!m_savedPositions.empty()); m_savedPositions.pop(); } void ___3442::eraseToPosition() { REQUIRE(!m_savedPositions.empty()); string::size_type lastPos = m_sourcePos; restorePosition(); m_sourceStr.erase(m_sourcePos, lastPos - m_sourcePos); } void ___3442::restorePosition() { REQUIRE(!m_savedPositions.empty()); m_sourcePos = m_savedPositions.top(); m_savedPositions.pop(); } static inline size_t getTokenStart( char const* cSourceStr, size_t      sourcePos, char const* cDelimiters) { REQUIRE(VALID_REF(cSourceStr)); REQUIRE("0 <= sourcePos" && sourcePos <= strlen(cSourceStr)); REQUIRE(VALID_REF(cDelimiters)); size_t ___3359 = (sourcePos + strspn(&cSourceStr[sourcePos], cDelimiters)); return ___3359; } static inline size_t getTokenLength( char const* cSourceStr, size_t      tokenStart, char const* cDelimiters) { REQUIRE(VALID_REF(cSourceStr)); REQUIRE("0 <= tokenStart" && tokenStart <= strlen(cSourceStr)); REQUIRE(VALID_REF(cDelimiters)); size_t ___3359; if (strlen(cDelimiters) != 0) ___3359 = strcspn(&cSourceStr[tokenStart], cDelimiters); else if (cSourceStr[tokenStart] != '\0')
___3359 = 1; else ___3359 = 0; return ___3359; } bool ___3442::hasNextToken() const { bool ___3359 = hasNextToken(m_defaultDelimiters); return ___3359; } bool ___3442::hasNextToken(char customDelimiter) const { string customDelimiterString; customDelimiterString += customDelimiter; bool ___3359 = hasNextToken(customDelimiterString); return ___3359; } bool ___3442::hasNextToken(string const& customDelimiters) const { char const* cSourceStr = m_sourceStr.c_str(); char const* cCustomDelimiters = customDelimiters.c_str(); size_t tokenStart = getTokenStart(cSourceStr, m_sourcePos, cCustomDelimiters); size_t tokenLength = getTokenLength(cSourceStr, tokenStart, cCustomDelimiters); bool ___3359 = (tokenLength != 0); return ___3359; } bool ___3442::hasNextInt64Token() const { bool ___3359 = hasNextInt64Token(m_defaultDelimiters); return ___3359; } bool ___3442::hasNextInt64Token(char customDelimiter) const { string customDelimiterString; customDelimiterString += customDelimiter; bool ___3359 = hasNextInt64Token(customDelimiterString); return ___3359; } bool ___3442::hasNextInt64Token(string const& customDelimiters) const { bool ___3359 = hasNextToken(customDelimiters); if (___3359) { char *endScan = NULL; string const tokenString = peekNextToken(customDelimiters); char const* cTokenString = tokenString.c_str(); int64_t strtoll_result = STRTOLL(cTokenString, &endScan, 10); (void)strtoll_result; ___3359 = (*endScan == '\0'); } return ___3359; } bool ___3442::hasNextDoubleToken() const { bool ___3359 = hasNextDoubleToken(m_defaultDelimiters); return ___3359; } bool ___3442::hasNextDoubleToken(char customDelimiter) const { string customDelimiterString; customDelimiterString += customDelimiter; bool ___3359 = hasNextDoubleToken(customDelimiterString); return ___3359; } bool ___3442::hasNextDoubleToken(string const& customDelimiters) const { bool ___3359 = hasNextToken(customDelimiters); if (___3359) { char *endScan = NULL; string const tokenString = peekNextToken(customDelimiters); char const* cTokenString = tokenString.c_str(); double strtod_result = strtod(cTokenString, &endScan); (void)strtod_result; ___3359 = (*endScan == '\0'); } return ___3359; } bool ___3442::hasNextTokenBeginningWith(string const& pattern) const { bool ___3359 = hasNextTokenBeginningWith(pattern, m_defaultDelimiters); return ___3359; } bool ___3442::hasNextTokenBeginningWith( string const& pattern, char          customDelimiter) const { string customDelimiterString; customDelimiterString += customDelimiter; bool ___3359 = hasNextTokenBeginningWith(pattern, customDelimiterString); return ___3359; } bool ___3442::hasNextTokenBeginningWith( string const& pattern, string const& customDelimiters) const { bool ___3359 = (hasNextToken() && peekNextToken(customDelimiters).find(pattern) == 0); return ___3359; } bool ___3442::hasNextTokenEndingWith(string const& pattern) const { bool ___3359 = hasNextTokenEndingWith(pattern, m_defaultDelimiters); return ___3359; } bool ___3442::hasNextTokenEndingWith( string const& pattern, char          customDelimiter) const
{ string customDelimiterString; customDelimiterString += customDelimiter; bool ___3359 = hasNextTokenEndingWith(pattern, customDelimiterString); return ___3359; } bool ___3442::hasNextTokenEndingWith( string const& pattern, string const& customDelimiters) const { bool ___3359 = false; if (hasNextToken(customDelimiters)) { string token = peekNextToken(customDelimiters); size_t tokenLength = token.length(); size_t ___2987 = pattern.length(); ___3359 = (tokenLength >= ___2987 && token.substr(tokenLength - ___2987).find(pattern) == 0); } return ___3359; } bool ___3442::hasNextTokenContaining(string const& pattern) const { bool ___3359 = hasNextTokenContaining(pattern, m_defaultDelimiters); return ___3359; } bool ___3442::hasNextTokenContaining( string const& pattern, char          customDelimiter) const { string customDelimiterString; customDelimiterString += customDelimiter; bool ___3359 = hasNextTokenContaining(pattern, customDelimiterString); return ___3359; } bool ___3442::hasNextTokenContaining( string const& pattern, string const& customDelimiters) const { bool ___3359 = (hasNextToken(customDelimiters) && peekNextToken(customDelimiters).find(pattern) != string::npos); return ___3359; } bool ___3442::hasNextChar() const { bool ___3359 = (m_sourcePos < m_sourceStr.length()); return ___3359; } bool ___3442::hasNextChar(char matchChar) const { REQUIRE(matchChar != '\0'); bool ___3359 = (hasNextChar() && peekNextChar() == matchChar); return ___3359; } bool ___3442::hasNext(string const& pattern) const { bool ___3359 = (m_sourceStr.find(pattern.c_str(), m_sourcePos, pattern.length()) == m_sourcePos); return ___3359; } bool ___3442::hasNextInt64() const { char const* cSourceStr = m_sourceStr.c_str(); char *endScan = NULL; int64_t strtoll_result = STRTOLL(&cSourceStr[m_sourcePos], &endScan, 10); (void)strtoll_result; size_t scanLength = (endScan - &cSourceStr[m_sourcePos]); bool ___3359 = (scanLength != 0); return ___3359; } bool ___3442::hasNextDouble() const { char const* cSourceStr = m_sourceStr.c_str(); char *endScan = NULL; double strtod_result = strtod(&cSourceStr[m_sourcePos], &endScan); (void)strtod_result; size_t scanLength = (endScan - &cSourceStr[m_sourcePos]); bool ___3359 = (scanLength != 0); return ___3359; } bool ___3442::hasNextLine() const { char const* cSourceStr = m_sourceStr.c_str(); char const* cNewLineDelimiters = newlineDelimiters.c_str(); size_t lineLength = getTokenLength(cSourceStr, m_sourcePos, cNewLineDelimiters); bool ___3359 = (cSourceStr[m_sourcePos+lineLength] != '\0'); return ___3359; } string ___3442::nextToken() { REQUIRE(hasNextToken(m_defaultDelimiters)); return nextToken(m_defaultDelimiters); } string ___3442::nextToken(char customDelimiter) { REQUIRE(hasNextToken(customDelimiter)); string customDelimiterString; customDelimiterString += customDelimiter; return nextToken(customDelimiterString); } string ___3442::nextToken(string const& customDelimiters) { REQUIRE(hasNextToken(customDelimiters)); char const* cSourceStr = m_sourceStr.c_str();
char const* cCustomDelimiters = customDelimiters.c_str(); size_t tokenStart = getTokenStart(cSourceStr, m_sourcePos, cCustomDelimiters); size_t tokenLength = getTokenLength(cSourceStr, tokenStart, cCustomDelimiters); string ___3359(&cSourceStr[tokenStart], tokenLength); m_sourcePos = (tokenStart + tokenLength); return ___3359; } string ___3442::peekNextToken() const { REQUIRE(hasNextToken(m_defaultDelimiters)); return peekNextToken(m_defaultDelimiters); } string ___3442::peekNextToken(char customDelimiter) const { REQUIRE(hasNextToken(customDelimiter)); string customDelimiterString; customDelimiterString += customDelimiter; return peekNextToken(customDelimiterString); } string ___3442::peekNextToken(string const& customDelimiters) const { REQUIRE(hasNextToken(customDelimiters)); char const* cSourceStr = m_sourceStr.c_str(); char const* cCustomDelimiters = customDelimiters.c_str(); size_t tokenStart = getTokenStart(cSourceStr, m_sourcePos, cCustomDelimiters); size_t tokenLength = getTokenLength(cSourceStr, tokenStart, cCustomDelimiters); string ___3359(&cSourceStr[tokenStart], tokenLength); return ___3359; } int64_t ___3442::nextInt64Token() { REQUIRE(hasNextInt64Token(m_defaultDelimiters)); return nextInt64Token(m_defaultDelimiters); } int64_t ___3442::nextInt64Token(char customDelimiter) { REQUIRE(hasNextInt64Token(customDelimiter)); string customDelimiterString; customDelimiterString += customDelimiter; return nextInt64Token(customDelimiterString); } int64_t ___3442::nextInt64Token(string const& customDelimiters) { REQUIRE(hasNextInt64Token(customDelimiters)); int64_t ___3359 = STRTOLL(nextToken(customDelimiters).c_str(), NULL, 10); return ___3359; } double ___3442::nextDoubleToken() { REQUIRE(hasNextDoubleToken(m_defaultDelimiters)); return nextDoubleToken(m_defaultDelimiters); } double ___3442::nextDoubleToken(char customDelimiter) { REQUIRE(hasNextDoubleToken(customDelimiter)); string customDelimiterString; customDelimiterString += customDelimiter; return nextDoubleToken(customDelimiterString); } double ___3442::nextDoubleToken(string const& customDelimiters) { REQUIRE(hasNextDoubleToken(customDelimiters)); double ___3359 = strtod(nextToken(customDelimiters).c_str(), NULL); return ___3359; } void ___3442::skipWhitespace() { skipDelimiters(whitespaceDelimiters); } void ___3442::skipDelimiters() { skipDelimiters(m_defaultDelimiters); } void ___3442::skipDelimiters(char customDelimiter) { string customDelimiterString; customDelimiterString += customDelimiter; skipDelimiters(customDelimiterString); } void ___3442::skipDelimiters(string const& customDelimiters) { char const* cSourceStr = m_sourceStr.c_str(); char const* cCustomDelimiters = customDelimiters.c_str(); m_sourcePos = getTokenStart(cSourceStr, m_sourcePos, cCustomDelimiters); ENSURE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); } char ___3442::nextChar() { REQUIRE(hasNextChar()); return m_sourceStr[m_sourcePos++]; } char ___3442::peekNextChar() const { REQUIRE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length());
return hasNextChar() ? m_sourceStr[m_sourcePos] : '\0'; } string ___3442::peekNext(string::size_type numChars) const { REQUIRE(numChars == string::npos || numChars > 0); REQUIRE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); return m_sourceStr.substr(m_sourcePos, numChars); } string ___3442::next(string::size_type numChars) { REQUIRE(numChars == string::npos || numChars > 0); REQUIRE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); string ___3359 = m_sourceStr.substr(m_sourcePos, numChars); m_sourcePos += ___3359.length(); return ___3359; } string ___3442::remaining() { REQUIRE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); return next(string::npos); } string ___3442::peekRemaining() const { REQUIRE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); return peekNext(string::npos); } string::size_type ___3442::numCharsRemaining() const { REQUIRE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); return m_sourceStr.length() - m_sourcePos; } int64_t ___3442::nextInt64() { REQUIRE(hasNextInt64()); char const* cSourceStr = m_sourceStr.c_str(); char *endScan = NULL; int64_t ___3359 = STRTOLL(&cSourceStr[m_sourcePos], &endScan, 10); size_t scanLength = (endScan - &cSourceStr[m_sourcePos]); m_sourcePos += scanLength; ENSURE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); return ___3359; } double ___3442::nextDouble() { REQUIRE(hasNextDouble()); char const* cSourceStr = m_sourceStr.c_str(); char *endScan = NULL; double ___3359 = strtod(&cSourceStr[m_sourcePos], &endScan); size_t scanLength = (endScan - &cSourceStr[m_sourcePos]); m_sourcePos += scanLength; ENSURE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); return ___3359; } string ___3442::nextLine() { REQUIRE(hasNextLine()); char const* cSourceStr = m_sourceStr.c_str(); char const* cNewLineDelimiters = newlineDelimiters.c_str(); size_t lineLength = getTokenLength(cSourceStr, m_sourcePos, cNewLineDelimiters); string ___3359(&cSourceStr[m_sourcePos], lineLength); m_sourcePos += lineLength; if (hasNextChar()) { if (cSourceStr[m_sourcePos] == '\r' && cSourceStr[m_sourcePos+1] == '\n') m_sourcePos++; m_sourcePos++; } ENSURE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); return ___3359; } bool ___3442::findInLine(string const& pattern) { bool ___3359 = false; if (hasNextToken(newlineDelimiters)) { char const* cSourceStr = m_sourceStr.c_str(); char const* cNewLineDelimiters = newlineDelimiters.c_str(); size_t lineLength = getTokenLength(cSourceStr, m_sourcePos, cNewLineDelimiters); char const* cPattern = pattern.c_str(); char const* cTarget = (char const*)strstr(&cSourceStr[m_sourcePos], cPattern); ___3359 = (cTarget != NULL && ((cTarget - cSourceStr) - m_sourcePos) <= lineLength); if (___3359) m_sourcePos = (cTarget - cSourceStr) + pattern.length(); } ENSURE("0 <= m_sourcePos" && m_sourcePos <= m_sourceStr.length()); return ___3359; } bool ___3442::find(string const& pattern) { while (hasNextToken(newlineDelimiters)) { if (findInLine(pattern))
return true; if (hasNextLine()) nextLine(); else return false; } return false; } bool ___3442::skipTokens(size_t NumTokensToSkip) { bool CanSkip = true; for (size_t i = 1; i <= NumTokensToSkip && CanSkip; i++) { if (hasNextToken()) nextToken(); else CanSkip = false; } return CanSkip; } }
