#include "ZoneVarMetadata.h"
#include "ThirdPartyHeadersBegin.h"
#include <cctype>
#include <new>
#include <sstream>
#include <boost/assign.hpp>
#include <boost/static_assert.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "AltTecUtil.h"
#include "fileStuff.h"
#include "ItemSetIterator.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3934 { namespace { ___4636 varGetPrevSharedZone( ___4636           zone, ___4636           ___341, ___4352            ___4336, ___37&           ___36, ___4635 const& zoneShareConnectivityWithZone) { ___4636 prevSharedZone = ___36.___912(NULL, zone + 1, ___4336 + 1) - 1; if (prevSharedZone != NOT_SHARED) { if (___36.___4620(zone + 1) == ___4704) {
 #if !defined TECIOMPI 
if (___36.___4620((___4636)prevSharedZone + 1) == ___4704) { ___1843 ___4632; ___1843 sharedZoneIJK; ___36.___4615((___4636)(zone + 1), ___4632); ___36.___4615((___4636)(prevSharedZone + 1), sharedZoneIJK); if (___4632 != sharedZoneIJK) prevSharedZone = NOT_SHARED; }
 #endif
} else if (zoneShareConnectivityWithZone[zone - ___341] == NOT_SHARED) { prevSharedZone = NOT_SHARED; } } return prevSharedZone; } } ___4707::___4707() {} ___4707::___4707( ___37&      ___36, ItemSetIterator& varIter, ItemSetIterator& zoneIter, bool             allowSharingBetweenFiles  ) { BOOST_STATIC_ASSERT(static_cast<size_t>(END_ValueLocation_e) <= uint8_t(-1)); BOOST_STATIC_ASSERT(static_cast<size_t>(END_FieldDataType_e) <= uint8_t(-1)); if (!___36.___894()) return; m_numVars = varIter.___2813(); m_numZones = zoneIter.___2813(); if (!m_zoneNames.alloc(m_numZones) || !m_zoneTypes.alloc(m_numZones) || !m_zoneDimension.alloc(m_numZones) || !m_zoneFaceNeighborModes.alloc(m_numZones) || !m_zoneSolutionTimes.alloc(m_numZones) || !m_zoneStrandIDs.alloc(m_numZones) || !m_zoneParentZones.alloc(m_numZones) || !m_zoneIMaxOrNumNodes.alloc(m_numZones) || !m_zoneJMaxOrNumCells.alloc(m_numZones) || !m_zoneKMaxOrNumCorners.alloc(m_numZones) || !m_zoneShareConnectivityWithZone.alloc(m_numZones) || !m_varNames.alloc(m_numVars) || !___3357(m_vzMinMaxes, m_numVars, m_numZones) || !___3357(m_vzValueLocations, m_numVars, m_numZones) || !___3357(m_vzFieldDataTypes, m_numVars, m_numZones) || !___3357(m_vzIsPassive, m_numVars, m_numZones) || !___3357(m_vzShareVarWithZone, m_numVars, m_numZones) || !m_zoneNumSections.alloc(m_numZones, 0) || !m_zoneNumElemsPerSec.alloc(m_numZones) || !m_zoneCellShapePerSec.alloc(m_numZones) || !m_zoneGridOrderPerSec.alloc(m_numZones) || !m_zoneCellBasisFuncPerSec.alloc(m_numZones)) { throw std::bad_alloc(); } std::map<ZoneType_e, char> zoneTypeMap = boost::assign::map_list_of<ZoneType_e, char> (___4704, ___4705) (___4702, ZONETYPE_FETRIANGLE_CHAR) (___4700, ZONETYPE_FEQUAD_CHAR) (___4701, ZONETYPE_FETETRA_CHAR) (___4695, ZONETYPE_FEBRICK_CHAR) (___4696, ZONETYPE_FELINESEG_CHAR) (___4698, ZONETYPE_FEPOLYGON_CHAR) (___4699, ZONETYPE_FEPOLYHEDRON_CHAR) (ZoneType_FEMixed, ZONETYPE_FEMIXED_CHAR); ___4265 const datasetID = ___36.datasetGetUniqueID(); zoneIter.reset(); ___4636 ___341 = zoneIter.baseItem(); while (zoneIter.hasNext()) { ___4636 const ___902 = zoneIter.next(); ___4636 const fileZone = ___902 - ___341; if (!___36.___4638(___902 + 1)) continue; char *zoneName = NULL; if (___36.___4616(___902 + 1, &zoneName)) { m_zoneNames[fileZone] = zoneName; ___36.___3818(&zoneName); } else { throw std::bad_alloc(); } m_zoneFaceNeighborModes[fileZone] = static_cast<uint8_t>(___36.___834(___902 + 1)); ___1843 ___4632; ___36.___4615(___902 + 1, ___4632); ZoneType_e const ___4692 = ___36.___4620(___902 + 1); m_zoneTypes[fileZone] = zoneTypeMap[___4692]; m_zoneDimension[fileZone] = ___36.zoneGetDimension( ___36.datasetGetUniqueID(), ___902 + 1);
if (___3896(___4692, m_zoneDimension[fileZone])) m_zoneTypes[fileZone] = static_cast<char>(std::toupper(m_zoneTypes[fileZone])); if (___4692 == ZoneType_FEMixed) { ___1170 numSections = 0; if (!___36.zoneGetNumSections(datasetID, ___902 + 1, &numSections)) throw std::runtime_error("failed to get zone section information"); m_zoneNumSections[fileZone] = checked_numeric_cast<uint8_t>(numSections); if (!m_zoneNumElemsPerSec[fileZone].alloc(numSections)  || !m_zoneCellShapePerSec[fileZone].alloc(numSections) || !m_zoneGridOrderPerSec[fileZone].alloc(numSections) || !m_zoneCellBasisFuncPerSec[fileZone].alloc(numSections)) { throw std::bad_alloc(); } for (___1170 section = 0; section < numSections; ++section) { FECellShape_e         cellShape = FECellShape_Invalid; ___1170            gridOrder = 0; FECellBasisFunction_e basisFn = FECellBasisFunction_Lagrangian; ___2226             numElements = 0; ___1170            numCornersPerElem = 0; ___1170            numNodesPerElem = 0; if (!___36.zoneGetSectionMetrics( datasetID, ___902+1, section+1, &cellShape, &gridOrder, &basisFn, &numElements, &numCornersPerElem, &numNodesPerElem)) { throw std::runtime_error("failed to get zone section information"); } m_zoneNumElemsPerSec[fileZone][section] = numElements; m_zoneCellShapePerSec[fileZone][section] = checked_numeric_cast<uint8_t>(cellShape); m_zoneGridOrderPerSec[fileZone][section] = checked_numeric_cast<uint8_t>(gridOrder); m_zoneCellBasisFuncPerSec[fileZone][section] = checked_numeric_cast<uint8_t>(basisFn); } } m_zoneSolutionTimes[fileZone] = ___36.___4618(___902 + 1); m_zoneStrandIDs[fileZone] = ___36.___4619(___902 + 1); ___4636 ___2975 = ___36.___4617(___902 + 1) - 1; ___476(___2975 == -1 || ___2975 >= ___341); m_zoneParentZones[fileZone] = ___2975 == -1 ? ___2975 : ___2975 - ___341; if (___4692 == ___4704) { m_zoneIMaxOrNumNodes[fileZone]   = ___4632.i(); m_zoneJMaxOrNumCells[fileZone]   = ___4632.___2104(); m_zoneKMaxOrNumCorners[fileZone] = ___4632.___2133(); } else { m_zoneIMaxOrNumNodes[fileZone] = ___4632.___1669(); m_zoneJMaxOrNumCells[fileZone] = ___4632.___1667(); if (___3159(___4692)) m_zoneKMaxOrNumCorners[fileZone] = ___4632.___2133(); else if (___4692 == ZoneType_FEMixed) m_zoneKMaxOrNumCorners[fileZone] = 0; else m_zoneKMaxOrNumCorners[fileZone] = ___4632.___1668(); } ___4636 const prevSharedZone = ___36.___542(NULL, ___902 + 1) - 1; if (prevSharedZone == NOT_SHARED) m_zoneShareConnectivityWithZone[fileZone] = NOT_SHARED; else if (prevSharedZone < ___341) m_zoneShareConnectivityWithZone[fileZone] = (allowSharingBetweenFiles ? prevSharedZone : NOT_SHARED); else if (m_zoneShareConnectivityWithZone[prevSharedZone - ___341] == NOT_SHARED) m_zoneShareConnectivityWithZone[fileZone] = prevSharedZone - ___341; else m_zoneShareConnectivityWithZone[fileZone] = m_zoneShareConnectivityWithZone[prevSharedZone - ___341];
___476(IMPLICATION(!allowSharingBetweenFiles, m_zoneShareConnectivityWithZone[fileZone] == NOT_SHARED || m_zoneShareConnectivityWithZone[m_zoneShareConnectivityWithZone[fileZone]] == NOT_SHARED)); } varIter.reset(); ___4352 const baseVar = varIter.baseItem(); while (varIter.hasNext()) { ___4352 const datasetVar = varIter.next(); ___4352 const fileVar = datasetVar - baseVar; char* ___4362 = NULL; if (___36.___4344(datasetVar+1, &___4362)) { m_varNames[fileVar] = ___4362; ___36.___3818(&___4362); } else { throw std::bad_alloc(); } } varIter.reset(); while (varIter.hasNext()) { ___4352 const datasetVar = varIter.next(); ___4352 const fileVar = datasetVar - baseVar; zoneIter.reset(); ___341 = zoneIter.baseItem(); while (zoneIter.hasNext()) { ___4636 const ___902 = zoneIter.next(); ___4636 const fileZone = ___902 - ___341; if (!___36.___4638(___902 + 1)) continue; ValueLocation_e ___4326 = ___36.___908(___902 + 1, datasetVar + 1); m_vzValueLocations[fileVar][fileZone] = static_cast<uint8_t>(___4326); FieldDataType_e ___1361 = ___36.___921(___902+1,datasetVar+1); m_vzFieldDataTypes[fileVar][fileZone] = static_cast<uint8_t>(___1361); ___372 varIsPassive = ___36.___924(___902 + 1, datasetVar + 1); m_vzIsPassive[fileVar][fileZone] = (varIsPassive ? 1 : 0); ___4636 const prevSharedZone = varGetPrevSharedZone( ___902, ___341, datasetVar, ___36, m_zoneShareConnectivityWithZone); if (prevSharedZone == NOT_SHARED) m_vzShareVarWithZone[fileVar][fileZone] = NOT_SHARED; else if (prevSharedZone < ___341) m_vzShareVarWithZone[fileVar][fileZone] = (allowSharingBetweenFiles ? prevSharedZone : NOT_SHARED); else if (m_vzShareVarWithZone[fileVar][prevSharedZone - ___341] == NOT_SHARED) m_vzShareVarWithZone[fileVar][fileZone] = prevSharedZone - ___341; else m_vzShareVarWithZone[fileVar][fileZone] = m_vzShareVarWithZone[fileVar][prevSharedZone - ___341]; if (prevSharedZone >= ___341) { m_vzMinMaxes[fileVar][fileZone] = m_vzMinMaxes[fileVar][prevSharedZone - ___341]; } else { double minValue; double maxValue; ___36.___911(___902 + 1, datasetVar + 1, &minValue, &maxValue); m_vzMinMaxes[fileVar][fileZone] = ___2480(minValue, maxValue); }
 #if !defined TECIOMPI 
___476(IMPLICATION(!allowSharingBetweenFiles, m_vzShareVarWithZone[fileVar][fileZone] == NOT_SHARED || m_vzShareVarWithZone[fileVar][m_vzShareVarWithZone[fileVar][fileZone]] == NOT_SHARED));
 #endif
} } } bool ___4707::alloc(size_t ___2847, size_t ___2844, std::vector<uint8_t> const& zoneNumSections) { REQUIRE(___2847 > 0); REQUIRE(___2844 > 0); m_numZones = ___2847; m_numVars = ___2844; bool ___3359 = m_zoneNames.alloc(___2847) && m_zoneTypes.alloc(___2847) && m_zoneDimension.alloc(m_numZones) && m_zoneFaceNeighborModes.alloc(___2847) && m_zoneSolutionTimes.alloc(___2847) && m_zoneStrandIDs.alloc(___2847) && m_zoneParentZones.alloc(___2847) && m_zoneIMaxOrNumNodes.alloc(___2847) && m_zoneJMaxOrNumCells.alloc(___2847) && m_zoneKMaxOrNumCorners.alloc(___2847) && m_zoneShareConnectivityWithZone.alloc(___2847) && m_varNames.alloc(___2844) && m_vzMinMaxes.alloc(___2844) && m_vzValueLocations.alloc(___2844) && m_vzFieldDataTypes.alloc(___2844) && m_vzIsPassive.alloc(___2844) && m_vzShareVarWithZone.alloc(___2844) && m_zoneNumSections.alloc(m_numZones) && m_zoneNumElemsPerSec.alloc(m_numZones) && m_zoneCellShapePerSec.alloc(m_numZones) && m_zoneGridOrderPerSec.alloc(m_numZones) && m_zoneCellBasisFuncPerSec.alloc(m_numZones); for (size_t ___4336 = 0; ___3359 && ___4336 < ___2844; ++___4336) { ___3359 = m_vzMinMaxes[___4336].alloc(___2847) && m_vzValueLocations[___4336].alloc(___2847) && m_vzFieldDataTypes[___4336].alloc(___2847) && m_vzIsPassive[___4336].alloc(___2847) && m_vzShareVarWithZone[___4336].alloc(___2847); } for (size_t zone = 0; ___3359 && zone < ___2847; ++zone) { m_zoneNumElemsPerSec[zone].alloc(zoneNumSections[zone]); m_zoneCellShapePerSec[zone].alloc(zoneNumSections[zone]); m_zoneGridOrderPerSec[zone].alloc(zoneNumSections[zone]); m_zoneCellBasisFuncPerSec[zone].alloc(zoneNumSections[zone]); } return ___3359; } bool ___4707::assign(___4707 const& ___2889, size_t zoneOffset) { REQUIRE(___2889.m_numZones + zoneOffset <= m_numZones); REQUIRE(___2889.m_numVars == m_numVars); try { for (size_t ___4336 = 0; ___4336 < ___2889.m_numVars; ++___4336) m_varNames[___4336] = ___2889.m_varNames[___4336]; for (size_t zone = 0; zone < ___2889.m_numZones; ++zone) { m_zoneNames                    [zoneOffset + zone] = ___2889.m_zoneNames[zone]; m_zoneTypes                    [zoneOffset + zone] = ___2889.m_zoneTypes[zone]; m_zoneDimension                [zoneOffset + zone] = ___2889.m_zoneDimension[zone]; m_zoneFaceNeighborModes        [zoneOffset + zone] = ___2889.m_zoneFaceNeighborModes[zone]; m_zoneSolutionTimes            [zoneOffset + zone] = ___2889.m_zoneSolutionTimes[zone]; m_zoneStrandIDs                [zoneOffset + zone] = ___2889.m_zoneStrandIDs[zone]; m_zoneParentZones              [zoneOffset + zone] = ___2889.m_zoneParentZones[zone]; m_zoneIMaxOrNumNodes           [zoneOffset + zone] = ___2889.m_zoneIMaxOrNumNodes[zone]; m_zoneJMaxOrNumCells           [zoneOffset + zone] = ___2889.m_zoneJMaxOrNumCells[zone]; m_zoneKMaxOrNumCorners         [zoneOffset + zone] = ___2889.m_zoneKMaxOrNumCorners[zone]; m_zoneShareConnectivityWithZone[zoneOffset + zone] = ___2889.m_zoneShareConnectivityWithZone[zone]; m_zoneNumSections              [zoneOffset + zone] = ___2889.m_zoneNumSections[zone]; for (size_t ___4336 = 0; ___4336 < ___2889.m_numVars; ++___4336)
{ m_vzMinMaxes        [___4336][zoneOffset + zone] = ___2889.m_vzMinMaxes[___4336][zone]; m_vzValueLocations  [___4336][zoneOffset + zone] = ___2889.m_vzValueLocations[___4336][zone]; m_vzFieldDataTypes  [___4336][zoneOffset + zone] = ___2889.m_vzFieldDataTypes[___4336][zone]; m_vzIsPassive       [___4336][zoneOffset + zone] = ___2889.m_vzIsPassive[___4336][zone]; m_vzShareVarWithZone[___4336][zoneOffset + zone] = ___2889.m_vzShareVarWithZone[___4336][zone]; } ___476(m_zoneNumElemsPerSec[zoneOffset + zone].size() == ___2889.m_zoneNumSections[zone]); ___476(m_zoneCellShapePerSec[zoneOffset + zone].size() == ___2889.m_zoneNumSections[zone]); ___476(m_zoneGridOrderPerSec[zoneOffset + zone].size() == ___2889.m_zoneNumSections[zone]); ___476(m_zoneCellBasisFuncPerSec[zoneOffset + zone].size() == ___2889.m_zoneNumSections[zone]); for (uint8_t section = 0; section < ___2889.m_zoneNumSections[zone]; ++section) { m_zoneNumElemsPerSec     [zoneOffset + zone][section] = ___2889.m_zoneNumElemsPerSec[zone][section]; m_zoneCellShapePerSec    [zoneOffset + zone][section] = ___2889.m_zoneCellShapePerSec[zone][section]; m_zoneGridOrderPerSec    [zoneOffset + zone][section] = ___2889.m_zoneGridOrderPerSec[zone][section]; m_zoneCellBasisFuncPerSec[zoneOffset + zone][section] = ___2889.m_zoneCellBasisFuncPerSec[zone][section]; } } } catch (std::bad_alloc const&) { return false; } return true; } }}
