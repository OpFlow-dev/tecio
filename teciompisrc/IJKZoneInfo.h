 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <vector>
#include <boost/unordered_map.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "IJKSubzoneInfo.h"
#include "MinMax.h"
namespace tecplot { namespace ___3934 { class ___1880 { public: typedef boost::unordered_map<ItemAddress64::SubzoneOffset_t, std::vector<___2480> > NszMinMaxMap; static const ___1843 ijkCornerOffset[NUM_IJK_CELL_CORNERS]; static const ___1843 ijkFaceNeighborOffset[NUM_IJK_CELL_FACES]; private: IJKSubzoneInfo m_cszInfo; IJKSubzoneInfo m_nszInfo;
 #if !defined NO_ASSERTS
ItemAddress64::___2981 m_partition;
 #endif
bool m_includeIMaxNodesInSubzones; bool m_includeJMaxNodesInSubzones; bool m_includeKMaxNodesInSubzones; NszMinMaxMap m_nszMinMaxes; mutable std::vector<ItemAddress64::SubzoneOffset_t> m_subzoneOffsetsAtNodeIndices; public: ___1880( ___1843 const& ___2715, ___1843 const& subzoneMaxIJKDim, ItemAddress64::___2981 ___2978 = ItemAddress64::UNKNOWN_PARTITION, bool minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES, bool includeIMaxNodesInSubzones = true, bool includeJMaxNodesInSubzones = true, bool includeKMaxNodesInSubzones = true) : m_cszInfo( ___2715.getCellIJK(), subzoneMaxIJKDim, ___2978, minimizeNumSubzones ) , m_nszInfo(___1843(includeIMaxNodesInSubzones ? ___2715.i() : ___2715.i() - 1, includeJMaxNodesInSubzones ? ___2715.___2104() : ___2715.___2104() - 1, includeKMaxNodesInSubzones ? ___2715.___2133() : ___2715.___2133() - 1), subzoneMaxIJKDim, ___2978, minimizeNumSubzones)
 #if !defined NO_ASSERTS
, m_partition(___2978)
 #endif
, m_includeIMaxNodesInSubzones(includeIMaxNodesInSubzones) , m_includeJMaxNodesInSubzones(includeJMaxNodesInSubzones) , m_includeKMaxNodesInSubzones(includeKMaxNodesInSubzones) { ___4279(___2978); REQUIRE(___2715>0); REQUIRE(subzoneMaxIJKDim>0); ItemAddress64::SubzoneOffset_t initialValue = ItemAddress64::INVALID_SUBZONE_OFFSET; m_subzoneOffsetsAtNodeIndices.resize(___1767(), initialValue); } ___1880() {} ___1880( ItemAddress64::___2981 ___2978, IJKSubzoneInfo const& nodeSubzoneInfo, IJKSubzoneInfo const& cellSubzoneInfo) : m_cszInfo(cellSubzoneInfo) , m_nszInfo(nodeSubzoneInfo)
 #if !defined NO_ASSERTS
, m_partition(___2978)
 #endif
, m_includeIMaxNodesInSubzones(true) , m_includeJMaxNodesInSubzones(true) , m_includeKMaxNodesInSubzones(true) { ___4279(___2978); } ~___1880() {} inline void swap(___1880& ___2889) { using std::swap; swap(m_cszInfo, ___2889.m_cszInfo); swap(m_nszInfo, ___2889.m_nszInfo);
 #if !defined NO_ASSERTS
swap(m_partition, ___2889.m_partition);
 #endif
swap(m_includeIMaxNodesInSubzones, ___2889.m_includeIMaxNodesInSubzones); swap(m_includeJMaxNodesInSubzones, ___2889.m_includeJMaxNodesInSubzones); swap(m_includeKMaxNodesInSubzones, ___2889.m_includeKMaxNodesInSubzones); swap(m_nszMinMaxes, ___2889.m_nszMinMaxes); swap(m_subzoneOffsetsAtNodeIndices, ___2889.m_subzoneOffsetsAtNodeIndices); } inline void reset( ___1843 const& ___2715, ___1843 const& subzoneMaxIJKDim, bool minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES, bool includeIMaxNodesInSubzones = true, bool includeJMaxNodesInSubzones = true, bool includeKMaxNodesInSubzones = true) { REQUIRE(___2715>0); REQUIRE(subzoneMaxIJKDim>0); m_cszInfo.reset( ___2715.getCellIJK(), subzoneMaxIJKDim, minimizeNumSubzones ); m_nszInfo.reset( ___2715, subzoneMaxIJKDim, minimizeNumSubzones ); m_includeIMaxNodesInSubzones = includeIMaxNodesInSubzones; m_includeJMaxNodesInSubzones = includeJMaxNodesInSubzones; m_includeKMaxNodesInSubzones = includeKMaxNodesInSubzones; } inline bool ___2066() const { return m_cszInfo.___2066() && m_nszInfo.___2066(); } inline bool validCszAddress(ItemAddress64::SubzoneAddress const& cszAddress) const { return m_cszInfo.validSzAddress(cszAddress); } inline bool validNszAddress(ItemAddress64::SubzoneAddress const& nszAddress) const { return m_nszInfo.validSzAddress(nszAddress); } inline bool validCellSubzone(ItemAddress64::SubzoneOffset_t ___467) const { return m_cszInfo.validSubzone(___467); } inline bool validNodeSubzone(ItemAddress64::SubzoneOffset_t ___2735) const { return m_nszInfo.validSubzone(___2735); } inline bool validCellAddress(ItemAddress64 const& ___449) const { return validCszAddress(___449.subzoneAddress()) && ___449.itemOffset() < getNumCellsInCsz(___449.subzoneOffset()); } inline bool validNodeAddress(ItemAddress64 const& nodeAddress) const { return validNszAddress(nodeAddress.subzoneAddress()) && nodeAddress.itemOffset() < getNumNodesInNsz(nodeAddress.subzoneOffset()); } bool includeIMaxNodesInSubzones() const { return m_includeIMaxNodesInSubzones; } bool includeJMaxNodesInSubzones() const { return m_includeJMaxNodesInSubzones; } bool includeKMaxNodesInSubzones() const { return m_includeKMaxNodesInSubzones; } inline ___463 ___1765(void) const { return ___463(m_cszInfo.getNumItems()); } inline ___2719 ___1767(void) const { return ___2719(m_nszInfo.getNumItems()); } inline ___1843 const ___2896() const { return ___1843(m_cszInfo.ijkDim().i() + 1, m_cszInfo.ijkDim().___2104() + 1, m_cszInfo.ijkDim().___2133()); } inline ___1843 const& contiguousCellIJKDim() const { return m_cszInfo.ijkDim(); } inline ___1843 const& ___2715() const { return m_nszInfo.ijkDim(); } inline ___1843 const& ___2197() const { return m_cszInfo.ijkLastIndex(); } inline ___1843 const& ___2198() const { return m_nszInfo.ijkLastIndex(); } inline ___1843 ___688(ItemAddress64::SubzoneOffset_t ___467) const { REQUIRE(___467 < getNumCszs()); return m_cszInfo.subzoneIJKStart(___467); }
inline ___1843 ___687(ItemAddress64::SubzoneOffset_t ___467) const { REQUIRE(___467 < getNumCszs()); return m_cszInfo.subzoneIJKEnd(___467); } inline ___1843 ___2762(ItemAddress64::SubzoneOffset_t ___2735) const { REQUIRE(___2735 < getNumNszs()); return m_nszInfo.subzoneIJKStart(___2735); } inline ___1843 ___2761(ItemAddress64::SubzoneOffset_t ___2735) const { REQUIRE(___2735 < getNumNszs()); return m_nszInfo.subzoneIJKEnd(___2735); } inline void nszIJKStartAndEnd( ItemAddress64::SubzoneOffset_t ___2735, ___1843& ___1879, ___1843& ___1851) const { REQUIRE(___2735 < getNumNszs()); m_nszInfo.subzoneIJKStartAndEnd(___2735, ___1879, ___1851); } static ItemAddress64::SubzoneOffset_t calcNumCszs( ___1843 const& zoneIJKDim, ___1843 const& subzoneMaxIJK, bool minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(zoneIJKDim>0 && zoneIJKDim.getNumPaddedCells()<=MAX_NUM_CELLS); REQUIRE(subzoneMaxIJK>0 && subzoneMaxIJK.blockSize()<=ItemAddress64::MAX_ITEM_OFFSET+1); ItemAddress64::SubzoneOffset_t const ___2784 = IJKSubzoneInfo::calcNumSubzones(zoneIJKDim.getCellIJK(), subzoneMaxIJK, minimizeNumSubzones); ENSURE(___2784>0 && ___2784 <= zoneIJKDim.getNumContiguousCells()); return ___2784; } static ItemAddress64::SubzoneOffset_t calcNumNszs( ___1843 const& zoneIJKDim, ___1843 const& subzoneMaxIJK, bool minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(zoneIJKDim>0 && zoneIJKDim.blockSize()<=MAX_NUM_NODES); REQUIRE(subzoneMaxIJK>0 && subzoneMaxIJK.blockSize()<=ItemAddress64::MAX_ITEM_OFFSET+1); ItemAddress64::SubzoneOffset_t const ___2824 = IJKSubzoneInfo::calcNumSubzones(zoneIJKDim, subzoneMaxIJK, minimizeNumSubzones); ENSURE(___2824>0 && ___2824 <= zoneIJKDim.blockSize()); return ___2824; } inline ItemAddress64::SubzoneOffset_t getNumCszs(void) const { return m_cszInfo.getNumSzs(); } inline ItemAddress64::ItemOffset_t getNumCellsInCsz(ItemAddress64::SubzoneOffset_t ___467) const { REQUIRE(validCellSubzone(___467)); ItemAddress64::ItemOffset_t const ___2782 = m_cszInfo.numItemsInSz(___467); ENSURE(0 < ___2782 && ___2782 < ItemAddress64::MAX_ITEM_OFFSET+1); return ___2782; } inline ItemAddress64 cellAddressAtCellIJK(___1843 const& cellIJK) const { REQUIRE(cellIJK < m_cszInfo.ijkDim()); ItemAddress64 const ___449 = m_cszInfo.itemAddressAtItemIJK(cellIJK); ENSURE(validCellAddress(___449)); return ___449; } inline ___1843 cellIJKAtCellAddress(ItemAddress64 const& ___449) const { REQUIRE(validCellAddress(___449)); ___1843 const cellIJK = m_cszInfo.itemIJKAtItemAddress(___449); ENSURE(cellIJK < m_cszInfo.ijkDim()); return cellIJK; } inline ItemAddress64 cellAddressAtContiguousCellIndex(___463 contiguousCellIndex) const { REQUIRE(contiguousCellIndex < ___1765()); ItemAddress64 const ___449 = m_cszInfo.itemAddressAtItemIndex(contiguousCellIndex); ENSURE(validCellAddress(___449)); return ___449;
} inline ___463 contiguousCellIndexAtCellAddress(ItemAddress64 const& ___449) const { REQUIRE(validCellAddress(___449)); ___463 const contiguousCellIndex = m_cszInfo.itemIndexAtItemAddress(___449); ENSURE(contiguousCellIndex<___1765()); return contiguousCellIndex; } inline ___463 contiguousCellIndexAtCellIJK(___1843 const& cellIJK) const { ___463 const contiguousCellIndex = m_cszInfo.itemIndexAtItemIJK(cellIJK); ENSURE(contiguousCellIndex<___1765()); return contiguousCellIndex; } inline ___463 getMaxPaddedCellIndex() const { REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); return m_nszInfo.ijkDim().i() * m_nszInfo.ijkDim().___2104() * m_cszInfo.ijkDim().___2133(); } inline ItemAddress64 cellAddressAtPaddedCellIndex(___463 paddedCellIndex) const { REQUIRE(paddedCellIndex < getMaxPaddedCellIndex()); REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___1843 cellIJK = m_nszInfo.itemIJKAtItemIndex(paddedCellIndex); if ( cellIJK.i() == m_cszInfo.ijkDim().i() ) cellIJK.setI(m_cszInfo.ijkLastIndex().i()); if ( cellIJK.___2104() == m_cszInfo.ijkDim().___2104() ) cellIJK.setJ(m_cszInfo.ijkLastIndex().___2104()); REQUIRE(cellIJK<m_cszInfo.ijkDim()); ItemAddress64 const ___449 = m_cszInfo.itemAddressAtItemIJK(cellIJK); ENSURE(validCellAddress(___449)); return ___449; } inline ___463 paddedCellIndexAtCellAddress(ItemAddress64 const& ___449) const { REQUIRE(validCellAddress(___449)); ___1843 const cellIJK = m_cszInfo.itemIJKAtItemAddress(___449); ___463 const paddedCellIndex = paddedCellIndexAtCellIJK(cellIJK); ENSURE(paddedCellIndex < getMaxPaddedCellIndex()); return paddedCellIndex; } inline ___463 paddedCellIndexAtCellIJK(___1843 const& cellIJK) const { REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___463 const paddedCellIndex = m_nszInfo.itemIndexAtItemIJK(cellIJK); ENSURE(paddedCellIndex < getMaxPaddedCellIndex()); return paddedCellIndex; } inline ItemAddress64::SubzoneAddress cszAtCellIJK(___1843 const& cellIJK) const { REQUIRE(cellIJK < m_cszInfo.ijkDim()); ItemAddress64::SubzoneAddress const cszAddress = m_cszInfo.szAddressAtItemIJK(cellIJK); ENSURE(validCszAddress(cszAddress)); return cszAddress; } inline ItemAddress64::SubzoneOffset_t getNumNszs(void) const { return m_nszInfo.getNumSzs(); } inline ItemAddress64::ItemOffset_t getNumNodesInNsz(ItemAddress64::SubzoneOffset_t ___2735) const { REQUIRE(validNodeSubzone(___2735)); ItemAddress64::ItemOffset_t const ___2822 = m_nszInfo.numItemsInSz(___2735); ENSURE(0 < ___2822 && ___2822 < ItemAddress64::MAX_ITEM_OFFSET+1); return ___2822; } inline ItemAddress64 nodeAddressAtNodeIJK(___1843 const& nodeIJK) const { REQUIRE(nodeIJK < m_nszInfo.ijkDim()); ItemAddress64 const nodeAddress = m_nszInfo.itemAddressAtItemIJK(nodeIJK); ENSURE(validNodeAddress(nodeAddress)); return nodeAddress; }
inline ___1843 nodeIJKAtNodeAddress(ItemAddress64 const& nodeAddress) const { REQUIRE(validNodeAddress(nodeAddress)); ___1843 const nodeIJK = m_nszInfo.itemIJKAtItemAddress(nodeAddress); ENSURE(nodeIJK < m_nszInfo.ijkDim()); return nodeIJK; } inline ItemAddress64 nodeAddressAtNodeIndex(___2719 ___2717) const { REQUIRE(___2717 < ___1767()); ItemAddress64 const nodeAddress = m_nszInfo.itemAddressAtItemIndex(___2717); return nodeAddress; } inline ItemAddress64::SubzoneAddress nszAtNodeIJK(___1843 const& nodeIJK) const { REQUIRE(nodeIJK < m_nszInfo.ijkDim()); ItemAddress64::SubzoneAddress const nszAddress = m_nszInfo.szAddressAtItemIJK(nodeIJK); ENSURE(validNszAddress(nszAddress)); return nszAddress; } inline ItemAddress64::SubzoneOffset_t nodeSubzoneOffsetAtNodeIndex(___2719 ___2717) const { REQUIRE(___2717 < ___1767()); if (m_subzoneOffsetsAtNodeIndices[___2717] == ItemAddress64::INVALID_SUBZONE_OFFSET) m_subzoneOffsetsAtNodeIndices[___2717] = m_nszInfo.subzoneOffsetAtItemIndex(___2717); return m_subzoneOffsetsAtNodeIndices[___2717]; } inline ___2719 nodeIndexAtNodeAddress(ItemAddress64 const& nodeAddress) const { REQUIRE(validNodeAddress(nodeAddress)); ___2719 const ___2717 = m_nszInfo.itemIndexAtItemAddress(nodeAddress); ENSURE(___2717<___1767()); return ___2717; } inline ___2719 nodeIndexAtNodeIJK(___1843 const& nodeIJK) const { ___2719 const ___2717 = m_nszInfo.itemIndexAtItemIJK(nodeIJK); ENSURE(___2717<___1767()); return ___2717; } inline ItemAddress64 getCellCorner( ItemAddress64 const& ___449, CellNodeIndex_t      ___679) const { REQUIRE(validCellAddress(___449)); REQUIRE(___679 < NUM_IJK_CELL_CORNERS); ___1843 const zoneCellIJK = m_cszInfo.itemIJKAtItemAddress(___449); ___1843 const cornerIJK = zoneCellIJK + ijkCornerOffset[___679]; ___476(0 <= cornerIJK); ItemAddress64 cornerNodeAddress; if (cornerIJK < ___2715()) { cornerNodeAddress = nodeAddressAtNodeIJK(cornerIJK); ___476(validNodeAddress(cornerNodeAddress)); } else { cornerNodeAddress = ItemAddress64(BAD_ANY_INDEX); } return cornerNodeAddress; } inline void getCellCorners( ItemAddress64 const&     ___449, ___3270<ItemAddress64>& cornerNodeAddresses) const { REQUIRE(validCellAddress(___449)); REQUIRE(cornerNodeAddresses.empty()); cornerNodeAddresses.reserve(NUM_IJK_CELL_CORNERS); cornerNodeAddresses.___3504(NUM_IJK_CELL_CORNERS); ___1843 const zoneCellIJK = m_cszInfo.itemIJKAtItemAddress(___449); ___1843 const& nodeSzIJKDim = ___2715(); ___1843 const baseSzIJK = m_nszInfo.szIJKAtItemIJK(zoneCellIJK); ___1843 const baseIJKEnd = m_nszInfo.itemIJKEnd(baseSzIJK); for (CellNodeIndex_t ___679 = 0; ___679 < NUM_IJK_CELL_CORNERS; ++___679) { ___1843 const cornerIJK = zoneCellIJK + ijkCornerOffset[___679]; ___476(0 <= cornerIJK); if (cornerIJK < nodeSzIJKDim) { ___1843 const nszIJK(cornerIJK.i() > baseIJKEnd.i() ? baseSzIJK.i()+1 : baseSzIJK.i(), cornerIJK.___2104() > baseIJKEnd.___2104() ? baseSzIJK.___2104()+1 : baseSzIJK.___2104(), cornerIJK.___2133() > baseIJKEnd.___2133() ? baseSzIJK.___2133()+1 : baseSzIJK.___2133());
cornerNodeAddresses[___679] = m_nszInfo.itemAddressAtItemIJK(cornerIJK, nszIJK); ___476(validNodeAddress(cornerNodeAddresses[___679])); } else { cornerNodeAddresses[___679] = ItemAddress64(BAD_ANY_INDEX); } } } inline ___463 getNumIJKFaceNeighbors( ItemAddress64 const&  , FaceIndex_t          ASSERT_ONLY(___455)) const { REQUIRE(___455 < NUM_IJK_CELL_FACES); return 1; } inline void cszFaceNeighborIJKRange( ItemAddress64::SubzoneOffset_t ___467, int                            iDir, int                            jDir, int                            kDir, ItemAddress64::SubzoneAddress& fnCszAddress, ___1843&                           fnCszIJKRange) const { REQUIRE(validCellSubzone(___467)); REQUIRE(iDir == -1 || iDir == 0 || iDir == 1); REQUIRE(jDir == -1 || jDir == 0 || jDir == 1); REQUIRE(kDir == -1 || kDir == 0 || kDir == 1); REQUIRE((iDir != 0 && jDir == 0 && kDir == 0) || (iDir == 0 && jDir != 0 && kDir == 0) || (iDir == 0 && jDir == 0 && kDir != 0)); ___1843 const subzoneIJK = m_cszInfo.szIJKAtSzIndex(___467); fnCszAddress = m_cszInfo.szAddressAtSzIJK( ___1843(subzoneIJK.i()+iDir,subzoneIJK.___2104()+jDir,subzoneIJK.___2133()+kDir)); ___1843 const fnCszIJKStart = m_cszInfo.subzoneIJKStart(fnCszAddress.subzoneOffset()); ___1843 const fnCszIJKEnd = m_cszInfo.subzoneIJKEnd(fnCszAddress.subzoneOffset()); fnCszIJKRange = fnCszIJKEnd-fnCszIJKStart+1; } inline void getIJKFaceNeighbor( ItemAddress64 const& ___449, FaceIndex_t          ___455, ___463          ASSERT_ONLY(neighborOffset), ItemAddress64&       fnCoord, ___4636&         fnZone) const { REQUIRE(___455 < NUM_IJK_CELL_FACES); REQUIRE(neighborOffset < getNumIJKFaceNeighbors(___449, ___455)); ItemAddress64::SubzoneOffset_t const ___467 = ___449.subzoneOffset(); ItemAddress64::ItemOffset_t const ___2866 = ___449.itemOffset(); ___1843 const ijkLastIndex = m_cszInfo.ijkLastIndex(); ___1843 const ___1879 = m_cszInfo.subzoneIJKStart(___467); ___1843 const ___1851 = m_cszInfo.subzoneIJKEnd(___467); ___1843 const ijkRange = ___1851-___1879+1; ___1843 const ___1861 = ijkRange.ijkAtOffset(___2866); ___1843 const ijkCell = ___1879 + ___1861; ItemAddress64::SubzoneAddress fnCszAddress; ___1843 fnCszIJKRange; switch (___455) { case 0: if (ijkCell.i() > 0) { if (___1861.i() > 0) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell - ___1843(1,0,0)); } else { cszFaceNeighborIJKRange(___467, -1, 0, 0, fnCszAddress, fnCszIJKRange); ___1843 const fnCszIJKOffset(fnCszIJKRange.i()-1,___1861.___2104(),___1861.___2133()); fnCoord = ItemAddress64( fnCszAddress, static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2750); } break; case 1: if (ijkCell.i() < ijkLastIndex.i()) { if (___1861.i() < ijkRange.i()-1) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell + ___1843(1,0,0)); } else { cszFaceNeighborIJKRange(___467, 1,0,0, fnCszAddress, fnCszIJKRange); ___1843 const fnCszIJKOffset(0,___1861.___2104(),___1861.___2133()); fnCoord = ItemAddress64(
fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2750); } break; case 2: if (ijkCell.___2104() > 0) { if (___1861.___2104() > 0) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell - ___1843(0,1,0)); } else { cszFaceNeighborIJKRange(___467, 0, -1, 0, fnCszAddress, fnCszIJKRange); ___1843 const fnCszIJKOffset(___1861.i(),fnCszIJKRange.___2104()-1,___1861.___2133()); fnCoord = ItemAddress64( fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2750); } break; case 3: if (ijkCell.___2104() < ijkLastIndex.___2104()) { if (___1861.___2104() < ijkRange.___2104()-1) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell + ___1843(0,1,0)); } else { cszFaceNeighborIJKRange(___467, 0, 1, 0, fnCszAddress, fnCszIJKRange); ___1843 const fnCszIJKOffset(___1861.i(),0,___1861.___2133()); fnCoord = ItemAddress64( fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2750); } break; case 4: if (ijkCell.___2133() > 0) { if (___1861.___2133() > 0) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell - ___1843(0,0,1)); } else { cszFaceNeighborIJKRange(___467, 0, 0, -1, fnCszAddress, fnCszIJKRange); ___1843 const fnCszIJKOffset(___1861.i(),___1861.___2104(),fnCszIJKRange.___2133()-1); fnCoord = ItemAddress64( fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2750); } break; case 5: if (ijkCell.___2133() < ijkLastIndex.___2133()) { if (___1861.___2133() < ijkRange.___2133()-1) { fnCoord = m_cszInfo.itemAddressAtItemIJK(ijkCell + ___1843(0,0,1)); } else { cszFaceNeighborIJKRange(___467, 0, 0, 1, fnCszAddress, fnCszIJKRange); ___1843 const fnCszIJKOffset(___1861.i(),___1861.___2104(),0); fnCoord = ItemAddress64( fnCszAddress,static_cast<ItemAddress64::ItemOffset_t>(fnCszIJKRange.offsetAtIJK(fnCszIJKOffset))); } } else { fnCoord = ItemAddress64(___2750); } break; default: ___476(___1303); break; } fnZone = ___2751; } ___463 getCellsAroundNodeIJK( ___1843 const&               nodeIJK, ___3270<ItemAddress64>& adjacentCells) const; ___372 getCszsOnIndexPlane( IJKPlanes_e                              whichPlane, ___2719                              planeIndex, ___3270<ItemAddress64::SubzoneAddress>& cszAddresses) const { REQUIRE(whichPlane == ___1866 || whichPlane == ___1871 || whichPlane == ___1873); REQUIRE(IMPLICATION(whichPlane == ___1866 ,planeIndex < m_nszInfo.ijkDim().i()) && IMPLICATION(whichPlane == ___1871 ,planeIndex < m_nszInfo.ijkDim().___2104()) && IMPLICATION(whichPlane == ___1873 ,planeIndex < m_nszInfo.ijkDim().___2133())); REQUIRE(cszAddresses.empty()); ___372 const ___2038 = m_cszInfo.getSubzonesOnIndexPlane(whichPlane, planeIndex, cszAddresses); ENSURE(IMPLICATION(___2038, !cszAddresses.empty())); ENSURE(IMPLICATION(___2038, std::is_sorted(cszAddresses.begin(), cszAddresses.end())));
ENSURE(IMPLICATION(___2038, cszAddresses[cszAddresses.size()-1].___2978()==m_partition)); ENSURE(IMPLICATION(___2038, cszAddresses[cszAddresses.size()-1].subzoneOffset() < getNumCszs())); return ___2038; } ___372 getCszsOnIndexLine( IJKLines_e                               whichLine, ___2719                              mIndex, ___2719                              nIndex, ___3270<ItemAddress64::SubzoneAddress>& cszAddresses) const { REQUIRE(whichLine == ___1856 || whichLine == ___1858 || whichLine == ___1859); REQUIRE(IMPLICATION(whichLine == ___1856, mIndex < m_nszInfo.ijkDim().___2104() && nIndex < m_nszInfo.ijkDim().___2133()) && IMPLICATION(whichLine == ___1858, mIndex < m_nszInfo.ijkDim().i() && nIndex < m_nszInfo.ijkDim().___2133()) && IMPLICATION(whichLine == ___1859, mIndex < m_nszInfo.ijkDim().i() && nIndex < m_nszInfo.ijkDim().___2104())); REQUIRE(cszAddresses.empty()); REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___372 const ___2038 = m_cszInfo.getSubzonesOnIndexLine(whichLine, mIndex, nIndex, cszAddresses); ENSURE(IMPLICATION(___2038, !cszAddresses.empty())); ENSURE(IMPLICATION(___2038, std::is_sorted(cszAddresses.begin(), cszAddresses.end()))); ENSURE(IMPLICATION(___2038, cszAddresses[cszAddresses.size()-1].___2978()==m_partition)); ENSURE(IMPLICATION(___2038, cszAddresses[cszAddresses.size()-1].subzoneOffset() < getNumCszs())); return ___2038; } ___372 getNszsOnIndexPlane( IJKPlanes_e                              whichPlane, ___2719                              planeIndex, ___3270<ItemAddress64::SubzoneAddress>& nszAddresses) const { REQUIRE(whichPlane == ___1866 || whichPlane == ___1871 || whichPlane == ___1873); REQUIRE(IMPLICATION(whichPlane == ___1866, planeIndex < m_nszInfo.ijkDim().i()) && IMPLICATION(whichPlane == ___1871, planeIndex < m_nszInfo.ijkDim().___2104()) && IMPLICATION(whichPlane == ___1873, planeIndex < m_nszInfo.ijkDim().___2133())); REQUIRE(nszAddresses.empty()); REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___372 ___2038 = m_nszInfo.getSubzonesOnIndexPlane(whichPlane, planeIndex, nszAddresses); ENSURE(IMPLICATION(___2038, !nszAddresses.empty())); ENSURE(IMPLICATION(___2038, std::is_sorted(nszAddresses.begin(), nszAddresses.end()))); ENSURE(IMPLICATION(___2038, nszAddresses[nszAddresses.size()-1].___2978()==m_partition)); ENSURE(IMPLICATION(___2038, nszAddresses[nszAddresses.size()-1].subzoneOffset() < getNumNszs())); return ___2038; } ___372 getNszsOnIndexLine( IJKLines_e                               whichLine, ___2719                              mIndex, ___2719                              nIndex, ___3270<ItemAddress64::SubzoneAddress>& nszAddresses) const { REQUIRE(whichLine == ___1856 || whichLine == ___1858 || whichLine == ___1859); REQUIRE(IMPLICATION(whichLine == ___1856, mIndex < m_nszInfo.ijkDim().___2104() && nIndex < m_nszInfo.ijkDim().___2133()) && IMPLICATION(whichLine == ___1858, mIndex < m_nszInfo.ijkDim().i() && nIndex < m_nszInfo.ijkDim().___2133()) &&
IMPLICATION(whichLine == ___1859, mIndex < m_nszInfo.ijkDim().i() && nIndex < m_nszInfo.ijkDim().___2104())); REQUIRE(nszAddresses.empty()); REQUIRE(m_includeIMaxNodesInSubzones && m_includeJMaxNodesInSubzones && m_includeKMaxNodesInSubzones); ___372 const ___2038 = m_nszInfo.getSubzonesOnIndexLine(whichLine, mIndex, nIndex, nszAddresses); ENSURE(IMPLICATION(___2038, !nszAddresses.empty())); ENSURE(IMPLICATION(___2038, std::is_sorted(nszAddresses.begin(), nszAddresses.end()))); ENSURE(IMPLICATION(___2038, nszAddresses[nszAddresses.size()-1].___2978()==m_partition)); ENSURE(IMPLICATION(___2038, nszAddresses[nszAddresses.size()-1].subzoneOffset() < getNumNszs())); return ___2038; } void includeNszVarMinMax(ItemAddress64::SubzoneOffset_t ___2735, std::vector<___2480> const& varMinMaxes) { REQUIRE(!varMinMaxes.empty()); std::vector<___2480>& nszVarMinMaxes = m_nszMinMaxes[___2735]; if (nszVarMinMaxes.empty()) nszVarMinMaxes.resize(varMinMaxes.size()); for (size_t ___4336 = 0; ___4336 < varMinMaxes.size(); ++___4336) nszVarMinMaxes[___4336].include(varMinMaxes[___4336]); } NszMinMaxMap const& getNszMinMaxes() const { return m_nszMinMaxes; } inline void resetNeighborInfo() { m_nszMinMaxes.clear(); } ___372 getNodeSubzonesInRange( ___1843 const& nodeIJKStart, ___1843 const& nodeIJKEnd, ___3270<ItemAddress64::SubzoneAddress>& refNszAddresses) const; ___372 getCszReferencedNszs( ItemAddress64::SubzoneAddress const&     cszAddress, ___3270<ItemAddress64::SubzoneAddress>& refNszAddresses) const; ___372 getCellSubzonesInRange( ___1843 const& cellIJKStart, ___1843 const& cellIJKEnd, ___3270<ItemAddress64::SubzoneAddress>& refCszAddresses) const; ___372 getNszReferencedCszs( ItemAddress64::SubzoneAddress const&     nszAddress, ___3270<ItemAddress64::SubzoneAddress>& refCszAddresses) const; }; }}
