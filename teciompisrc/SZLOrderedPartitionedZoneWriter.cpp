#include "SZLOrderedPartitionedZoneWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <new>
#include <sstream>
#include <utility>
#include <vector>
#include <boost/assign.hpp>
#include <boost/make_shared.hpp>
#include <boost/ref.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData.h"
#include "ItemAddress.h"
#include "ItemSetIterator.h"
#include "SZLOrderedPartitionWriter.h"
#include "writeValueArray.h"
#include "ZoneInfoCache.h"
namespace tecplot { namespace ___3934 { SZLOrderedPartitionedZoneWriter::SZLOrderedPartitionedZoneWriter( uint32_t                      fileVersion, ItemSetIterator&              varIter, ___4636                   zone, ___4636                   ___341, std::vector<___372> const& ___4564, ___372                     ___4499, ___37&                   ___36, ZoneInfoCache&                zoneInfoCache) : ___4709(fileVersion, varIter, zone, ___341, ___4564, ___4499, ___36) , m_headerWriter( fileVersion, varIter, zone, ___341, ___36, m_partitionFileNums, m_partitionHeaderFilePositions, m_partitionMinNodeNumbers, m_partitionMaxNodeNumbers, m_varPartitionMinMaxes) , ___2681(zoneInfoCache) , m_partitionTecUtil(___36, zone + 1) { REQUIRE(0 <= zone && ___36.___4638(zone + 1)); REQUIRE(VALID_BOOLEAN(___4499)); REQUIRE(___36.zoneIsPartitioned(zone + 1)); size_t const numVarsToWrite = static_cast<size_t>(m_varIter.___2813()); size_t const numPartitions = static_cast<size_t>(___36.zoneGetNumPartitions(zone + 1)); if (!m_partitionFileNums.alloc(numPartitions, 0) || !m_partitionHeaderFilePositions.alloc(numPartitions, ___330) || !m_partitionMinNodeNumbers.alloc(numPartitions, 0) || !m_partitionMaxNodeNumbers.alloc(numPartitions, 0) || !___3357(m_varPartitionMinMaxes, numVarsToWrite, numPartitions)) throw std::bad_alloc(); } SZLOrderedPartitionedZoneWriter::~SZLOrderedPartitionedZoneWriter() {} void SZLOrderedPartitionedZoneWriter::getCellMinMaxes( std::vector<___2480>& cellMinMaxes, ___2226 ___460, ___1843 const& dimensions, std::vector<___1350> const& fieldDatas) { REQUIRE(cellMinMaxes.size() == fieldDatas.size()); for (size_t ___4336 = 0; ___4336 < fieldDatas.size(); ++___4336) cellMinMaxes[___4336].invalidate(); for (int cellI = 0; cellI <= 1; ++cellI) { for (int cellJ = 0; cellJ <= 1; ++cellJ) { for (int cellK = 0; cellK <= 1; ++cellK) { ___2226 ___2717 = ___460 + (cellK * dimensions.___2104() + cellJ) * dimensions.i() + cellI + 1; for (size_t ___4336 = 0; ___4336 < fieldDatas.size(); ++___4336) { double ___4299 = 0.0; if (fieldDatas[___4336].___2066()) ___4299 = fieldDatas[___4336].___1779(___2717); cellMinMaxes[___4336].include(___4299); } } } } } namespace{ void applyCellMinMaxToNeighborNodeSubzones( ___2226 i, ___2226 ___2104, ___2226 ___2133, std::vector<___2480> const& cellMinMaxes, ___1843 const& partitionOffsetIJK, ___1843 const& neighborOffsetIJK, ___1880& neighborInfo) { for (___2226 ___2157 = 0; ___2157 <= 1; ++___2157) { ___2226 neighborK = ___2157 + ___2133 + partitionOffsetIJK.___2133() - neighborOffsetIJK.___2133(); if (0 <= neighborK && neighborK < neighborInfo.___2715().___2133()) { for (___2226 ___2112 = 0; ___2112 <= 1; ++___2112) { ___2226 neighborJ = ___2112 + ___2104 + partitionOffsetIJK.___2104() - neighborOffsetIJK.___2104(); if (0 <= neighborJ && neighborJ < neighborInfo.___2715().___2104()) { for (___2226 ___1840 = 0; ___1840 <= 1; ++___1840) { ___2226 neighborI = ___1840 + i + partitionOffsetIJK.i() - neighborOffsetIJK.i(); if (0 <= neighborI && neighborI < neighborInfo.___2715().i())
{ ___1843 neighborNodeIJK((___81)neighborI, (___81)neighborJ, (___81)neighborK); ItemAddress64::SubzoneOffset_t ___2735 = neighborInfo.nszAtNodeIJK(neighborNodeIJK).subzoneOffset(); neighborInfo.includeNszVarMinMax(___2735, cellMinMaxes); } } } } } } } } void SZLOrderedPartitionedZoneWriter::applyCellMinMaxesToNeighborsInRange( std::vector<___1863> const& neighborItems, ItemAddress64::___2981 ___2978, ___1854 const& partitionRange, ___1843 const& partitionOffsetIJK, ___1843 const& partitionDimensionsIJK, std::vector<___1350> const& fieldDatas, std::vector<boost::shared_ptr<___1880> >& partitionInfos) { for (std::vector<___1863>::const_iterator neighborItem = neighborItems.begin(); neighborItem != neighborItems.end(); ++neighborItem) { ItemAddress64::___2981 neighborPartition = neighborItem->second; if (neighborPartition == ___2978) continue; ___1854 intersectionRange = ___1854(); ___1854 neighborRange = neighborItem->first; boost::geometry::intersection(partitionRange, neighborRange, intersectionRange); throwIfBadIntersectionRange(intersectionRange, ___2978, neighborPartition); ___2226 cellIMin = std::max((___2226)0, (___2226)(intersectionRange.min_corner().get<0>() - partitionOffsetIJK.i() - 1)); ___2226 ___459 = std::min((___2226)(partitionDimensionsIJK.i() - 2), (___2226)(intersectionRange.max_corner().get<0>() - partitionOffsetIJK.i())); ___2226 cellJMin = std::max((___2226)0, (___2226)(intersectionRange.min_corner().get<1>() - partitionOffsetIJK.___2104() - 1)); ___2226 ___464 = std::min((___2226)(partitionDimensionsIJK.___2104() - 2), (___2226)(intersectionRange.max_corner().get<1>() - partitionOffsetIJK.___2104())); ___2226 cellKMin = std::max((___2226)0, intersectionRange.min_corner().get<2>() - partitionOffsetIJK.___2133() - 1); ___2226 ___465 = std::min((___2226)(partitionDimensionsIJK.___2133() - 2), (___2226)(intersectionRange.max_corner().get<2>() - partitionOffsetIJK.___2133())); ___1843 neighborOffsetIJK((___81)neighborRange.min_corner().get<0>(), (___81)neighborRange.min_corner().get<1>(), (___81)neighborRange.min_corner().get<2>()); for (___2226 ___2133 = cellKMin; ___2133 <= ___465; ++___2133) { for (___2226 ___2104 = cellJMin; ___2104 <= ___464; ++___2104) { for (___2226 i = cellIMin; i <= ___459; ++i) { std::vector<___2480> cellMinMaxes(fieldDatas.size()); ___2226 ___460 = (___2133 * partitionDimensionsIJK.___2104() + ___2104) * partitionDimensionsIJK.i() + i; getCellMinMaxes(cellMinMaxes, ___460, partitionDimensionsIJK, fieldDatas); applyCellMinMaxToNeighborNodeSubzones(i, ___2104, ___2133, cellMinMaxes, partitionOffsetIJK, neighborOffsetIJK, *partitionInfos[neighborPartition]); } } } } } void SZLOrderedPartitionedZoneWriter::applyCellMinMaxesToNeighborNodeSubzones( ItemAddress64::___2981 ___2978, std::vector<___1350> const& nodalFieldDatas, std::vector<boost::shared_ptr<___1880> >& partitionInfos, ___1862 const& partitionTree) { ___1843 partitionOffsetIJK; ___2338.zonePartitionGetIJKOffset(___2678 + 1, ___2978 + 1, partitionOffsetIJK);
___1852 ___2475(partitionOffsetIJK.i(), partitionOffsetIJK.___2104(), partitionOffsetIJK.___2133()); ___1843 partitionDimensionsIJK; ___2338.zonePartitionGetIJK(___2678 + 1, ___2978 + 1, partitionDimensionsIJK); ___1843 partitionMaxIJK = partitionOffsetIJK + partitionDimensionsIJK - 1; ___1852 ___2365(partitionMaxIJK.i(), partitionMaxIJK.___2104(), partitionMaxIJK.___2133()); std::vector<___1863> neighborItems; ___1852 iFaceMinCorner(partitionMaxIJK.i(), partitionOffsetIJK.___2104(), partitionOffsetIJK.___2133()); ___1854 iFaceRange(iFaceMinCorner, ___2365); partitionTree.query(boost::geometry::index::intersects(iFaceRange), std::back_inserter(neighborItems)); applyCellMinMaxesToNeighborsInRange(neighborItems, ___2978, iFaceRange, partitionOffsetIJK, partitionDimensionsIJK, nodalFieldDatas, partitionInfos); neighborItems.clear(); ___1852 jFaceMinCorner(partitionOffsetIJK.i(), partitionMaxIJK.___2104(), partitionOffsetIJK.___2133()); ___1854 jFaceRange(jFaceMinCorner, ___2365); partitionTree.query(boost::geometry::index::intersects(jFaceRange), std::back_inserter(neighborItems)); applyCellMinMaxesToNeighborsInRange(neighborItems, ___2978, jFaceRange, partitionOffsetIJK, partitionDimensionsIJK, nodalFieldDatas, partitionInfos); neighborItems.clear(); ___1852 kFaceMinCorner(partitionOffsetIJK.i(), partitionOffsetIJK.___2104(), partitionMaxIJK.___2133()); ___1854 kFaceRange(kFaceMinCorner, ___2365); partitionTree.query(boost::geometry::index::intersects(kFaceRange), std::back_inserter(neighborItems)); applyCellMinMaxesToNeighborsInRange(neighborItems, ___2978, kFaceRange, partitionOffsetIJK, partitionDimensionsIJK, nodalFieldDatas, partitionInfos); } void SZLOrderedPartitionedZoneWriter::retrieveNodalFieldDataPtrsForPartition( ___37& partitionTecUtilDecorator, ItemAddress64::___2981 ___2978, std::vector<___1350> &nodalFieldDatas) { m_varIter.reset(); ___4352 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4352 const datasetVar = m_varIter.next(); ___4352 const fileVar = datasetVar - baseVar; if (___2338.___4353(datasetVar + 1) && !___2338.___924(___2678 + 1, datasetVar + 1)) { if (___2338.___908(___2678 + 1, datasetVar + 1) == ___4330) nodalFieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2978 + 1, datasetVar + 1, false, false); else nodalFieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2978 + 1, datasetVar + 1, false, true); } } } void SZLOrderedPartitionedZoneWriter::throwIfBadIntersectionRange( ___1854 const& intersectionRange, ItemAddress64::___2981 ___2978, ItemAddress64::___2981 neighborPartition) { if (intersectionRange.min_corner().get<0>() != intersectionRange.max_corner().get<0>() && intersectionRange.min_corner().get<1>() != intersectionRange.max_corner().get<1>() && intersectionRange.min_corner().get<2>() != intersectionRange.max_corner().get<2>()) { std::ostringstream ___2893; ___2893 << "Error writing zone " << ___2678 + 1 << ": partition " << ___2978 + 1 <<
" overlaps partition " << neighborPartition << " by more than one node layer. The overlap is (" << intersectionRange.min_corner().get<0>() << '-' << intersectionRange.max_corner().get<0>() << ", " << intersectionRange.min_corner().get<1>() << '-' << intersectionRange.max_corner().get<1>() << ", " << intersectionRange.min_corner().get<2>() << '-' << intersectionRange.max_corner().get<2>() << ")." << " Ghost cells cannot be output for ordered zones. Please correct the partition index ranges in your calls to tecijkptn."; throw std::runtime_error(___2893.str()); } } void SZLOrderedPartitionedZoneWriter::exchangeGhostInfo( std::vector<boost::shared_ptr<___1880> >& partitionInfos, std::vector<___1863> const& ___2982) { ___1862 partitionTree(___2982); PartitionTecUtilDecorator partitionTecUtilDecorator(___2338, ___2678 + 1); ___4352 const numVarsToWrite = m_varIter.___2813(); ItemAddress64::___2981 const numPartitions = static_cast<ItemAddress64::___2981>(___2338.zoneGetNumPartitions(___2678 + 1)); std::vector<___1863> neighborPartitions; for (ItemAddress64::___2981 ___2978 = 0; ___2978 < numPartitions; ++___2978) { std::vector<___1350> nodalFieldDatas(numVarsToWrite); retrieveNodalFieldDataPtrsForPartition(partitionTecUtilDecorator, ___2978, nodalFieldDatas); applyCellMinMaxesToNeighborNodeSubzones(___2978, nodalFieldDatas, partitionInfos, partitionTree); } } void SZLOrderedPartitionedZoneWriter::getPartitionExtentsWithGhostNodes( ItemAddress64::___2981 ___2978, ___1843& partitionMinIJK, ___1843& partitionMaxIJK) { REQUIRE(___2978 < static_cast<ItemAddress64::___2981>(___2338.zoneGetNumPartitions(___2678 + 1))); ___1843 partitionSize; ___2338.zonePartitionGetIJK(___2678 + 1, ___2978 + 1, partitionSize); ___2338.zonePartitionGetIJKOffset(___2678 + 1, ___2978 + 1, partitionMinIJK); partitionMaxIJK = partitionMinIJK + partitionSize - 1; } void SZLOrderedPartitionedZoneWriter::trimGhostNodes(___1843 &partitionMaxIJK) { ___1843 zoneSize; ___2338.___4615(___2678 + 1, zoneSize); if (partitionMaxIJK.i() < zoneSize.i() - 1) partitionMaxIJK.setI(partitionMaxIJK.i() - 1); if (partitionMaxIJK.___2104() < zoneSize.___2104() - 1) partitionMaxIJK.setJ(partitionMaxIJK.___2104() - 1); if (partitionMaxIJK.___2133() < zoneSize.___2133() - 1) partitionMaxIJK.___3498(partitionMaxIJK.___2133() - 1); } void SZLOrderedPartitionedZoneWriter::getPartitionExtentsWithoutGhostNodes( ItemAddress64::___2981 ___2978, ___1843& partitionMinIJK, ___1843& partitionMaxIJK) { REQUIRE(___2978 < static_cast<ItemAddress64::___2981>(___2338.zoneGetNumPartitions(___2678 + 1))); getPartitionExtentsWithGhostNodes(___2978, partitionMinIJK, partitionMaxIJK); trimGhostNodes(partitionMaxIJK); } void SZLOrderedPartitionedZoneWriter::createPartitionWriters() { std::vector<boost::shared_ptr<___1880> > partitionInfos; ItemAddress64::___2981 numPartitions = static_cast<ItemAddress64::___2981>(___2338.zoneGetNumPartitions(___2678 + 1));
std::vector<___1863> ___2982; ___2982.reserve((size_t)numPartitions); ___1843 zoneSize; ___2338.___4615(___2678 + 1, zoneSize); for (ItemAddress64::___2981 ___2978 = 0; ___2978 < numPartitions; ++___2978) { partitionInfos.push_back(___2681.getIJKZonePartitionInfo(___2678, ___2978)); ___1843 partitionMinIJK; ___1843 partitionMaxIJK; getPartitionExtentsWithoutGhostNodes(___2978, partitionMinIJK, partitionMaxIJK); m_partitionMinNodeNumbers[___2978] = zoneSize.offsetAtIJK(partitionMinIJK); m_partitionMaxNodeNumbers[___2978] = zoneSize.offsetAtIJK(partitionMaxIJK); ___1852 ___2479(partitionMinIJK.i(), partitionMinIJK.___2104(), partitionMinIJK.___2133()); ___1852 ___2373(partitionMaxIJK.i(), partitionMaxIJK.___2104(), partitionMaxIJK.___2133()); ___2982.push_back(std::make_pair(___1854(___2479, ___2373), ___2978)); } exchangeGhostInfo(partitionInfos, ___2982); for (ItemAddress64::___2981 ___2978 = 0; ___2978 < numPartitions; ++___2978) { m_partitionWriters[___2978] = boost::make_shared<SZLOrderedPartitionWriter> ( m_fileVersion, boost::ref(m_varIter), ___2678, m_baseZone, ___2978, boost::ref(m_writeVariables), m_writeConnectivity, boost::ref(m_partitionTecUtil), partitionInfos[___2978]); } } ___372 SZLOrderedPartitionedZoneWriter::writeZoneData(FileWriterInterface& szpltFile) { if (m_partitionWriters.empty()) createPartitionWriters(); for(___4636 ___2978 = 0; ___2978 < ___2338.zoneGetNumPartitions(___2678 + 1); ++___2978) { m_partitionWriters[___2978]->writeZone(szpltFile, szpltFile.fileLoc()); m_partitionHeaderFilePositions[___2978] = m_partitionWriters[___2978]->getZoneHeaderFilePosition(); m_varIter.reset(); ___4352 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4352 const datasetVar = m_varIter.next(); ___4352 const fileVar = datasetVar - baseVar; m_varPartitionMinMaxes[fileVar][___2978] = m_partitionWriters[___2978]->varMinMax(datasetVar); } } return ___4227; } uint64_t SZLOrderedPartitionedZoneWriter::zoneDataFileSize(bool ___2001) { if (m_partitionWriters.empty()) createPartitionWriters(); uint64_t ___3359 = 0; for(___4636 ___2978 = 0; ___2978 < ___2338.zoneGetNumPartitions(___2678 + 1); ++___2978) ___3359 += m_partitionWriters[___2978]->zoneFileSize(___2001); return ___3359; } ___372 SZLOrderedPartitionedZoneWriter::writeZoneConnectivity(FileWriterInterface&  ) { return ___4227; } uint64_t SZLOrderedPartitionedZoneWriter::zoneConnectivityFileSize(bool  ) { return 0; } ___372 SZLOrderedPartitionedZoneWriter::writeZoneHeader(FileWriterInterface& szpltFile) { REQUIRE(szpltFile.___2040()); return m_headerWriter.write(szpltFile); } uint64_t SZLOrderedPartitionedZoneWriter::zoneHeaderFileSize(bool ___2001) { return m_headerWriter.sizeInFile(___2001); } }}
