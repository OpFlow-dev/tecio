#include "SZLOrderedPartitionedZoneWriterMPI.h"
#include "ThirdPartyHeadersBegin.h"
#include <limits>
#include <boost/functional/hash.hpp>
#include <boost/make_shared.hpp>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData.h"
#include "FileWriterInterface.h"
#include "ItemSetIterator.h"
#include "MPICommunicationCache.h"
#include "MPICommunicator.h"
#include "MPIFileWriter.h"
#include "MPINonBlockingCommunicationCollection.h"
#include "MPIUtil.h"
#include "SZLOrderedPartitionWriter.h"
#include "TecioMPI.h"
#include "ZoneInfoCache.h"
using namespace tecplot::___3934; namespace tecplot { namespace ___3934 { std::size_t hash_value(___1843 const& ___1842) { std::size_t seed = 0; boost::hash_combine(seed, ___1842.i()); boost::hash_combine(seed, ___1842.___2104()); boost::hash_combine(seed, ___1842.___2133()); return seed; } }} namespace tecplot { namespace teciompi { struct SZLOrderedPartitionedZoneWriterMPI::Impl { typedef boost::unordered_map<ItemAddress64::SubzoneOffset_t, std::vector<___2480> > SubzoneMinMaxMap; struct NeighborExtents { SimpleVector<ItemAddress64::___2981> neighborPartitions; SimpleVector<uint64_t> neighborMinNodeNumbers; SimpleVector<uint64_t> neighborMaxNodeNumbers; }; typedef boost::unordered_map<ItemAddress64::___2981, NeighborExtents> NeighborExtentsMap; struct IJKExtents { ___1843 ___2475; ___1843 ___2365; IJKExtents() {} IJKExtents(___1843 const& ___2475, ___1843 const& ___2365) : ___2475(___2475) , ___2365(___2365) {} }; boost::unordered_map<ItemAddress64::___2981, IJKExtents> partitionExtentsMap; struct PartitionIntersection { ItemAddress64::___2981 ___2978; ItemAddress64::___2981 neighborPartition; IJKExtents extents; PartitionIntersection( ItemAddress64::___2981 ___2978, ItemAddress64::___2981 neighborPartition, ___1843 const& ___2475, ___1843 const& ___2365) : ___2978(___2978) , neighborPartition(neighborPartition) , extents(___2475, ___2365) {} }; struct SendOrder { bool operator() (PartitionIntersection const& a, PartitionIntersection const& b) { if (a.___2978 < b.___2978) return true; else if (a.___2978 == b.___2978 && a.neighborPartition < b.neighborPartition) return true; return false; } }; struct ReceiveOrder { bool operator() (PartitionIntersection const& a, PartitionIntersection const& b) { if (a.neighborPartition < b.neighborPartition) return true; else if (a.neighborPartition == b.neighborPartition && a.___2978 < b.___2978) return true; return false; } }; struct SubzoneMinMaxes { SimpleVector<ItemAddress64::SubzoneOffset_t> subzones; SimpleVector<___2480> varMinMaxes; }; typedef boost::unordered_map<ItemAddress64::___2981, SubzoneMinMaxes> NeighborMinMaxMap; typedef boost::unordered_map<ItemAddress64::___2981, NeighborMinMaxMap> PartitionMinMaxMap; SZLOrderedPartitionedZoneWriterMPI& m_outer; MPI_Comm m_comm; int m_mainProcess; int m_localProcess; bool m_useCollectiveRoutines; Impl( SZLOrderedPartitionedZoneWriterMPI& outer, MPI_Comm comm, int mainProcess, ___37& ___36, ___4636 zone) : m_outer(outer) , m_comm(comm) , m_mainProcess(mainProcess) , m_useCollectiveRoutines(everyRankOwnsOnePartition(comm, ___36, zone)) { MPI_Comm_rank(m_comm, &m_localProcess); createPartitionWriters(); } typedef std::map<ItemAddress64::___2981, boost::shared_ptr<___3934::___1880> > PartitionIJKInfoMap; void createPartitionWriters(); void sendLocalPartitionExtentsToMainProcess(PartitionIJKInfoMap& partitionIJKInfoMap, MPINonBlockingCommunicationCollection& communicationCollection); void collectAllPartitionExtents(MPINonBlockingCommunicationCollection& communicationCollection);
void distributePartitionNeighborExtents(MPINonBlockingCommunicationCollection& communicationCollection); void receiveNeighborPartitionExtents( PartitionIJKInfoMap const& partitionijkInfoMap, MPINonBlockingCommunicationCollection& communicationCollection, NeighborExtentsMap& neighborExtentsMap); void calculateNeighborIntesections( NeighborExtentsMap const& neighborExtentsMap, std::vector<PartitionIntersection>& partitionIntersections); void applyCellMinMaxToNodeSubzones( ___2226 cellI, ___2226 cellJ, ___2226 cellK, boost::unordered_set<___1843> const& nodeSet, IJKSubzoneInfo const& subzoneInfo, ___1843 const& partitionMinIJK, std::vector<___2480> const& cellMinMaxes, SubzoneMinMaxMap& nszMinMaxMap); void sendMinMaxesToNeighbors( std::vector<PartitionIntersection>& partitionIntersections, MPINonBlockingCommunicationCollection& communicationCollection); void receiveMinMaxesFromNeighbors( std::vector<PartitionIntersection> const& partitionIntersections, MPINonBlockingCommunicationCollection& communicationCollection, PartitionMinMaxMap& partitionMinMaxMap); void applyReceivedMinMaxesToSubzones( PartitionMinMaxMap const& partitionMinMaxMap, size_t ___2844, PartitionIJKInfoMap& partitionIJKInfoMap); void exchangeGhostInfo(PartitionIJKInfoMap& partitionIJKInfoMap); }; SZLOrderedPartitionedZoneWriterMPI::SZLOrderedPartitionedZoneWriterMPI( uint32_t                      fileVersion, ItemSetIterator&              varIter, ___4636                   zone, ___4636                   ___341, std::vector<___372> const& ___4564, ___372                     ___4499, ___37&                   ___36, ZoneInfoCache&                zoneInfoCache, MPI_Comm                      communicator, int                           mainProcess) : SZLOrderedPartitionedZoneWriter(fileVersion, varIter, zone, ___341, ___4564, ___4499, ___36, zoneInfoCache) , m_impl(new Impl(*this, communicator, mainProcess, ___36, zone)) {} SZLOrderedPartitionedZoneWriterMPI::~SZLOrderedPartitionedZoneWriterMPI() {} ___2480 SZLOrderedPartitionedZoneWriterMPI::varMinMax(___3934::___4352 datasetVar) { REQUIRE(m_varIter.baseItem() <= datasetVar && datasetVar < m_varIter.___2813()); ___2480 ___3359; ___4352 const baseVar = m_varIter.baseItem(); for (___4636 ___2978 = 0; ___2978 < ___2338.zoneGetNumPartitions(___2678 + 1); ++___2978) ___3359.include(m_varPartitionMinMaxes[datasetVar - baseVar][___2978]); return ___3359; } namespace { std::vector<___1863> gatherPartitionTreeItems( UInt64Array const& minNodeNumbers, UInt64Array const& maxNodeNumbers, ___1843 const& zoneSize, ItemAddress64::___2981 numPartitions) { std::vector<___1863> ___2982; ___2982.reserve(numPartitions); for (ItemAddress64::___2981 ___2978 = 0; ___2978 < numPartitions; ++___2978) { ___1843 partitionMinIJK = zoneSize.ijkAtOffset(static_cast<___81>(minNodeNumbers[___2978])); ___1843 partitionMaxIJK = (zoneSize.ijkAtOffset(static_cast<___81>(maxNodeNumbers[___2978])) + 1).minOp(zoneSize - 1);
___1852 ___2479(partitionMinIJK.i(), partitionMinIJK.___2104(), partitionMinIJK.___2133()); ___1852 ___2373(partitionMaxIJK.i(), partitionMaxIJK.___2104(), partitionMaxIJK.___2133()); ___2982.push_back(std::make_pair(___1854(___2479, ___2373), ___2978)); } return ___2982; } } void SZLOrderedPartitionedZoneWriterMPI::Impl::sendLocalPartitionExtentsToMainProcess( PartitionIJKInfoMap& partitionIJKInfoMap, MPINonBlockingCommunicationCollection& communicationCollection) { ___1843 zoneSize; m_outer.___2338.___4615(m_outer.___2678 + 1, zoneSize); for (PartitionIJKInfoMap::iterator infoPair = partitionIJKInfoMap.begin(); infoPair != partitionIJKInfoMap.end(); ++infoPair) { communicationCollection.sendScalar(m_outer.m_partitionMinNodeNumbers[infoPair->first], m_mainProcess, TecioMPI::PARTITION_MIN_NODE_NUMBER); communicationCollection.sendScalar(m_outer.m_partitionMaxNodeNumbers[infoPair->first], m_mainProcess, TecioMPI::PARTITION_MAX_NODE_NUMBER); } } void SZLOrderedPartitionedZoneWriterMPI::Impl::collectAllPartitionExtents(MPINonBlockingCommunicationCollection& communicationCollection) { for (ItemAddress64::___2981 ___2978 = 0; ___2978 < static_cast<ItemAddress64::___2981>(m_outer.___2338.zoneGetNumPartitions(m_outer.___2678 + 1)); ++___2978) { int32_t owner = m_outer.___2338.zonePartitionGetOwnerProcess(m_outer.___2678 + 1, ___2978 + 1); if (owner != m_localProcess) { communicationCollection.receiveScalar(m_outer.m_partitionMinNodeNumbers[___2978], owner, TecioMPI::PARTITION_MIN_NODE_NUMBER); communicationCollection.receiveScalar(m_outer.m_partitionMaxNodeNumbers[___2978], owner, TecioMPI::PARTITION_MAX_NODE_NUMBER); } } communicationCollection.___4446(); } void SZLOrderedPartitionedZoneWriterMPI::Impl::distributePartitionNeighborExtents(MPINonBlockingCommunicationCollection& communicationCollection) { ___1843 zoneSize; m_outer.___2338.___4615(m_outer.___2678 + 1, zoneSize); ItemAddress64::___2981 numPartitions = m_outer.___2338.zoneGetNumPartitions(m_outer.___2678 + 1); ___1862 partitionTree(gatherPartitionTreeItems(m_outer.m_partitionMinNodeNumbers, m_outer.m_partitionMaxNodeNumbers, zoneSize, numPartitions)); std::vector<ItemAddress64::___2981> neighborPartitions; std::vector<uint64_t> neighborMinNodes; std::vector<uint64_t> neighborMaxNodes; std::vector<___1863> neighborItems; for (ItemAddress64::___2981 ___2978 = 0; ___2978 < numPartitions; ++___2978) { ___1843 partitionMinIJK = zoneSize.ijkAtOffset(static_cast<___81>(m_outer.m_partitionMinNodeNumbers[___2978])); ___1843 partitionMaxIJK = (zoneSize.ijkAtOffset(static_cast<___81>(m_outer.m_partitionMaxNodeNumbers[___2978])) + 1).minOp(zoneSize - 1); neighborItems.clear(); partitionTree.find(partitionMinIJK, partitionMaxIJK, neighborItems); neighborPartitions.clear(); neighborMinNodes.clear(); neighborMaxNodes.clear(); neighborPartitions.reserve(neighborItems.size()); neighborMinNodes.reserve(neighborItems.size());
neighborMaxNodes.reserve(neighborItems.size()); int32_t owner = m_outer.___2338.zonePartitionGetOwnerProcess(m_outer.___2678 + 1, ___2978 + 1); for (std::vector<___1863>::const_iterator neighborItem = neighborItems.begin(); neighborItem != neighborItems.end(); ++neighborItem) { ItemAddress64::___2981 neighborPartition = neighborItem->second; if (neighborPartition != ___2978) { neighborPartitions.push_back(neighborPartition); neighborMinNodes.push_back(m_outer.m_partitionMinNodeNumbers[neighborPartition]); neighborMaxNodes.push_back(m_outer.m_partitionMaxNodeNumbers[neighborPartition]); } } communicationCollection.sendVectorCopy(neighborPartitions, owner, TecioMPI::PARTITION_NEIGHBORS_SIZE, TecioMPI::PARTITION_NEIGHBORS_VEC); communicationCollection.sendVectorCopy(neighborMinNodes, owner, TecioMPI::PARTITION_NEIGHBOR_MIN_NODES_SIZE, TecioMPI::PARTITION_NEIGHBOR_MIN_NODES_VEC); communicationCollection.sendVectorCopy(neighborMaxNodes, owner, TecioMPI::PARTITION_NEIGHBOR_MAX_NODES_SIZE, TecioMPI::PARTITION_NEIGHBOR_MAX_NODES_VEC); } } void SZLOrderedPartitionedZoneWriterMPI::Impl::receiveNeighborPartitionExtents( PartitionIJKInfoMap const& partitionIJKInfoMap, MPINonBlockingCommunicationCollection& communicationCollection, NeighborExtentsMap& neighborExtentsMap) { for (PartitionIJKInfoMap::const_iterator infoPair = partitionIJKInfoMap.begin(); infoPair != partitionIJKInfoMap.end(); ++infoPair) { ItemAddress64::___2981 ___2978 = infoPair->first; communicationCollection.receiveVector(neighborExtentsMap[___2978].neighborPartitions, m_mainProcess, TecioMPI::PARTITION_NEIGHBORS_SIZE, TecioMPI::PARTITION_NEIGHBORS_VEC); communicationCollection.receiveVector(neighborExtentsMap[___2978].neighborMinNodeNumbers, m_mainProcess, TecioMPI::PARTITION_NEIGHBOR_MIN_NODES_SIZE, TecioMPI::PARTITION_NEIGHBOR_MIN_NODES_VEC); communicationCollection.receiveVector(neighborExtentsMap[___2978].neighborMaxNodeNumbers, m_mainProcess, TecioMPI::PARTITION_NEIGHBOR_MAX_NODES_SIZE, TecioMPI::PARTITION_NEIGHBOR_MAX_NODES_VEC); } communicationCollection.___4446(); } void SZLOrderedPartitionedZoneWriterMPI::Impl::calculateNeighborIntesections( NeighborExtentsMap const& neighborExtentsMap, std::vector<PartitionIntersection>& partitionIntersections) { REQUIRE(partitionIntersections.empty()); ___1843 zoneSize; m_outer.___2338.___4615(m_outer.___2678 + 1, zoneSize); for (NeighborExtentsMap::const_iterator neighborPair = neighborExtentsMap.begin(); neighborPair != neighborExtentsMap.end(); ++neighborPair) { ItemAddress64::___2981 ___2978 = neighborPair->first; ___1843 partitionMinIJK; ___1843 partitionMaxIJK; m_outer.getPartitionExtentsWithGhostNodes(___2978, partitionMinIJK, partitionMaxIJK); partitionExtentsMap[___2978] = IJKExtents(partitionMinIJK, partitionMaxIJK); NeighborExtents const& neighborExtents = neighborPair->second; for (int i = 0; i < neighborExtents.neighborPartitions.size(); ++i) { ItemAddress64::___2981 neighborPartition = neighborExtents.neighborPartitions[i];
___1843 neighborMinIJK = zoneSize.ijkAtOffset(static_cast<___81>(neighborExtents.neighborMinNodeNumbers[i])); ___1843 neighborMaxIJK = (zoneSize.ijkAtOffset(static_cast<___81>(neighborExtents.neighborMaxNodeNumbers[i])) + 1).minOp(zoneSize - 1); partitionExtentsMap[neighborPartition] = IJKExtents(neighborMinIJK, neighborMaxIJK); ___1852 partitionMinCorner(partitionMinIJK.i(), partitionMinIJK.___2104(), partitionMinIJK.___2133()); ___1852 partitionMaxCorner(partitionMaxIJK.i(), partitionMaxIJK.___2104(), partitionMaxIJK.___2133()); ___1854 partitionRange(partitionMinCorner, partitionMaxCorner); ___1852 neighborMinCorner(neighborMinIJK.i(), neighborMinIJK.___2104(), neighborMinIJK.___2133()); ___1852 neighborMaxCorner(neighborMaxIJK.i(), neighborMaxIJK.___2104(), neighborMaxIJK.___2133()); ___1854 neighborRange(neighborMinCorner, neighborMaxCorner); ___1854 intersectionRange; boost::geometry::intersection(partitionRange, neighborRange, intersectionRange); m_outer.throwIfBadIntersectionRange(intersectionRange, ___2978, neighborPartition); partitionIntersections.push_back( PartitionIntersection( ___2978, neighborPartition, ___1843(static_cast<___81>(intersectionRange.min_corner().get<0>()), static_cast<___81>(intersectionRange.min_corner().get<1>()), static_cast<___81>(intersectionRange.min_corner().get<2>())), ___1843(static_cast<___81>(intersectionRange.max_corner().get<0>()), static_cast<___81>(intersectionRange.max_corner().get<1>()), static_cast<___81>(intersectionRange.max_corner().get<2>())))); } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::applyCellMinMaxToNodeSubzones( ___2226 cellI, ___2226 cellJ, ___2226 cellK, boost::unordered_set<___1843> const& nodeSet, IJKSubzoneInfo const& subzoneInfo, ___1843 const& partitionMinIJK, std::vector<___2480> const& cellMinMaxes, SubzoneMinMaxMap& nszMinMaxMap) { for (___2226 ___2133 = 0; ___2133 <= 1; ++___2133) { for (___2226 ___2104 = 0; ___2104 <= 1; ++___2104) { for (___2226 i = 0; i <= 1; ++i) { ___1843 nodeIJK(static_cast<___81>(cellI + i), static_cast<___81>(cellJ + ___2104), static_cast<___81>(cellK + ___2133)); if (nodeSet.find(nodeIJK) != nodeSet.end()) { ___1843 partitionNodeIJK = nodeIJK - partitionMinIJK; ItemAddress64::SubzoneOffset_t ___3881 = subzoneInfo.szAddressAtItemIJK(partitionNodeIJK).subzoneOffset(); if (nszMinMaxMap[___3881].empty()) nszMinMaxMap[___3881].resize(cellMinMaxes.size()); for (size_t m = 0; m < cellMinMaxes.size(); ++m) { nszMinMaxMap[___3881][m].include(cellMinMaxes[m]); } } } } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::sendMinMaxesToNeighbors( std::vector<PartitionIntersection>& partitionIntersections, MPINonBlockingCommunicationCollection& communicationCollection) { ___1843 zoneSize; m_outer.___2338.___4615(m_outer.___2678 + 1, zoneSize); PartitionTecUtilDecorator partitionTecUtilDecorator(m_outer.___2338, m_outer.___2678 + 1); ___4352 const numVarsToWrite = m_outer.m_varIter.___2813(); for (size_t iPartition = 0; iPartition < partitionIntersections.size(); ++iPartition) { ItemAddress64::___2981 ___2978 = partitionIntersections[iPartition].___2978;
ItemAddress64::___2981 neighborPartition = partitionIntersections[iPartition].neighborPartition; IJKExtents intersectionExtents = partitionIntersections[iPartition].extents; IJKExtents const& partitionExtents = partitionExtentsMap[___2978]; IJKExtents const& neighborExtents = partitionExtentsMap[neighborPartition]; if (intersectionExtents.___2475.i() == partitionExtents.___2365.i() || intersectionExtents.___2475.___2104() == partitionExtents.___2365.___2104() || intersectionExtents.___2475.___2133() == partitionExtents.___2365.___2133()) { if (intersectionExtents.___2365.i() == neighborExtents.___2365.i() && intersectionExtents.___2365.i() < zoneSize.i() - 1) intersectionExtents.___2365.setI(intersectionExtents.___2365.i() - 1); if (intersectionExtents.___2365.___2104() == neighborExtents.___2365.___2104() && intersectionExtents.___2365.___2104() < zoneSize.___2104() - 1) intersectionExtents.___2365.setJ(intersectionExtents.___2365.___2104() - 1); if (intersectionExtents.___2365.___2133() == neighborExtents.___2365.___2133() && intersectionExtents.___2365.___2133() < zoneSize.___2133() - 1) intersectionExtents.___2365.___3498(intersectionExtents.___2365.___2133() - 1); if (intersectionExtents.___2475 <= intersectionExtents.___2365) { std::vector<___1350> nodalFieldDatas(numVarsToWrite); m_outer.retrieveNodalFieldDataPtrsForPartition(partitionTecUtilDecorator, ___2978, nodalFieldDatas); int32_t owner = m_outer.___2338.zonePartitionGetOwnerProcess(m_outer.___2678 + 1, neighborPartition + 1); boost::unordered_set<___1843> nodeSet; for (___2226 ___2133 = intersectionExtents.___2475.___2133(); ___2133 <= intersectionExtents.___2365.___2133(); ++___2133) { for (___2226 ___2104 = intersectionExtents.___2475.___2104(); ___2104 <= intersectionExtents.___2365.___2104(); ++___2104) { for (___2226 i = intersectionExtents.___2475.i(); i <= intersectionExtents.___2365.i(); ++i) { ___1843 nodeIJK(static_cast<___81>(i), static_cast<___81>(___2104), static_cast<___81>(___2133)); nodeSet.insert(nodeIJK); } } } SubzoneMinMaxMap neighborMinMaxMap; ___1843 cellMinIJK( std::max(partitionExtents.___2475.i(), intersectionExtents.___2475.i() == 0 ? 0 : intersectionExtents.___2475.i() - 1), std::max(partitionExtents.___2475.___2104(), intersectionExtents.___2475.___2104() == 0 ? 0 : intersectionExtents.___2475.___2104() - 1), std::max(partitionExtents.___2475.___2133(), intersectionExtents.___2475.___2133() == 0 ? 0 : intersectionExtents.___2475.___2133() - 1)); ___1843 cellMaxIJK( std::min(partitionExtents.___2365.i() - 1, intersectionExtents.___2365.i()), std::min(partitionExtents.___2365.___2104() - 1, intersectionExtents.___2365.___2104()), std::min(partitionExtents.___2365.___2133() - 1, intersectionExtents.___2365.___2133())); std::vector<___2480> cellMinMaxes(nodalFieldDatas.size()); ___1843 partitionDimensionsIJK = partitionExtents.___2365 - partitionExtents.___2475 + 1; ___1843 neighborDimensionsIJK = neighborExtents.___2365 - neighborExtents.___2475 + 1; if (neighborExtents.___2365.i() < zoneSize.i() - 1) neighborDimensionsIJK.setI(neighborDimensionsIJK.i() - 1); if (neighborExtents.___2365.___2104() < zoneSize.___2104() - 1)
neighborDimensionsIJK.setJ(neighborDimensionsIJK.___2104() - 1); if (neighborExtents.___2365.___2133() < zoneSize.___2133() - 1) neighborDimensionsIJK.___3498(neighborDimensionsIJK.___2133() - 1); IJKSubzoneInfo neighborSubzoneInfo(neighborDimensionsIJK, DEFAULT_SUBZONE_MAX_IJK_DIM, neighborPartition, true); for (___2226 cellK = cellMinIJK.___2133(); cellK <= cellMaxIJK.___2133(); ++cellK) { for (___2226 cellJ = cellMinIJK.___2104(); cellJ <= cellMaxIJK.___2104(); ++cellJ) { for (___2226 cellI = cellMinIJK.i(); cellI <= cellMaxIJK.i(); ++cellI) { ___2226 ___460 = ((cellK - partitionExtents.___2475.___2133()) * partitionDimensionsIJK.___2104() + cellJ - partitionExtents.___2475.___2104()) * partitionDimensionsIJK.i() + cellI - partitionExtents.___2475.i(); m_outer.getCellMinMaxes(cellMinMaxes, ___460, partitionDimensionsIJK, nodalFieldDatas); applyCellMinMaxToNodeSubzones(cellI, cellJ, cellK, nodeSet, neighborSubzoneInfo, neighborExtents.___2475, cellMinMaxes, neighborMinMaxMap); } } } std::vector<ItemAddress64::SubzoneOffset_t> nodeSubzones; std::vector<___2480> minMaxValues; nodeSubzones.reserve(neighborMinMaxMap.size()); minMaxValues.reserve(neighborMinMaxMap.size() * nodalFieldDatas.size()); for (SubzoneMinMaxMap::const_iterator valuePair = neighborMinMaxMap.begin(); valuePair != neighborMinMaxMap.end(); ++valuePair) { nodeSubzones.push_back(valuePair->first); for (size_t i = 0; i < nodalFieldDatas.size(); ++i) minMaxValues.push_back(valuePair->second[i]); } communicationCollection.sendVectorCopy(nodeSubzones, owner, TecioMPI::REFERENCED_NODE_SUBZONES_SIZE, TecioMPI::REFERENCED_NODE_SUBZONES_VEC); communicationCollection.sendVectorCopy(minMaxValues, owner, TecioMPI::NODE_SUBZONE_MINMAX_VALUES_SIZE, TecioMPI::NODE_SUBZONE_MINMAX_VALUES_VEC); } } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::receiveMinMaxesFromNeighbors( std::vector<PartitionIntersection> const& partitionIntersections, MPINonBlockingCommunicationCollection& communicationCollection, PartitionMinMaxMap& partitionMinMaxMap) { ___1843 zoneSize; m_outer.___2338.___4615(m_outer.___2678 + 1, zoneSize); for (size_t i = 0; i < partitionIntersections.size(); ++i) { ItemAddress64::___2981 const ___2978 = partitionIntersections[i].___2978; ItemAddress64::___2981 const neighborPartition = partitionIntersections[i].neighborPartition; IJKExtents intersectionExtents = partitionIntersections[i].extents; IJKExtents const& partitionExtents = partitionExtentsMap[___2978]; if (intersectionExtents.___2365.i() == partitionExtents.___2365.i() && intersectionExtents.___2365.i() < zoneSize.i() - 1) intersectionExtents.___2365.setI(intersectionExtents.___2365.i() - 1); if (intersectionExtents.___2365.___2104() == partitionExtents.___2365.___2104() && intersectionExtents.___2365.___2104() < zoneSize.___2104() - 1) intersectionExtents.___2365.setJ(intersectionExtents.___2365.___2104() - 1); if (intersectionExtents.___2365.___2133() == partitionExtents.___2365.___2133() && intersectionExtents.___2365.___2133() < zoneSize.___2133() - 1) intersectionExtents.___2365.___3498(intersectionExtents.___2365.___2133() - 1);
if (intersectionExtents.___2475 <= intersectionExtents.___2365) { int32_t owner = m_outer.___2338.zonePartitionGetOwnerProcess(m_outer.___2678 + 1, neighborPartition + 1); communicationCollection.receiveVector(partitionMinMaxMap[___2978][neighborPartition].subzones, owner, TecioMPI::REFERENCED_NODE_SUBZONES_SIZE, TecioMPI::REFERENCED_NODE_SUBZONES_VEC); communicationCollection.receiveVector(partitionMinMaxMap[___2978][neighborPartition].varMinMaxes, owner, TecioMPI::NODE_SUBZONE_MINMAX_VALUES_SIZE, TecioMPI::NODE_SUBZONE_MINMAX_VALUES_VEC); } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::applyReceivedMinMaxesToSubzones( PartitionMinMaxMap const& partitionMinMaxMap, size_t ___2844, PartitionIJKInfoMap& partitionIJKInfoMap) { for (PartitionMinMaxMap::const_iterator partitionNeighborPair = partitionMinMaxMap.begin(); partitionNeighborPair != partitionMinMaxMap.end(); ++partitionNeighborPair) { ItemAddress64::___2981 ___2978 = partitionNeighborPair->first; boost::shared_ptr<___1880> const& partitionIJKInfoPtr = partitionIJKInfoMap[___2978]; for (NeighborMinMaxMap::const_iterator neighborMinMaxPair = partitionNeighborPair->second.begin(); neighborMinMaxPair != partitionNeighborPair->second.end(); ++neighborMinMaxPair) { ItemAddress64::___2981 neighborPartition = neighborMinMaxPair->first; SubzoneMinMaxes const& subzoneMinMaxes = neighborMinMaxPair->second; if (subzoneMinMaxes.varMinMaxes.size() != static_cast<int>(___2844) * subzoneMinMaxes.subzones.size()) { std::ostringstream ___2893; ___2893 << "Mismatched var minmax array sizes (internal error)." << " Partition: " << ___2978 << " Neighbor partition: " << neighborPartition << " # subzones: " << subzoneMinMaxes.subzones.size() << " # vars: " << ___2844 << " # varMinMaxes: " << subzoneMinMaxes.varMinMaxes.size() << ". Please contact technical support."; throw std::runtime_error(___2893.str()); } std::vector<___2480> minMaxesForNode(___2844); for (int i = 0; i < subzoneMinMaxes.subzones.size(); ++i) { if (!partitionIJKInfoPtr->validNodeSubzone(subzoneMinMaxes.subzones[i])) { std::ostringstream ___2893; ___2893 << "Invalid node subzone (" << subzoneMinMaxes.subzones[i] << ") passed from partition " << neighborPartition << " to partition " << ___2978 << " (internal error). Please contact technical support."; throw std::runtime_error(___2893.str()); } for (size_t ___2104 = 0; ___2104 < ___2844; ++___2104) { ___476(i * ___2844 + ___2104 <= static_cast<size_t>(std::numeric_limits<int32_t>::max())); int ind = static_cast<int>(i * ___2844 + ___2104); minMaxesForNode[___2104] = subzoneMinMaxes.varMinMaxes[ind]; } partitionIJKInfoPtr->includeNszVarMinMax(subzoneMinMaxes.subzones[i], minMaxesForNode); } } } } void SZLOrderedPartitionedZoneWriterMPI::Impl::exchangeGhostInfo(PartitionIJKInfoMap& partitionIJKInfoMap) { MPINonBlockingCommunicationCollection communicationCollection(m_comm); if (m_localProcess == m_mainProcess) { collectAllPartitionExtents(communicationCollection); distributePartitionNeighborExtents(communicationCollection);
} else { sendLocalPartitionExtentsToMainProcess(partitionIJKInfoMap, communicationCollection); } NeighborExtentsMap neighborExtentsMap; receiveNeighborPartitionExtents(partitionIJKInfoMap, communicationCollection, neighborExtentsMap); std::vector<PartitionIntersection> partitionIntersections; calculateNeighborIntesections(neighborExtentsMap, partitionIntersections); std::sort(partitionIntersections.begin(), partitionIntersections.end(), SendOrder()); sendMinMaxesToNeighbors(partitionIntersections, communicationCollection); std::sort(partitionIntersections.begin(), partitionIntersections.end(), ReceiveOrder()); PartitionMinMaxMap partitionMinMaxMap; receiveMinMaxesFromNeighbors(partitionIntersections, communicationCollection, partitionMinMaxMap); communicationCollection.___4446(); applyReceivedMinMaxesToSubzones(partitionMinMaxMap, m_outer.m_varIter.___2813(), partitionIJKInfoMap); } void SZLOrderedPartitionedZoneWriterMPI::Impl::createPartitionWriters() { PartitionIJKInfoMap partitionIJKInfoMap; ItemAddress64::___2981 numPartitions = static_cast<ItemAddress64::___2981>(m_outer.___2338.zoneGetNumPartitions(m_outer.___2678 + 1)); ___1843 zoneSize; m_outer.___2338.___4615(m_outer.___2678 + 1, zoneSize); for (ItemAddress64::___2981 ___2978 = 0; ___2978 < numPartitions; ++___2978) { if (m_outer.___2338.zonePartitionGetOwnerProcess(m_outer.___2678 + 1, ___2978 + 1) == m_localProcess) { partitionIJKInfoMap[___2978] = m_outer.___2681.getIJKZonePartitionInfo(m_outer.___2678, ___2978); ___1843 partitionMinIJK; ___1843 partitionMaxIJK; m_outer.getPartitionExtentsWithoutGhostNodes(___2978, partitionMinIJK, partitionMaxIJK); m_outer.m_partitionMinNodeNumbers[___2978] = static_cast<uint64_t>(zoneSize.offsetAtIJK(partitionMinIJK)); m_outer.m_partitionMaxNodeNumbers[___2978] = static_cast<uint64_t>(zoneSize.offsetAtIJK(partitionMaxIJK)); } } exchangeGhostInfo(partitionIJKInfoMap); for (ItemAddress64::___2981 ___2978 = 0; ___2978 < numPartitions; ++___2978) { if (m_outer.___2338.zonePartitionGetOwnerProcess(m_outer.___2678 + 1, ___2978 + 1) == m_localProcess) m_outer.m_partitionWriters[___2978] = boost::make_shared<SZLOrderedPartitionWriter>( m_outer.m_fileVersion, boost::ref(m_outer.m_varIter), m_outer.___2678, m_outer.m_baseZone, ___2978, boost::ref(m_outer.m_writeVariables), m_outer.m_writeConnectivity, boost::ref(m_outer.m_partitionTecUtil), partitionIJKInfoMap[___2978]); } } uint64_t SZLOrderedPartitionedZoneWriterMPI::zoneDataFileSize(bool ___2001) { uint64_t ___3359 = 0; MPICommunicator communicator(m_impl->m_comm); if (m_impl->m_localProcess == m_impl->m_mainProcess) { for (___4636 ___2978 = 0; ___2978 < ___2338.zoneGetNumPartitions(___2678 + 1); ++___2978) { uint64_t partitionFileSize; int32_t partitionOwner = ___2338.zonePartitionGetOwnerProcess(___2678 + 1, ___2978 + 1); if (partitionOwner == m_impl->m_localProcess) partitionFileSize = m_partitionWriters[___2978]->zoneFileSize(___2001);
else communicator.receiveScalar(partitionFileSize, partitionOwner, TecioMPI::PARTITION_FILE_SIZE); ___3359 += partitionFileSize; } } else { for (___4636 ___2978 = 0; ___2978 < ___2338.zoneGetNumPartitions(___2678 + 1); ++___2978) { int32_t partitionOwner = ___2338.zonePartitionGetOwnerProcess(___2678 + 1, ___2978 + 1); if (partitionOwner == m_impl->m_localProcess) { uint64_t partitionFileSize = m_partitionWriters[___2978]->zoneFileSize(___2001); communicator.sendScalar(partitionFileSize, m_impl->m_mainProcess, TecioMPI::PARTITION_FILE_SIZE); } } } return ___3359; } uint64_t SZLOrderedPartitionedZoneWriterMPI::zoneHeaderFileSize(bool ___2001) { if (m_impl->m_localProcess == m_impl->m_mainProcess) return SZLOrderedPartitionedZoneWriter::zoneHeaderFileSize(___2001); else return 0; } ___372 SZLOrderedPartitionedZoneWriterMPI::writeZoneData(___3934::FileWriterInterface& szpltFile) { ___1391 fileLoc = szpltFile.fileLoc(); boost::unordered_map<___4636, ___1391> partitionFileLocMap; uint64_t localPartitionFileSize = 0; if (m_impl->m_useCollectiveRoutines) { ___476(m_partitionWriters.size() == 1); ___4636 localPartition = m_partitionWriters.begin()->first; localPartitionFileSize = m_partitionWriters[localPartition]->zoneFileSize(szpltFile.___2001() == ___4227); gatherScatterPartitionFileLocs(fileLoc, partitionFileLocMap[localPartition], ___2338, ___2678, m_impl->m_localProcess, localPartitionFileSize, m_impl->m_mainProcess, m_impl->m_comm); } else if (m_impl->m_localProcess == m_impl->m_mainProcess) { MPICommunicator communicator(m_impl->m_comm); for (___4636 ___2978 = 0; ___2978 < ___2338.zoneGetNumPartitions(___2678 + 1); ++___2978) { uint64_t partitionFileSize; int32_t partitionOwner = ___2338.zonePartitionGetOwnerProcess(___2678 + 1, ___2978 + 1); if (partitionOwner == m_impl->m_localProcess) { partitionFileLocMap[___2978] = fileLoc; partitionFileSize = m_partitionWriters[___2978]->zoneFileSize(szpltFile.___2001() == ___4227); } else { communicator.sendScalar(fileLoc, partitionOwner, TecioMPI::PARTITION_FILE_LOC); communicator.receiveScalar(partitionFileSize, partitionOwner, TecioMPI::PARTITION_FILE_SIZE); } fileLoc += partitionFileSize; } } else { MPINonBlockingCommunicationCollection communicationCollection(m_impl->m_comm); for (___4636 ___2978 = 0; ___2978 < ___2338.zoneGetNumPartitions(___2678 + 1); ++___2978) { if (___2338.zonePartitionGetOwnerProcess(___2678 + 1, ___2978 + 1) == m_impl->m_localProcess) { uint64_t partitionSize = m_partitionWriters[___2978]->zoneFileSize(szpltFile.___2001() == ___4227); communicationCollection.sendScalarCopy(partitionSize, m_impl->m_mainProcess, TecioMPI::PARTITION_FILE_SIZE); communicationCollection.receiveScalar(partitionFileLocMap[___2978], m_impl->m_mainProcess, TecioMPI::PARTITION_FILE_LOC); } } communicationCollection.___4446(); } if (m_impl->m_useCollectiveRoutines) { ___476(m_partitionWriters.size() == 1 && localPartitionFileSize > 0);
___4636 localPartition = m_partitionWriters.begin()->first; MPIFileWriter& fileWriter = dynamic_cast<MPIFileWriter&>(szpltFile); boost::scoped_ptr<MPIFileWriter::ScopedCaching> scopedCaching; try { scopedCaching.reset(new MPIFileWriter::ScopedCaching(fileWriter, localPartitionFileSize)); } catch (...) { } m_partitionWriters[localPartition]->writeZone(szpltFile, partitionFileLocMap[localPartition]); m_partitionHeaderFilePositions[localPartition] = m_partitionWriters[localPartition]->getZoneHeaderFilePosition(); MPICommunicationCache cache; cache.addScalar(m_partitionHeaderFilePositions[localPartition], TecioMPI::PARTITION_HEADER_FILE_LOC); cache.addScalar(m_partitionMinNodeNumbers[localPartition], TecioMPI::PARTITION_MIN_NODE_NUMBER); cache.addScalar(m_partitionMaxNodeNumbers[localPartition], TecioMPI::PARTITION_MAX_NODE_NUMBER); SimpleVector<___2480> minMaxValues(m_varIter.___2813()); m_varIter.reset(); int i = 0; while (m_varIter.hasNext()) { ___4352 const datasetVar = m_varIter.next(); minMaxValues[i++] = m_partitionWriters[localPartition]->varMinMax(datasetVar); } cache.addVector(minMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); SimpleVector<uint8_t> cachedData = cache.data(); int bytesPerPartition = cachedData.size(); std::vector<uint8_t> serializedCaches(static_cast<size_t>(bytesPerPartition) * ___2338.zoneGetNumPartitions(___2678 + 1)); MPI_Gather(&cachedData[0], bytesPerPartition, MPI_UINT8_T, serializedCaches.data(), bytesPerPartition, MPI_UINT8_T, m_impl->m_mainProcess, m_impl->m_comm); if (m_impl->m_localProcess == m_impl->m_mainProcess) { for (___4636 ___2978 = 0; ___2978 < ___2338.zoneGetNumPartitions(___2678 + 1); ++___2978) { MPICommunicationCache partitionCache(&serializedCaches[___2978 * bytesPerPartition], bytesPerPartition); int32_t partitionOwner = ___2338.zonePartitionGetOwnerProcess(___2678 + 1, ___2978 + 1); partitionCache.retrieveScalar(m_partitionHeaderFilePositions[partitionOwner], TecioMPI::PARTITION_HEADER_FILE_LOC); partitionCache.retrieveScalar(m_partitionMinNodeNumbers[partitionOwner], TecioMPI::PARTITION_MIN_NODE_NUMBER); partitionCache.retrieveScalar(m_partitionMaxNodeNumbers[partitionOwner], TecioMPI::PARTITION_MAX_NODE_NUMBER); SimpleVector<___2480> partitionMinMaxValues; partitionCache.retrieveVector(partitionMinMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); ___476(partitionMinMaxValues.size() == m_varIter.___2813()); m_varIter.reset(); ___4352 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4352 const fileVar = m_varIter.next() - baseVar; m_varPartitionMinMaxes[fileVar][partitionOwner] = partitionMinMaxValues[fileVar]; } } } } else { for (___4636 ___2978 = 0; ___2978 < ___2338.zoneGetNumPartitions(___2678 + 1); ++___2978) { int32_t partitionOwner = ___2338.zonePartitionGetOwnerProcess(___2678 + 1, ___2978 + 1); if (partitionOwner == m_impl->m_localProcess) { m_partitionWriters[___2978]->writeZone(szpltFile, partitionFileLocMap[___2978]);
m_partitionHeaderFilePositions[___2978] = m_partitionWriters[___2978]->getZoneHeaderFilePosition(); if (m_impl->m_localProcess == m_impl->m_mainProcess) { m_varIter.reset(); ___4352 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4352 const datasetVar = m_varIter.next(); m_varPartitionMinMaxes[datasetVar - baseVar][___2978] = m_partitionWriters[___2978]->varMinMax(datasetVar); } } else { MPICommunicationCache cache; cache.addScalar(m_partitionHeaderFilePositions[___2978], TecioMPI::PARTITION_HEADER_FILE_LOC); cache.addScalar(m_partitionMinNodeNumbers[___2978], TecioMPI::PARTITION_MIN_NODE_NUMBER); cache.addScalar(m_partitionMaxNodeNumbers[___2978], TecioMPI::PARTITION_MAX_NODE_NUMBER); SimpleVector<___2480> minMaxValues(m_varIter.___2813()); m_varIter.reset(); int i = 0; while (m_varIter.hasNext()) { ___4352 const datasetVar = m_varIter.next(); minMaxValues[i++] = m_partitionWriters[___2978]->varMinMax(datasetVar); } cache.addVector(minMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); MPICommunicator(m_impl->m_comm).sendVector(cache.data(), m_impl->m_mainProcess, TecioMPI::PARTITION_CACHED_INFO_SIZE, TecioMPI::PARTITION_CACHED_INFO_VEC); } } else if (m_impl->m_localProcess == m_impl->m_mainProcess) { MPICommunicator communicator(m_impl->m_comm); SimpleVector<uint8_t> cachedData; communicator.receiveVector(cachedData, partitionOwner, TecioMPI::PARTITION_CACHED_INFO_SIZE, TecioMPI::PARTITION_CACHED_INFO_VEC); MPICommunicationCache cache(cachedData); cache.retrieveScalar(m_partitionHeaderFilePositions[___2978], TecioMPI::PARTITION_HEADER_FILE_LOC); cache.retrieveScalar(m_partitionMinNodeNumbers[___2978], TecioMPI::PARTITION_MIN_NODE_NUMBER); cache.retrieveScalar(m_partitionMaxNodeNumbers[___2978], TecioMPI::PARTITION_MAX_NODE_NUMBER); SimpleVector<___2480> minMaxValues; cache.retrieveVector(minMaxValues, TecioMPI::PARTITION_VAR_MINMAX_VALUES); ___476(minMaxValues.size() == m_varIter.___2813()); m_varIter.reset(); ___4352 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4352 const fileVar = m_varIter.next() - baseVar; m_varPartitionMinMaxes[fileVar][___2978] = minMaxValues[fileVar]; } } } } if (m_impl->m_localProcess == m_impl->m_mainProcess) szpltFile.___3460(fileLoc);
 #if !defined NO_ASSERTS
if (m_impl->m_localProcess != m_impl->m_mainProcess) szpltFile.___3460(0);
 #endif
return ___4227; } ___372 SZLOrderedPartitionedZoneWriterMPI::writeZoneHeader(___3934::FileWriterInterface& szpltFile) { if (m_impl->m_localProcess == m_impl->m_mainProcess) return SZLOrderedPartitionedZoneWriter::writeZoneHeader(szpltFile); else return ___4227; } } }
