#include "DataSetWriterMPI.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/foreach.hpp>
#include <boost/static_assert.hpp>
#include <boost/unordered_map.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData.h"
#include "FileWriterInterface.h"
#include "ItemSetIterator.h"
#include "MPICommunicator.h"
#include "MPINonBlockingCommunicationCollection.h"
#include "NodeMap.h"
#include "TecioMPI.h"
#include "zoneUtil.h"
#include "ZoneWriterAbstract.h"
#include "ZoneWriterFactoryMPI.h"
using namespace tecplot::___3934; namespace tecplot { namespace teciompi { DataSetWriterMPI::DataSetWriterMPI( ___37*                 ___36, ___3502                      vars, ___3502                      ___4671, ___1843 const&                  maxIJKSubzoneSize, ItemAddress64::ItemOffset_t maxFESubzoneSize, MPI_Comm                    communicator, int                         mainProcess, int                         localProcess, bool                        flushToDisk  ) : DataSetWriter(___36, vars, ___4671, maxIJKSubzoneSize, maxFESubzoneSize, flushToDisk) , m_communicator(communicator) , m_mainProcess(mainProcess) , m_localProcess(localProcess) {} DataSetWriterMPI::~DataSetWriterMPI() {} ___372 DataSetWriterMPI::writeDataSet( FileWriterInterface& szpltFile, uint32_t             fileVersion, ___1390&        szpltZoneHeaderFileLocs) { REQUIRE(szpltFile.___2040()); if (!___2338->___894()) return ___4227; ___372 ___2038 = ___4227; try { ZoneWriterFactoryMPI ___4710(___2681, *___2338, m_communicator, m_mainProcess); boost::unordered_map<___4636, boost::shared_ptr<___4709> > zoneWriterMap; std::vector<int32_t> localZoneIndices; std::vector<int32_t> partitionedZones; int32_t ___2847 = static_cast<int32_t>(m_zoneIter->___2813()); std::vector<int32_t> zoneOwners(___2847, -1); m_zoneIter->reset(); ___4636 const ___341 = m_zoneIter->baseItem(); while (___2038 && m_zoneIter->hasNext()) { ___4636 const ___902 = m_zoneIter->next(); ___4636 const fileZoneIndex = ___902 - ___341; if (!___2338->___4638(___902 + 1)) continue; if (___2338->zoneIsPartitioned(___902 + 1)) zoneOwners[fileZoneIndex] = m_mainProcess; else zoneOwners[fileZoneIndex] = ___2338->zoneGetOwnerProcess(___902 + 1); if (zoneOwners[fileZoneIndex] == m_localProcess) localZoneIndices.push_back(fileZoneIndex); else if (m_localProcess != m_mainProcess) partitionedZones.push_back(fileZoneIndex); if (___2338->zoneIsPartitioned(___902 + 1) || zoneOwners[fileZoneIndex] == m_localProcess) { std::vector<___372> ___4564; ___372 ___4499; getZoneSharing(___4564, ___4499, ___902, ___341, szpltFile.___842()); zoneWriterMap[fileZoneIndex] = ___4710.___4708(fileVersion, *m_varIter, ___902, m_flushingToDisk ? 0 : ___341, ___4564, ___4499); } } int32_t const numLocalZones = static_cast<int32_t>(localZoneIndices.size()); std::vector<uint64_t> localZoneSizes; BOOST_FOREACH(int32_t localZoneIndex, localZoneIndices) localZoneSizes.push_back(zoneWriterMap[localZoneIndex]->zoneFileSize(szpltFile.___2001() == ___4227)); BOOST_FOREACH(int32_t localZoneIndex, partitionedZones) (void)zoneWriterMap[localZoneIndex]->zoneFileSize(szpltFile.___2001() == ___4227); std::vector<uint64_t> zoneSizes(1); std::vector<int32_t> numZonesPerRank(1, 0); std::vector<int32_t> offsets(1, 0); if (m_localProcess == m_mainProcess)
{ int32_t numRanks; MPI_Comm_size(m_communicator, &numRanks); numZonesPerRank.resize(numRanks, 0); offsets.resize(numRanks + 1, 0); BOOST_FOREACH(int32_t owner, zoneOwners) ++numZonesPerRank[owner]; for (int32_t i = 0; i < numRanks; ++i) offsets[i + 1] = offsets[i] + numZonesPerRank[i]; zoneSizes.resize(___2847); } if (localZoneSizes.empty()) localZoneSizes.resize(1); MPI_Gatherv(localZoneSizes.data(), numLocalZones, MPI_UINT64_T, zoneSizes.data(), numZonesPerRank.data(), offsets.data(), MPI_UINT64_T, m_mainProcess, m_communicator); std::vector<uint64_t> zoneFileLocs(1); std::vector<uint64_t> localZoneFileLocs(std::max(1, numLocalZones)); if (m_localProcess == m_mainProcess) { int32_t numRanks; MPI_Comm_size(m_communicator, &numRanks); zoneFileLocs.resize(___2847); std::vector<int32_t> tempNumZonesPerRank(numRanks, 0); ___1391 fileLoc = szpltFile.fileLoc(); for (int i = 0; i < ___2847; ++i) { int32_t const owner = zoneOwners[i]; int32_t const zoneOffset = offsets[owner] + tempNumZonesPerRank[owner]++; zoneFileLocs[zoneOffset] = fileLoc; fileLoc += zoneSizes[zoneOffset]; } } MPI_Scatterv(zoneFileLocs.data(), numZonesPerRank.data(), offsets.data(), MPI_UINT64_T, localZoneFileLocs.data(), numLocalZones, MPI_UINT64_T, m_mainProcess, m_communicator); boost::unordered_map<___4636, ___1391> localZoneFileLocMap; for (int i = 0; i < numLocalZones; ++i) localZoneFileLocMap[localZoneIndices[i]] = localZoneFileLocs[i]; std::vector<uint64_t> localHeaderFileLocations; localHeaderFileLocations.reserve(std::max((size_t)1, localZoneIndices.size())); std::vector<___2480> localMinMaxes; int32_t const ___2844 = m_varIter->___2813(); localMinMaxes.reserve(static_cast<size_t>(___2844) * numLocalZones); m_zoneIter->reset(); while (___2038 && m_zoneIter->hasNext()) { ___4636 const ___902 = m_zoneIter->next(); ___4636 const fileZone = ___902 - ___341; if (!___2338->___4638(___902 + 1)) continue; if (___2338->zoneIsPartitioned(___902 + 1) || zoneOwners[fileZone] == m_localProcess) { ___2038 = zoneWriterMap[fileZone]->writeZone(szpltFile, localZoneFileLocMap[fileZone]); } if (zoneOwners[fileZone] == m_localProcess) { localHeaderFileLocations.push_back(zoneWriterMap[fileZone]->getZoneHeaderFilePosition()); m_varIter->reset(); while (m_varIter->hasNext()) { ___4352 const ___4336 = m_varIter->next(); localMinMaxes.push_back(zoneWriterMap[fileZone]->varMinMax(___4336)); } } zoneWriterMap.erase(fileZone); if (szpltFile.___842() == ___843) ___2681.remove(fileZone); } if (localHeaderFileLocations.empty()) localHeaderFileLocations.resize(1); std::vector<uint64_t> rankOrderZoneHeaderFileLocs(___2847); MPI_Gatherv(localHeaderFileLocations.data(), numLocalZones, MPI_UINT64_T, rankOrderZoneHeaderFileLocs.data(), numZonesPerRank.data(), offsets.data(), MPI_UINT64_T, m_mainProcess, m_communicator); if (m_localProcess == m_mainProcess) { std::vector<int32_t> tempNumZonesPerRank(numZonesPerRank.size(), 0); for(size_t i = 0; i < zoneOwners.size(); ++i)
{ int32_t const owner = zoneOwners[i]; int32_t const zoneOffset = offsets[owner] + tempNumZonesPerRank[owner]++; szpltZoneHeaderFileLocs[i] = rankOrderZoneHeaderFileLocs[zoneOffset]; } ___476(tempNumZonesPerRank == numZonesPerRank); } BOOST_STATIC_ASSERT(sizeof(___2480) == 2 * sizeof(double)); std::vector<___2480> rankOrderMinMaxes(1); std::vector<int32_t> numValuesPerRank(1); if (m_localProcess == m_mainProcess) { rankOrderMinMaxes.resize(___2847 * ___2844); numValuesPerRank.resize(numZonesPerRank.size()); for (size_t i = 0; i < numZonesPerRank.size(); ++i) { numValuesPerRank[i] = 2 * ___2844 * numZonesPerRank[i]; offsets[i] *= (2 * ___2844); } } if (localMinMaxes.empty()) localMinMaxes.resize(1); MPI_Gatherv(localMinMaxes.data(), 2 * numLocalZones * ___2844, MPI_DOUBLE, rankOrderMinMaxes.data(), numValuesPerRank.data(), offsets.data(), MPI_DOUBLE, m_mainProcess, m_communicator); if (m_localProcess == m_mainProcess) { BOOST_FOREACH(int32_t& ___2866, offsets) ___2866 /= 2; std::vector<int32_t> tempNumZonesPerRank(numZonesPerRank.size(), 0); for (size_t zone = 0; zone < zoneOwners.size(); ++zone) { int32_t const owner = zoneOwners[zone]; int32_t const zoneOffset = offsets[owner] + ___2844 * tempNumZonesPerRank[owner]++; for (int ___4336 = 0; ___4336 < ___2844; ++___4336) { ___4636 const shareZone = m_zoneVarMetadata->m_vzShareVarWithZone[___4336][zone]; ___4636 const fileShareZone = shareZone - ___341; ___476(IMPLICATION(shareZone != NOT_SHARED && fileShareZone < 0, m_flushingToDisk)); if (shareZone == NOT_SHARED || fileShareZone < 0) m_zoneVarMetadata->m_vzMinMaxes[___4336][zone] = rankOrderMinMaxes[static_cast<size_t>(zoneOffset) + ___4336]; else m_zoneVarMetadata->m_vzMinMaxes[___4336][zone] = m_zoneVarMetadata->m_vzMinMaxes[___4336][fileShareZone]; } } } } catch(std::exception const& e) { ___2038 = ___1184(e.what()); } return ___2038; } }}
