 #pragma once
#include "ThirdPartyHeadersBegin.h"
#  include <string>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "stringformat.h"
namespace tecplot { namespace ___3934 { class IODescription { public: typedef uint32_t SegmentIndex_t; static ___4352 const                 NO_VAR = BAD_VAR_INDEX; static ___4636 const                NO_ZONE = BAD_ZONE_INDEX; static ItemAddress64::___2981 const NO_PARTITION = ItemAddress64::INVALID_PARTITION; static SegmentIndex_t const             NO_SEGMENT = SegmentIndex_t(-1); private: char const*                ___2496; ___4352                 m_var; ___4636                ___2678; ItemAddress64::___2981 m_partition; SegmentIndex_t             m_segment; char const*                m_suffix; public: explicit IODescription( char const*                ___2686 = NULL, ___4352                 ___4336 = NO_VAR, ___4636                zone = NO_ZONE, ItemAddress64::___2981 ___2978 = NO_PARTITION, SegmentIndex_t             segment = NO_SEGMENT, char const*                suffix = NULL) : ___2496(___2686) , m_var(___4336) , ___2678(zone) , m_partition(___2978) , m_segment(segment) , m_suffix(suffix) {} char const* ___2686() const { return ___2496; } ___4352 ___4336() const { return m_var; } ___4636 zone() const { return ___2678; } ItemAddress64::___2981 ___2978() const { return m_partition; } SegmentIndex_t segment() const { return m_segment; } char const* suffix() const { return m_suffix; } ___372 ___2066() const { return ___4227; } ___372 isEmpty() const { return ___2496==NULL; } void getFormattedDescription( char*  formattedDescription, size_t formattedDescriptionSize) const { ___372 isAsciiOnly = ___1303; size_t ___2866; if ( ___2496 != NULL ) { ___2866 = snprintf(formattedDescription, formattedDescriptionSize, "%s", ___2496); if ( ___2866 > 0 && formattedDescription[___2866-1] == '*' ) { ___2866--; formattedDescription[___2866] = '\0'; isAsciiOnly = ___4227; } } else ___2866 = snprintf(formattedDescription, formattedDescriptionSize, "unspecified"); if ( m_var != NO_VAR && ___2866 < formattedDescriptionSize ) ___2866 += snprintf(formattedDescription+___2866, formattedDescriptionSize-___2866, "%sVar%" PRIu64, ___2496 != NULL ? "For" : "", uint64_t(m_var+1)); if ( ___2678 != NO_ZONE && ___2866 < formattedDescriptionSize ) ___2866 += snprintf(formattedDescription+___2866, formattedDescriptionSize-___2866, "%sZone%" PRIu64, ___2496 != NULL && m_var == NO_VAR ? "For" : "", uint64_t(___2678+1)); if ( m_partition != NO_PARTITION && ___2866 < formattedDescriptionSize ) ___2866 += snprintf(formattedDescription+___2866, formattedDescriptionSize-___2866, "%sPartition%" PRIu64, ___2496 != NULL && m_var == NO_VAR && ___2678 == NO_ZONE ? "For" : "", uint64_t(m_partition+1)); if ( m_segment != NO_SEGMENT && ___2866 < formattedDescriptionSize ) ___2866 += snprintf(formattedDescription+___2866, formattedDescriptionSize-___2866, "%sSegment%" PRIu64, ___2496 != NULL && m_var == NO_VAR && ___2678 == NO_ZONE && m_partition == NO_PARTITION ? "For" : "", uint64_t(m_segment+1)); if ( m_suffix != NULL && ___2866 < formattedDescriptionSize ) ___2866 += snprintf(formattedDescription+___2866, formattedDescriptionSize-___2866, "%s", m_suffix);
if ( isAsciiOnly && ___2866 < formattedDescriptionSize ) { formattedDescription[___2866] = '*'; if ( ___2866 < formattedDescriptionSize ) ___2866++; formattedDescription[___2866] = '\0'; } } }; }}
